#!/usr/bin/env node --loader @esbuild-kit/esm-loader --no-warnings
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/.pnpm/chalk@5.2.0/node_modules/chalk/source/vendor/ansi-styles/index.js
function assembleStyles() {
  const codes = /* @__PURE__ */ new Map();
  for (const [groupName, group] of Object.entries(styles)) {
    for (const [styleName, style] of Object.entries(group)) {
      styles[styleName] = {
        open: `\x1B[${style[0]}m`,
        close: `\x1B[${style[1]}m`
      };
      group[styleName] = styles[styleName];
      codes.set(style[0], style[1]);
    }
    Object.defineProperty(styles, groupName, {
      value: group,
      enumerable: false
    });
  }
  Object.defineProperty(styles, "codes", {
    value: codes,
    enumerable: false
  });
  styles.color.close = "\x1B[39m";
  styles.bgColor.close = "\x1B[49m";
  styles.color.ansi = wrapAnsi16();
  styles.color.ansi256 = wrapAnsi256();
  styles.color.ansi16m = wrapAnsi16m();
  styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
  styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);
  Object.defineProperties(styles, {
    rgbToAnsi256: {
      value(red, green, blue) {
        if (red === green && green === blue) {
          if (red < 8) {
            return 16;
          }
          if (red > 248) {
            return 231;
          }
          return Math.round((red - 8) / 247 * 24) + 232;
        }
        return 16 + 36 * Math.round(red / 255 * 5) + 6 * Math.round(green / 255 * 5) + Math.round(blue / 255 * 5);
      },
      enumerable: false
    },
    hexToRgb: {
      value(hex) {
        const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
        if (!matches) {
          return [0, 0, 0];
        }
        let [colorString] = matches;
        if (colorString.length === 3) {
          colorString = [...colorString].map((character) => character + character).join("");
        }
        const integer = Number.parseInt(colorString, 16);
        return [
          /* eslint-disable no-bitwise */
          integer >> 16 & 255,
          integer >> 8 & 255,
          integer & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: false
    },
    hexToAnsi256: {
      value: (hex) => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
      enumerable: false
    },
    ansi256ToAnsi: {
      value(code) {
        if (code < 8) {
          return 30 + code;
        }
        if (code < 16) {
          return 90 + (code - 8);
        }
        let red;
        let green;
        let blue;
        if (code >= 232) {
          red = ((code - 232) * 10 + 8) / 255;
          green = red;
          blue = red;
        } else {
          code -= 16;
          const remainder = code % 36;
          red = Math.floor(code / 36) / 5;
          green = Math.floor(remainder / 6) / 5;
          blue = remainder % 6 / 5;
        }
        const value = Math.max(red, green, blue) * 2;
        if (value === 0) {
          return 30;
        }
        let result = 30 + (Math.round(blue) << 2 | Math.round(green) << 1 | Math.round(red));
        if (value === 2) {
          result += 60;
        }
        return result;
      },
      enumerable: false
    },
    rgbToAnsi: {
      value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
      enumerable: false
    },
    hexToAnsi: {
      value: (hex) => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
      enumerable: false
    }
  });
  return styles;
}
var ANSI_BACKGROUND_OFFSET, wrapAnsi16, wrapAnsi256, wrapAnsi16m, styles, modifierNames, foregroundColorNames, backgroundColorNames, colorNames, ansiStyles, ansi_styles_default;
var init_ansi_styles = __esm({
  "node_modules/.pnpm/chalk@5.2.0/node_modules/chalk/source/vendor/ansi-styles/index.js"() {
    ANSI_BACKGROUND_OFFSET = 10;
    wrapAnsi16 = (offset = 0) => (code) => `\x1B[${code + offset}m`;
    wrapAnsi256 = (offset = 0) => (code) => `\x1B[${38 + offset};5;${code}m`;
    wrapAnsi16m = (offset = 0) => (red, green, blue) => `\x1B[${38 + offset};2;${red};${green};${blue}m`;
    styles = {
      modifier: {
        reset: [0, 0],
        // 21 isn't widely supported and 22 does the same thing
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        overline: [53, 55],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29]
      },
      color: {
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        // Bright color
        blackBright: [90, 39],
        gray: [90, 39],
        // Alias of `blackBright`
        grey: [90, 39],
        // Alias of `blackBright`
        redBright: [91, 39],
        greenBright: [92, 39],
        yellowBright: [93, 39],
        blueBright: [94, 39],
        magentaBright: [95, 39],
        cyanBright: [96, 39],
        whiteBright: [97, 39]
      },
      bgColor: {
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // Bright color
        bgBlackBright: [100, 49],
        bgGray: [100, 49],
        // Alias of `bgBlackBright`
        bgGrey: [100, 49],
        // Alias of `bgBlackBright`
        bgRedBright: [101, 49],
        bgGreenBright: [102, 49],
        bgYellowBright: [103, 49],
        bgBlueBright: [104, 49],
        bgMagentaBright: [105, 49],
        bgCyanBright: [106, 49],
        bgWhiteBright: [107, 49]
      }
    };
    modifierNames = Object.keys(styles.modifier);
    foregroundColorNames = Object.keys(styles.color);
    backgroundColorNames = Object.keys(styles.bgColor);
    colorNames = [...foregroundColorNames, ...backgroundColorNames];
    ansiStyles = assembleStyles();
    ansi_styles_default = ansiStyles;
  }
});

// node_modules/.pnpm/chalk@5.2.0/node_modules/chalk/source/vendor/supports-color/index.js
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : import_node_process.default.argv) {
  const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
  const position = argv.indexOf(prefix + flag);
  const terminatorPosition = argv.indexOf("--");
  return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}
function envForceColor() {
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      return 1;
    }
    if (env.FORCE_COLOR === "false") {
      return 0;
    }
    return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
  }
}
function translateLevel(level) {
  if (level === 0) {
    return false;
  }
  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}
function _supportsColor(haveStream, { streamIsTTY, sniffFlags = true } = {}) {
  const noFlagForceColor = envForceColor();
  if (noFlagForceColor !== void 0) {
    flagForceColor = noFlagForceColor;
  }
  const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;
  if (forceColor === 0) {
    return 0;
  }
  if (sniffFlags) {
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
  }
  if ("TF_BUILD" in env && "AGENT_NAME" in env) {
    return 1;
  }
  if (haveStream && !streamIsTTY && forceColor === void 0) {
    return 0;
  }
  const min = forceColor || 0;
  if (env.TERM === "dumb") {
    return min;
  }
  if (import_node_process.default.platform === "win32") {
    const osRelease = import_node_os.default.release().split(".");
    if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }
    return 1;
  }
  if ("CI" in env) {
    if ("GITHUB_ACTIONS" in env) {
      return 3;
    }
    if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "BUILDKITE", "DRONE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
      return 1;
    }
    return min;
  }
  if ("TEAMCITY_VERSION" in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }
  if (env.COLORTERM === "truecolor") {
    return 3;
  }
  if (env.TERM === "xterm-kitty") {
    return 3;
  }
  if ("TERM_PROGRAM" in env) {
    const version = Number.parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
    switch (env.TERM_PROGRAM) {
      case "iTerm.app": {
        return version >= 3 ? 3 : 2;
      }
      case "Apple_Terminal": {
        return 2;
      }
    }
  }
  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }
  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }
  if ("COLORTERM" in env) {
    return 1;
  }
  return min;
}
function createSupportsColor(stream, options = {}) {
  const level = _supportsColor(stream, {
    streamIsTTY: stream && stream.isTTY,
    ...options
  });
  return translateLevel(level);
}
var import_node_process, import_node_os, import_node_tty, env, flagForceColor, supportsColor, supports_color_default;
var init_supports_color = __esm({
  "node_modules/.pnpm/chalk@5.2.0/node_modules/chalk/source/vendor/supports-color/index.js"() {
    import_node_process = __toESM(require("node:process"), 1);
    import_node_os = __toESM(require("node:os"), 1);
    import_node_tty = __toESM(require("node:tty"), 1);
    ({ env } = import_node_process.default);
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      flagForceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      flagForceColor = 1;
    }
    supportsColor = {
      stdout: createSupportsColor({ isTTY: import_node_tty.default.isatty(1) }),
      stderr: createSupportsColor({ isTTY: import_node_tty.default.isatty(2) })
    };
    supports_color_default = supportsColor;
  }
});

// node_modules/.pnpm/chalk@5.2.0/node_modules/chalk/source/utilities.js
function stringReplaceAll(string, substring, replacer) {
  let index4 = string.indexOf(substring);
  if (index4 === -1) {
    return string;
  }
  const substringLength = substring.length;
  let endIndex = 0;
  let returnValue = "";
  do {
    returnValue += string.slice(endIndex, index4) + substring + replacer;
    endIndex = index4 + substringLength;
    index4 = string.indexOf(substring, endIndex);
  } while (index4 !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index4) {
  let endIndex = 0;
  let returnValue = "";
  do {
    const gotCR = string[index4 - 1] === "\r";
    returnValue += string.slice(endIndex, gotCR ? index4 - 1 : index4) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
    endIndex = index4 + 1;
    index4 = string.indexOf("\n", endIndex);
  } while (index4 !== -1);
  returnValue += string.slice(endIndex);
  return returnValue;
}
var init_utilities = __esm({
  "node_modules/.pnpm/chalk@5.2.0/node_modules/chalk/source/utilities.js"() {
  }
});

// node_modules/.pnpm/chalk@5.2.0/node_modules/chalk/source/index.js
function createChalk(options) {
  return chalkFactory(options);
}
var stdoutColor, stderrColor, GENERATOR, STYLER, IS_EMPTY, levelMapping, styles2, applyOptions, chalkFactory, getModelAnsi, usedModels, proto, createStyler, createBuilder, applyStyle, chalk, chalkStderr, source_default;
var init_source = __esm({
  "node_modules/.pnpm/chalk@5.2.0/node_modules/chalk/source/index.js"() {
    init_ansi_styles();
    init_supports_color();
    init_utilities();
    init_ansi_styles();
    ({ stdout: stdoutColor, stderr: stderrColor } = supports_color_default);
    GENERATOR = Symbol("GENERATOR");
    STYLER = Symbol("STYLER");
    IS_EMPTY = Symbol("IS_EMPTY");
    levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    styles2 = /* @__PURE__ */ Object.create(null);
    applyOptions = (object, options = {}) => {
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    };
    chalkFactory = (options) => {
      const chalk2 = (...strings) => strings.join(" ");
      applyOptions(chalk2, options);
      Object.setPrototypeOf(chalk2, createChalk.prototype);
      return chalk2;
    };
    Object.setPrototypeOf(createChalk.prototype, Function.prototype);
    for (const [styleName, style] of Object.entries(ansi_styles_default)) {
      styles2[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
          Object.defineProperty(this, styleName, { value: builder });
          return builder;
        }
      };
    }
    styles2.visible = {
      get() {
        const builder = createBuilder(this, this[STYLER], true);
        Object.defineProperty(this, "visible", { value: builder });
        return builder;
      }
    };
    getModelAnsi = (model, level, type, ...arguments_) => {
      if (model === "rgb") {
        if (level === "ansi16m") {
          return ansi_styles_default[type].ansi16m(...arguments_);
        }
        if (level === "ansi256") {
          return ansi_styles_default[type].ansi256(ansi_styles_default.rgbToAnsi256(...arguments_));
        }
        return ansi_styles_default[type].ansi(ansi_styles_default.rgbToAnsi(...arguments_));
      }
      if (model === "hex") {
        return getModelAnsi("rgb", level, type, ...ansi_styles_default.hexToRgb(...arguments_));
      }
      return ansi_styles_default[type][model](...arguments_);
    };
    usedModels = ["rgb", "hex", "ansi256"];
    for (const model of usedModels) {
      styles2[model] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(getModelAnsi(model, levelMapping[level], "color", ...arguments_), ansi_styles_default.color.close, this[STYLER]);
            return createBuilder(this, styler, this[IS_EMPTY]);
          };
        }
      };
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles2[bgModel] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(getModelAnsi(model, levelMapping[level], "bgColor", ...arguments_), ansi_styles_default.bgColor.close, this[STYLER]);
            return createBuilder(this, styler, this[IS_EMPTY]);
          };
        }
      };
    }
    proto = Object.defineProperties(() => {
    }, {
      ...styles2,
      level: {
        enumerable: true,
        get() {
          return this[GENERATOR].level;
        },
        set(level) {
          this[GENERATOR].level = level;
        }
      }
    });
    createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    createBuilder = (self2, _styler, _isEmpty) => {
      const builder = (...arguments_) => applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      Object.setPrototypeOf(builder, proto);
      builder[GENERATOR] = self2;
      builder[STYLER] = _styler;
      builder[IS_EMPTY] = _isEmpty;
      return builder;
    };
    applyStyle = (self2, string) => {
      if (self2.level <= 0 || !string) {
        return self2[IS_EMPTY] ? "" : string;
      }
      let styler = self2[STYLER];
      if (styler === void 0) {
        return string;
      }
      const { openAll, closeAll } = styler;
      if (string.includes("\x1B")) {
        while (styler !== void 0) {
          string = stringReplaceAll(string, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string.indexOf("\n");
      if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
      }
      return openAll + string + closeAll;
    };
    Object.defineProperties(createChalk.prototype, styles2);
    chalk = createChalk();
    chalkStderr = createChalk({ level: stderrColor ? stderrColor.level : 0 });
    source_default = chalk;
  }
});

// node_modules/.pnpm/hanji@0.0.5/node_modules/hanji/readline.js
var require_readline = __commonJS({
  "node_modules/.pnpm/hanji@0.0.5/node_modules/hanji/readline.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prepareReadLine = void 0;
    var prepareReadLine = () => {
      const stdin = process.stdin;
      const stdout = process.stdout;
      const readline = require("readline");
      const rl = readline.createInterface({
        input: stdin,
        escapeCodeTimeout: 50
      });
      readline.emitKeypressEvents(stdin, rl);
      return {
        stdin,
        stdout,
        closable: rl
      };
    };
    exports.prepareReadLine = prepareReadLine;
  }
});

// node_modules/.pnpm/sisteransi@1.0.5/node_modules/sisteransi/src/index.js
var require_src = __commonJS({
  "node_modules/.pnpm/sisteransi@1.0.5/node_modules/sisteransi/src/index.js"(exports, module2) {
    "use strict";
    var ESC = "\x1B";
    var CSI = `${ESC}[`;
    var beep = "\x07";
    var cursor = {
      to(x, y) {
        if (!y)
          return `${CSI}${x + 1}G`;
        return `${CSI}${y + 1};${x + 1}H`;
      },
      move(x, y) {
        let ret = "";
        if (x < 0)
          ret += `${CSI}${-x}D`;
        else if (x > 0)
          ret += `${CSI}${x}C`;
        if (y < 0)
          ret += `${CSI}${-y}A`;
        else if (y > 0)
          ret += `${CSI}${y}B`;
        return ret;
      },
      up: (count = 1) => `${CSI}${count}A`,
      down: (count = 1) => `${CSI}${count}B`,
      forward: (count = 1) => `${CSI}${count}C`,
      backward: (count = 1) => `${CSI}${count}D`,
      nextLine: (count = 1) => `${CSI}E`.repeat(count),
      prevLine: (count = 1) => `${CSI}F`.repeat(count),
      left: `${CSI}G`,
      hide: `${CSI}?25l`,
      show: `${CSI}?25h`,
      save: `${ESC}7`,
      restore: `${ESC}8`
    };
    var scroll = {
      up: (count = 1) => `${CSI}S`.repeat(count),
      down: (count = 1) => `${CSI}T`.repeat(count)
    };
    var erase = {
      screen: `${CSI}2J`,
      up: (count = 1) => `${CSI}1J`.repeat(count),
      down: (count = 1) => `${CSI}J`.repeat(count),
      line: `${CSI}2K`,
      lineEnd: `${CSI}K`,
      lineStart: `${CSI}1K`,
      lines(count) {
        let clear = "";
        for (let i = 0; i < count; i++)
          clear += this.line + (i < count - 1 ? cursor.up() : "");
        if (count)
          clear += cursor.left;
        return clear;
      }
    };
    module2.exports = { cursor, scroll, erase, beep };
  }
});

// node_modules/.pnpm/hanji@0.0.5/node_modules/hanji/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/hanji@0.0.5/node_modules/hanji/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.clear = void 0;
    var sisteransi_1 = require_src();
    var strip = (str) => {
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))"
      ].join("|");
      const RGX = new RegExp(pattern, "g");
      return typeof str === "string" ? str.replace(RGX, "") : str;
    };
    var stringWidth = (str) => [...strip(str)].length;
    var clear = function(prompt, perLine) {
      if (!perLine)
        return sisteransi_1.erase.line + sisteransi_1.cursor.to(0);
      let rows = 0;
      const lines = prompt.split(/\r?\n/);
      for (let line of lines) {
        rows += 1 + Math.floor(Math.max(stringWidth(line) - 1, 0) / perLine);
      }
      return sisteransi_1.erase.lines(rows);
    };
    exports.clear = clear;
  }
});

// node_modules/.pnpm/lodash.throttle@4.1.1/node_modules/lodash.throttle/index.js
var require_lodash = __commonJS({
  "node_modules/.pnpm/lodash.throttle@4.1.1/node_modules/lodash.throttle/index.js"(exports, module2) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }
    function throttle(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = throttle;
  }
});

// node_modules/.pnpm/hanji@0.0.5/node_modules/hanji/index.js
var require_hanji = __commonJS({
  "node_modules/.pnpm/hanji@0.0.5/node_modules/hanji/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.onTerminate = exports.renderWithTask = exports.render = exports.TaskTerminal = exports.TaskView = exports.Terminal = exports.deferred = exports.SelectState = exports.Prompt = void 0;
    var readline_1 = require_readline();
    var sisteransi_1 = require_src();
    var utils_1 = require_utils();
    var lodash_throttle_1 = __importDefault(require_lodash());
    var Prompt2 = class {
      constructor() {
        this.attachCallbacks = [];
        this.detachCallbacks = [];
        this.inputCallbacks = [];
      }
      requestLayout() {
        this.terminal.requestLayout();
      }
      on(type, callback) {
        if (type === "attach") {
          this.attachCallbacks.push(callback);
        } else if (type === "detach") {
          this.detachCallbacks.push(callback);
        } else if (type === "input") {
          this.inputCallbacks.push(callback);
        }
      }
      attach(terminal) {
        this.terminal = terminal;
        this.attachCallbacks.forEach((it) => it(terminal));
      }
      detach(terminal) {
        this.detachCallbacks.forEach((it) => it(terminal));
        this.terminal = void 0;
      }
      input(str, key) {
        this.inputCallbacks.forEach((it) => it(str, key));
      }
    };
    exports.Prompt = Prompt2;
    var SelectState2 = class {
      constructor(items) {
        this.items = items;
        this.selectedIdx = 0;
      }
      bind(prompt) {
        prompt.on("input", (str, key) => {
          const invalidate = this.consume(str, key);
          if (invalidate)
            prompt.requestLayout();
        });
      }
      consume(str, key) {
        if (!key)
          return false;
        if (key.name === "down") {
          this.selectedIdx = (this.selectedIdx + 1) % this.items.length;
          return true;
        }
        if (key.name === "up") {
          this.selectedIdx -= 1;
          this.selectedIdx = this.selectedIdx < 0 ? this.items.length - 1 : this.selectedIdx;
          return true;
        }
        return false;
      }
    };
    exports.SelectState = SelectState2;
    var deferred = () => {
      let resolve;
      let reject;
      const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      return {
        resolve,
        reject,
        promise
      };
    };
    exports.deferred = deferred;
    var Terminal = class {
      constructor(view, stdin, stdout, closable) {
        this.view = view;
        this.stdin = stdin;
        this.stdout = stdout;
        this.closable = closable;
        this.text = "";
        this.status = "idle";
        if (this.stdin.isTTY)
          this.stdin.setRawMode(true);
        const keypress = (str, key) => {
          if (key.name === "c" && key.ctrl === true) {
            this.requestLayout();
            this.view.detach(this);
            this.tearDown(keypress);
            if (terminateHandler) {
              terminateHandler(this.stdin, this.stdout);
              return;
            }
            this.stdout.write(`
^C
`);
            process.exit(1);
          }
          if (key.name === "escape") {
            this.status = "aborted";
            this.requestLayout();
            this.view.detach(this);
            this.tearDown(keypress);
            this.resolve({ status: "aborted", data: void 0 });
            return;
          }
          if (key.name === "return") {
            this.status = "submitted";
            this.requestLayout();
            this.view.detach(this);
            this.tearDown(keypress);
            this.resolve({ status: "submitted", data: this.view.result() });
            return;
          }
          view.input(str, key);
        };
        this.stdin.on("keypress", keypress);
        this.view.attach(this);
        const { resolve, promise } = (0, exports.deferred)();
        this.resolve = resolve;
        this.promise = promise;
        this.renderFunc = (0, lodash_throttle_1.default)((str) => {
          this.stdout.write(str);
        });
      }
      tearDown(keypress) {
        this.stdout.write(sisteransi_1.cursor.show);
        this.stdin.removeListener("keypress", keypress);
        if (this.stdin.isTTY)
          this.stdin.setRawMode(false);
        this.closable.close();
      }
      result() {
        return this.promise;
      }
      toggleCursor(state) {
        if (state === "hide") {
          this.stdout.write(sisteransi_1.cursor.hide);
        } else {
          this.stdout.write(sisteransi_1.cursor.show);
        }
      }
      requestLayout() {
        const string = this.view.render(this.status);
        const clearPrefix = this.text ? (0, utils_1.clear)(this.text, this.stdout.columns) : "";
        this.text = string;
        this.renderFunc(`${clearPrefix}${string}`);
      }
    };
    exports.Terminal = Terminal;
    var TaskView2 = class {
      constructor() {
        this.attachCallbacks = [];
        this.detachCallbacks = [];
      }
      requestLayout() {
        this.terminal.requestLayout();
      }
      attach(terminal) {
        this.terminal = terminal;
        this.attachCallbacks.forEach((it) => it(terminal));
      }
      detach(terminal) {
        this.detachCallbacks.forEach((it) => it(terminal));
        this.terminal = void 0;
      }
      on(type, callback) {
        if (type === "attach") {
          this.attachCallbacks.push(callback);
        } else if (type === "detach") {
          this.detachCallbacks.push(callback);
        }
      }
    };
    exports.TaskView = TaskView2;
    var TaskTerminal = class {
      constructor(view, stdout) {
        this.view = view;
        this.stdout = stdout;
        this.text = "";
        this.view.attach(this);
      }
      requestLayout() {
        const string = this.view.render("pending");
        const clearPrefix = this.text ? (0, utils_1.clear)(this.text, this.stdout.columns) : "";
        this.text = string;
        this.stdout.write(`${clearPrefix}${string}`);
      }
      clear() {
        const string = this.view.render("done");
        this.view.detach(this);
        const clearPrefix = this.text ? (0, utils_1.clear)(this.text, this.stdout.columns) : "";
        this.stdout.write(`${clearPrefix}${string}`);
      }
    };
    exports.TaskTerminal = TaskTerminal;
    function render3(view) {
      const { stdin, stdout, closable } = (0, readline_1.prepareReadLine)();
      if (view instanceof Prompt2) {
        const terminal = new Terminal(view, stdin, stdout, closable);
        terminal.requestLayout();
        return terminal.result();
      }
      stdout.write(`${view}
`);
      closable.close();
      return;
    }
    exports.render = render3;
    function renderWithTask(view, task) {
      return __awaiter(this, void 0, void 0, function* () {
        const terminal = new TaskTerminal(view, process.stdout);
        terminal.requestLayout();
        const result = yield task;
        terminal.clear();
        return result;
      });
    }
    exports.renderWithTask = renderWithTask;
    var terminateHandler;
    function onTerminate(callback) {
      terminateHandler = callback;
    }
    exports.onTerminate = onTerminate;
  }
});

// src/cli/views.ts
var import_hanji, info;
var init_views = __esm({
  "src/cli/views.ts"() {
    init_source();
    import_hanji = __toESM(require_hanji());
    info = (msg, greyMsg = "") => {
      return `${source_default.blue.bold("Info:")} ${msg} ${greyMsg ? source_default.grey(greyMsg) : ""}`.trim();
    };
  }
});

// node_modules/.pnpm/zod@3.20.2/node_modules/zod/lib/index.mjs
function getErrorMap() {
  return overrideErrorMap;
}
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
function deepPartialify(schema4) {
  if (schema4 instanceof ZodObject) {
    const newShape = {};
    for (const key in schema4.shape) {
      const fieldSchema = schema4.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema4._def,
      shape: () => newShape
    });
  } else if (schema4 instanceof ZodArray) {
    return ZodArray.create(deepPartialify(schema4.element));
  } else if (schema4 instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema4.unwrap()));
  } else if (schema4 instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema4.unwrap()));
  } else if (schema4 instanceof ZodTuple) {
    return ZodTuple.create(schema4.items.map((item) => deepPartialify(item)));
  } else {
    return schema4;
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index4 = 0; index4 < a.length; index4++) {
      const itemA = a[index4];
      const itemB = b[index4];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var util, ZodParsedType, getParsedType, ZodIssueCode, ZodError, errorMap, overrideErrorMap, makeIssue, ParseStatus, INVALID, DIRTY, OK, isAborted, isDirty, isValid, isAsync, errorUtil, ParseInputLazyPath, handleResult, ZodType, cuidRegex, uuidRegex, emailRegex, datetimeRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, objectUtil, AugmentFactory, ZodObject, ZodUnion, getDiscriminator, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodFunction, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodCatch, ZodNaN, BRAND, ZodBranded, ZodPipeline, late, ZodFirstPartyTypeKind, stringType, numberType, nanType, bigIntType, booleanType, dateType, symbolType, undefinedType, nullType, anyType, unknownType, neverType, voidType, arrayType, objectType, strictObjectType, unionType, discriminatedUnionType, intersectionType, tupleType, recordType, mapType, setType, functionType, lazyType, literalType, enumType, nativeEnumType, promiseType, effectsType, optionalType, nullableType, preprocessType, pipelineType;
var init_lib = __esm({
  "node_modules/.pnpm/zod@3.20.2/node_modules/zod/lib/index.mjs"() {
    (function(util2) {
      util2.assertEqual = (val) => val;
      function assertIs(_arg) {
      }
      util2.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      util2.assertNever = assertNever;
      util2.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util2.getValidEnumValues = (obj) => {
        const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
          filtered[k] = obj[k];
        }
        return util2.objectValues(filtered);
      };
      util2.objectValues = (obj) => {
        return util2.objectKeys(obj).map(function(e) {
          return obj[e];
        });
      };
      util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
        const keys = [];
        for (const key in object) {
          if (Object.prototype.hasOwnProperty.call(object, key)) {
            keys.push(key);
          }
        }
        return keys;
      };
      util2.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
      function joinValues(array, separator = " | ") {
        return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      util2.joinValues = joinValues;
      util2.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util || (util = {}));
    ZodParsedType = util.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    getParsedType = (data) => {
      const t = typeof data;
      switch (t) {
        case "undefined":
          return ZodParsedType.undefined;
        case "string":
          return ZodParsedType.string;
        case "number":
          return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
          return ZodParsedType.boolean;
        case "function":
          return ZodParsedType.function;
        case "bigint":
          return ZodParsedType.bigint;
        case "symbol":
          return ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return ZodParsedType.array;
          }
          if (data === null) {
            return ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return ZodParsedType.date;
          }
          return ZodParsedType.object;
        default:
          return ZodParsedType.unknown;
      }
    };
    ZodIssueCode = util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    ZodError = class extends Error {
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      get errors() {
        return this.issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue) {
          return issue.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
          for (const issue of error.issues) {
            if (issue.code === "invalid_union") {
              issue.unionErrors.map(processError);
            } else if (issue.code === "invalid_return_type") {
              processError(issue.returnTypeError);
            } else if (issue.code === "invalid_arguments") {
              processError(issue.argumentsError);
            } else if (issue.path.length === 0) {
              fieldErrors._errors.push(mapper(issue));
            } else {
              let curr = fieldErrors;
              let i = 0;
              while (i < issue.path.length) {
                const el = issue.path[i];
                const terminal = i === issue.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue));
                }
                curr = curr[el];
                i++;
              }
            }
          }
        };
        processError(this);
        return fieldErrors;
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
            fieldErrors[sub.path[0]].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    ZodError.create = (issues) => {
      const error = new ZodError(issues);
      return error;
    };
    errorMap = (issue, _ctx) => {
      let message;
      switch (issue.code) {
        case ZodIssueCode.invalid_type:
          if (issue.received === ZodParsedType.undefined) {
            message = "Required";
          } else {
            message = `Expected ${issue.expected}, received ${issue.received}`;
          }
          break;
        case ZodIssueCode.invalid_literal:
          message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
          break;
        case ZodIssueCode.unrecognized_keys:
          message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
          break;
        case ZodIssueCode.invalid_union:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_union_discriminator:
          message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
          break;
        case ZodIssueCode.invalid_enum_value:
          message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodIssueCode.invalid_arguments:
          message = `Invalid function arguments`;
          break;
        case ZodIssueCode.invalid_return_type:
          message = `Invalid function return type`;
          break;
        case ZodIssueCode.invalid_date:
          message = `Invalid date`;
          break;
        case ZodIssueCode.invalid_string:
          if (typeof issue.validation === "object") {
            if ("startsWith" in issue.validation) {
              message = `Invalid input: must start with "${issue.validation.startsWith}"`;
            } else if ("endsWith" in issue.validation) {
              message = `Invalid input: must end with "${issue.validation.endsWith}"`;
            } else {
              util.assertNever(issue.validation);
            }
          } else if (issue.validation !== "regex") {
            message = `Invalid ${issue.validation}`;
          } else {
            message = "Invalid";
          }
          break;
        case ZodIssueCode.too_small:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(issue.minimum)}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.too_big:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(issue.maximum)}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.custom:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_intersection_types:
          message = `Intersection results could not be merged`;
          break;
        case ZodIssueCode.not_multiple_of:
          message = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodIssueCode.not_finite:
          message = "Number must be finite";
          break;
        default:
          message = _ctx.defaultError;
          util.assertNever(issue);
      }
      return { message };
    };
    overrideErrorMap = errorMap;
    makeIssue = (params) => {
      const { data, path, errorMaps, issueData } = params;
      const fullPath = [...path, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      let errorMessage = "";
      const maps = errorMaps.filter((m) => !!m).slice().reverse();
      for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: issueData.message || errorMessage
      };
    };
    ParseStatus = class _ParseStatus {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
          if (s.status === "aborted")
            return INVALID;
          if (s.status === "dirty")
            status.dirty();
          arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          syncPairs.push({
            key: await pair.key,
            value: await pair.value
          });
        }
        return _ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key, value } = pair;
          if (key.status === "aborted")
            return INVALID;
          if (value.status === "aborted")
            return INVALID;
          if (key.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (typeof value.value !== "undefined" || pair.alwaysSet) {
            finalObject[key.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    };
    INVALID = Object.freeze({
      status: "aborted"
    });
    DIRTY = (value) => ({ status: "dirty", value });
    OK = (value) => ({ status: "valid", value });
    isAborted = (x) => x.status === "aborted";
    isDirty = (x) => x.status === "dirty";
    isValid = (x) => x.status === "valid";
    isAsync = (x) => typeof Promise !== void 0 && x instanceof Promise;
    (function(errorUtil2) {
      errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
      errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
    })(errorUtil || (errorUtil = {}));
    ParseInputLazyPath = class {
      constructor(parent, value, path, key) {
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
      }
      get path() {
        return this._path.concat(this._key);
      }
    };
    handleResult = (ctx, result) => {
      if (isValid(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        const error = new ZodError(ctx.common.issues);
        return { success: false, error };
      }
    };
    ZodType = class {
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
      }
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return getParsedType(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params) {
        var _a;
        const ctx = {
          common: {
            issues: [],
            async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
      }
      async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
            async: true
          },
          path: (params === null || params === void 0 ? void 0 : params.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
      }
      refine(check, message) {
        const getIssueProperties = (val) => {
          if (typeof message === "string" || typeof message === "undefined") {
            return { message };
          } else if (typeof message === "function") {
            return message(val);
          } else {
            return message;
          }
        };
        return this._refinement((val, ctx) => {
          const result = check(val);
          const setError = () => ctx.addIssue({
            code: ZodIssueCode.custom,
            ...getIssueProperties(val)
          });
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      optional() {
        return ZodOptional.create(this);
      }
      nullable() {
        return ZodNullable.create(this);
      }
      nullish() {
        return this.optional().nullable();
      }
      array() {
        return ZodArray.create(this);
      }
      promise() {
        return ZodPromise.create(this);
      }
      or(option) {
        return ZodUnion.create([this, option]);
      }
      and(incoming) {
        return ZodIntersection.create(this, incoming);
      }
      transform(transform) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(void 0)
        });
      }
      catch(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline.create(this, target);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    cuidRegex = /^c[^\s-]{8,}$/i;
    uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
    emailRegex = /^(([^<>()[\]\.,;:\s@\"]+(\.[^<>()[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
    datetimeRegex = (args) => {
      if (args.precision) {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}:\\d{2})|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
        }
      } else if (args.precision === 0) {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}:\\d{2})|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
        }
      } else {
        if (args.offset) {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}:\\d{2})|Z)$`);
        } else {
          return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
        }
      }
    };
    ZodString = class _ZodString extends ZodType {
      constructor() {
        super(...arguments);
        this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
          validation,
          code: ZodIssueCode.invalid_string,
          ...errorUtil.errToObj(message)
        });
        this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
        this.trim = () => new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(
            ctx2,
            {
              code: ZodIssueCode.invalid_type,
              expected: ZodParsedType.string,
              received: ctx2.parsedType
            }
            //
          );
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.length < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.length > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "length") {
            const tooBig = input.data.length > check.value;
            const tooSmall = input.data.length < check.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              } else if (tooSmall) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              }
              status.dirty();
            }
          } else if (check.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "email",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "uuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "url") {
            try {
              new URL(input.data);
            } catch (_a) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "url",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "regex") {
            check.regex.lastIndex = 0;
            const testResult = check.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "regex",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "trim") {
            input.data = input.data.trim();
          } else if (check.kind === "startsWith") {
            if (!input.data.startsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { startsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "endsWith") {
            if (!input.data.endsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { endsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "datetime") {
            const regex = datetimeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _addCheck(check) {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
      }
      url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
      }
      uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
      }
      cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
      }
      datetime(options) {
        var _a;
        if (typeof options === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            message: options
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
          offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
          ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      regex(regex, message) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil.errToObj(message)
        });
      }
      startsWith(value, message) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      endsWith(value, message) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      min(minLength, message) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil.errToObj(message)
        });
      }
      max(maxLength, message) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil.errToObj(message)
        });
      }
      length(len, message) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil.errToObj(message)
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodString.create = (params) => {
      var _a;
      return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params)
      });
    };
    ZodNumber = class _ZodNumber extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.number,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "int") {
            if (!util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (floatSafeRemainder(input.data, check.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_finite,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      int(message) {
        return this._addCheck({
          kind: "int",
          message: errorUtil.toString(message)
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      finite(message) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int");
      }
    };
    ZodNumber.create = (params) => {
      return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    ZodBigInt = class extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = BigInt(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.bigint,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodBigInt.create = (params) => {
      var _a;
      return new ZodBigInt({
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
        ...processCreateParams(params)
      });
    };
    ZodBoolean = class extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodBoolean.create = (params) => {
      return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        ...processCreateParams(params)
      });
    };
    ZodDate = class _ZodDate extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.date,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        if (isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_date
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.getTime() < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                message: check.message,
                inclusive: true,
                exact: false,
                minimum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.getTime() > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                message: check.message,
                inclusive: true,
                exact: false,
                maximum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check) {
        return new _ZodDate({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      min(minDate, message) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      max(maxDate, message) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min != null ? new Date(min) : null;
      }
      get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max != null ? new Date(max) : null;
      }
    };
    ZodDate.create = (params) => {
      return new ZodDate({
        checks: [],
        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params)
      });
    };
    ZodSymbol = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodSymbol.create = (params) => {
      return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params)
      });
    };
    ZodUndefined = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodUndefined.create = (params) => {
      return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params)
      });
    };
    ZodNull = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.null,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodNull.create = (params) => {
      return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params)
      });
    };
    ZodAny = class extends ZodType {
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodAny.create = (params) => {
      return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params)
      });
    };
    ZodUnknown = class extends ZodType {
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodUnknown.create = (params) => {
      return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params)
      });
    };
    ZodNever = class extends ZodType {
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.never,
          received: ctx.parsedType
        });
        return INVALID;
      }
    };
    ZodNever.create = (params) => {
      return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params)
      });
    };
    ZodVoid = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.void,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodVoid.create = (params) => {
      return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params)
      });
    };
    ZodArray = class _ZodArray extends ZodType {
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            addIssueToContext(ctx, {
              code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all(ctx.data.map((item, i) => {
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
          })).then((result2) => {
            return ParseStatus.mergeArray(status, result2);
          });
        }
        const result = ctx.data.map((item, i) => {
          return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message) {
        return new _ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil.toString(message) }
        });
      }
      max(maxLength, message) {
        return new _ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil.toString(message) }
        });
      }
      length(len, message) {
        return new _ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil.toString(message) }
        });
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodArray.create = (schema4, params) => {
      return new ZodArray({
        type: schema4,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params)
      });
    };
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil || (objectUtil = {}));
    AugmentFactory = (def) => (augmentation) => {
      return new ZodObject({
        ...def,
        shape: () => ({
          ...def.shape(),
          ...augmentation
        })
      });
    };
    ZodObject = class _ZodObject extends ZodType {
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = AugmentFactory(this._def);
        this.extend = AugmentFactory(this._def);
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        return this._cached = { shape, keys };
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
          for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
              extraKeys.push(key);
            }
          }
        }
        const pairs = [];
        for (const key of shapeKeys) {
          const keyValidator = shape[key];
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key },
                value: { status: "valid", value: ctx.data[key] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip")
            ;
          else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key of extraKeys) {
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: catchall._parse(
                new ParseInputLazyPath(ctx, value, ctx.path, key)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key = await pair.key;
              syncPairs.push({
                key,
                value: await pair.value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message) {
        errorUtil.errToObj;
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message !== void 0 ? {
            errorMap: (issue, ctx) => {
              var _a, _b, _c, _d;
              const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}
        });
      }
      strip() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      setKey(key, schema4) {
        return this.augment({ [key]: schema4 });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new _ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: () => objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
      }
      catchall(index4) {
        return new _ZodObject({
          ...this._def,
          catchall: index4
        });
      }
      pick(mask) {
        const shape = {};
        util.objectKeys(mask).map((key) => {
          if (this.shape[key])
            shape[key] = this.shape[key];
        });
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      omit(mask) {
        const shape = {};
        util.objectKeys(this.shape).map((key) => {
          if (util.objectKeys(mask).indexOf(key) === -1) {
            shape[key] = this.shape[key];
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        if (mask) {
          util.objectKeys(this.shape).map((key) => {
            if (util.objectKeys(mask).indexOf(key) === -1) {
              newShape[key] = this.shape[key];
            } else {
              newShape[key] = this.shape[key].optional();
            }
          });
          return new _ZodObject({
            ...this._def,
            shape: () => newShape
          });
        } else {
          for (const key in this.shape) {
            const fieldSchema = this.shape[key];
            newShape[key] = fieldSchema.optional();
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      required(mask) {
        const newShape = {};
        if (mask) {
          util.objectKeys(this.shape).map((key) => {
            if (util.objectKeys(mask).indexOf(key) === -1) {
              newShape[key] = this.shape[key];
            } else {
              const fieldSchema = this.shape[key];
              let newField = fieldSchema;
              while (newField instanceof ZodOptional) {
                newField = newField._def.innerType;
              }
              newShape[key] = newField;
            }
          });
        } else {
          for (const key in this.shape) {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
              newField = newField._def.innerType;
            }
            newShape[key] = newField;
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      keyof() {
        return createZodEnum(util.objectKeys(this.shape));
      }
    };
    ZodObject.create = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.strictCreate = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.lazycreate = (shape, params) => {
      return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodUnion = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return Promise.all(options.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError(issues2));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    ZodUnion.create = (types, params) => {
      return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params)
      });
    };
    getDiscriminator = (type) => {
      if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
      } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
      } else if (type instanceof ZodLiteral) {
        return [type.value];
      } else if (type instanceof ZodEnum) {
        return type.options;
      } else if (type instanceof ZodNativeEnum) {
        return Object.keys(type.enum);
      } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
      } else if (type instanceof ZodUndefined) {
        return [void 0];
      } else if (type instanceof ZodNull) {
        return [null];
      } else {
        return null;
      }
    };
    ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      /**
       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
       * have a different value for each object in the union.
       * @param discriminator the name of the discriminator property
       * @param types an array of object schemas
       * @param params
       */
      static create(discriminator, options, params) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options) {
          const discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new _ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
          discriminator,
          options,
          optionsMap,
          ...processCreateParams(params)
        });
      }
    };
    ZodIntersection = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
          if (isAborted(parsedLeft) || isAborted(parsedRight)) {
            return INVALID;
          }
          const merged = mergeValues(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_intersection_types
            });
            return INVALID;
          }
          if (isDirty(parsedLeft) || isDirty(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    };
    ZodIntersection.create = (left, right, params) => {
      return new ZodIntersection({
        left,
        right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params)
      });
    };
    ZodTuple = class _ZodTuple extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = ctx.data.map((item, itemIndex) => {
          const schema4 = this._def.items[itemIndex] || this._def.rest;
          if (!schema4)
            return null;
          return schema4._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x) => !!x);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return ParseStatus.mergeArray(status, results);
          });
        } else {
          return ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new _ZodTuple({
          ...this._def,
          rest
        });
      }
    };
    ZodTuple.create = (schemas, params) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
      });
    };
    ZodRecord = class _ZodRecord extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
          });
        }
        if (ctx.common.async) {
          return ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType) {
          return new _ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
          });
        }
        return new _ZodRecord({
          keyType: ZodString.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(second)
        });
      }
    };
    ZodMap = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.map,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index4) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index4, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index4, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key = pair.key;
            const value = pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    ZodMap.create = (keyType, valueType, params) => {
      return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params)
      });
    };
    ZodSet = class _ZodSet extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.set,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return INVALID;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message) {
        return new _ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil.toString(message) }
        });
      }
      max(maxSize, message) {
        return new _ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil.toString(message) }
        });
      }
      size(size, message) {
        return this.min(size, message).max(size, message);
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodSet.create = (valueType, params) => {
      return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params)
      });
    };
    ZodFunction = class _ZodFunction extends ZodType {
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.function,
            received: ctx.parsedType
          });
          return INVALID;
        }
        function makeArgsIssue(args, error) {
          return makeIssue({
            data: args,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              getErrorMap(),
              errorMap
            ].filter((x) => !!x),
            issueData: {
              code: ZodIssueCode.invalid_arguments,
              argumentsError: error
            }
          });
        }
        function makeReturnsIssue(returns, error) {
          return makeIssue({
            data: returns,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              getErrorMap(),
              errorMap
            ].filter((x) => !!x),
            issueData: {
              code: ZodIssueCode.invalid_return_type,
              returnTypeError: error
            }
          });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
          return OK(async (...args) => {
            const error = new ZodError([]);
            const parsedArgs = await this._def.args.parseAsync(args, params).catch((e) => {
              error.addIssue(makeArgsIssue(args, e));
              throw error;
            });
            const result = await fn(...parsedArgs);
            const parsedReturns = await this._def.returns._def.type.parseAsync(result, params).catch((e) => {
              error.addIssue(makeReturnsIssue(result, e));
              throw error;
            });
            return parsedReturns;
          });
        } else {
          return OK((...args) => {
            const parsedArgs = this._def.args.safeParse(args, params);
            if (!parsedArgs.success) {
              throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = fn(...parsedArgs.data);
            const parsedReturns = this._def.returns.safeParse(result, params);
            if (!parsedReturns.success) {
              throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new _ZodFunction({
          ...this._def,
          args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
      }
      returns(returnType) {
        return new _ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params) {
        return new _ZodFunction({
          args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
          returns: returns || ZodUnknown.create(),
          typeName: ZodFirstPartyTypeKind.ZodFunction,
          ...processCreateParams(params)
        });
      }
    };
    ZodLazy = class extends ZodType {
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    };
    ZodLazy.create = (getter, params) => {
      return new ZodLazy({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params)
      });
    };
    ZodLiteral = class extends ZodType {
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    ZodLiteral.create = (value, params) => {
      return new ZodLiteral({
        value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params)
      });
    };
    ZodEnum = class extends ZodType {
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (this._def.values.indexOf(input.data) === -1) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
    };
    ZodEnum.create = createZodEnum;
    ZodNativeEnum = class extends ZodType {
      _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (nativeEnumValues.indexOf(input.data) === -1) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    ZodNativeEnum.create = (values, params) => {
      return new ZodNativeEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params)
      });
    };
    ZodPromise = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.promise,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    };
    ZodPromise.create = (schema4, params) => {
      return new ZodPromise({
        type: schema4,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params)
      });
    };
    ZodEffects = class extends ZodType {
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        if (effect.type === "preprocess") {
          const processed = effect.transform(ctx.data);
          if (ctx.common.async) {
            return Promise.resolve(processed).then((processed2) => {
              return this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
            });
          } else {
            return this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
          }
        }
        const checkCtx = {
          addIssue: (arg) => {
            addIssueToContext(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          },
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "refinement") {
          const executeRefinement = (acc) => {
            const result = effect.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          };
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect.type === "transform") {
          if (ctx.common.async === false) {
            const base = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!isValid(base))
              return base;
            const result = effect.transform(base.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
              if (!isValid(base))
                return base;
              return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
            });
          }
        }
        util.assertNever(effect);
      }
    };
    ZodEffects.create = (schema4, effect, params) => {
      return new ZodEffects({
        schema: schema4,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess, schema4, params) => {
      return new ZodEffects({
        schema: schema4,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params)
      });
    };
    ZodOptional = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
          return OK(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodOptional.create = (type, params) => {
      return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params)
      });
    };
    ZodNullable = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
          return OK(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodNullable.create = (type, params) => {
      return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params)
      });
    };
    ZodDefault = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    ZodDefault.create = (type, params) => {
      return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params)
      });
    };
    ZodCatch = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const result = this._def.innerType._parse({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (isAsync(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.defaultValue()
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.defaultValue()
          };
        }
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    ZodCatch.create = (type, params) => {
      return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params)
      });
    };
    ZodNaN = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.nan,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
    };
    ZodNaN.create = (params) => {
      return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params)
      });
    };
    BRAND = Symbol("zod_brand");
    ZodBranded = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    ZodPipeline = class _ZodPipeline extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return DIRTY(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          };
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a, b) {
        return new _ZodPipeline({
          in: a,
          out: b,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    };
    late = {
      object: ZodObject.lazycreate
    };
    (function(ZodFirstPartyTypeKind2) {
      ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
    stringType = ZodString.create;
    numberType = ZodNumber.create;
    nanType = ZodNaN.create;
    bigIntType = ZodBigInt.create;
    booleanType = ZodBoolean.create;
    dateType = ZodDate.create;
    symbolType = ZodSymbol.create;
    undefinedType = ZodUndefined.create;
    nullType = ZodNull.create;
    anyType = ZodAny.create;
    unknownType = ZodUnknown.create;
    neverType = ZodNever.create;
    voidType = ZodVoid.create;
    arrayType = ZodArray.create;
    objectType = ZodObject.create;
    strictObjectType = ZodObject.strictCreate;
    unionType = ZodUnion.create;
    discriminatedUnionType = ZodDiscriminatedUnion.create;
    intersectionType = ZodIntersection.create;
    tupleType = ZodTuple.create;
    recordType = ZodRecord.create;
    mapType = ZodMap.create;
    setType = ZodSet.create;
    functionType = ZodFunction.create;
    lazyType = ZodLazy.create;
    literalType = ZodLiteral.create;
    enumType = ZodEnum.create;
    nativeEnumType = ZodNativeEnum.create;
    promiseType = ZodPromise.create;
    effectsType = ZodEffects.create;
    optionalType = ZodOptional.create;
    nullableType = ZodNullable.create;
    preprocessType = ZodEffects.createWithPreprocess;
    pipelineType = ZodPipeline.create;
  }
});

// node_modules/.pnpm/heap@0.2.7/node_modules/heap/lib/heap.js
var require_heap = __commonJS({
  "node_modules/.pnpm/heap@0.2.7/node_modules/heap/lib/heap.js"(exports, module2) {
    (function() {
      var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;
      floor = Math.floor, min = Math.min;
      defaultCmp = function(x, y) {
        if (x < y) {
          return -1;
        }
        if (x > y) {
          return 1;
        }
        return 0;
      };
      insort = function(a, x, lo, hi, cmp) {
        var mid;
        if (lo == null) {
          lo = 0;
        }
        if (cmp == null) {
          cmp = defaultCmp;
        }
        if (lo < 0) {
          throw new Error("lo must be non-negative");
        }
        if (hi == null) {
          hi = a.length;
        }
        while (lo < hi) {
          mid = floor((lo + hi) / 2);
          if (cmp(x, a[mid]) < 0) {
            hi = mid;
          } else {
            lo = mid + 1;
          }
        }
        return [].splice.apply(a, [lo, lo - lo].concat(x)), x;
      };
      heappush = function(array, item, cmp) {
        if (cmp == null) {
          cmp = defaultCmp;
        }
        array.push(item);
        return _siftdown(array, 0, array.length - 1, cmp);
      };
      heappop = function(array, cmp) {
        var lastelt, returnitem;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        lastelt = array.pop();
        if (array.length) {
          returnitem = array[0];
          array[0] = lastelt;
          _siftup(array, 0, cmp);
        } else {
          returnitem = lastelt;
        }
        return returnitem;
      };
      heapreplace = function(array, item, cmp) {
        var returnitem;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        returnitem = array[0];
        array[0] = item;
        _siftup(array, 0, cmp);
        return returnitem;
      };
      heappushpop = function(array, item, cmp) {
        var _ref;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        if (array.length && cmp(array[0], item) < 0) {
          _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
          _siftup(array, 0, cmp);
        }
        return item;
      };
      heapify = function(array, cmp) {
        var i, _i, _j, _len, _ref, _ref1, _results, _results1;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        _ref1 = function() {
          _results1 = [];
          for (var _j2 = 0, _ref2 = floor(array.length / 2); 0 <= _ref2 ? _j2 < _ref2 : _j2 > _ref2; 0 <= _ref2 ? _j2++ : _j2--) {
            _results1.push(_j2);
          }
          return _results1;
        }.apply(this).reverse();
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          i = _ref1[_i];
          _results.push(_siftup(array, i, cmp));
        }
        return _results;
      };
      updateItem = function(array, item, cmp) {
        var pos;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        pos = array.indexOf(item);
        if (pos === -1) {
          return;
        }
        _siftdown(array, 0, pos, cmp);
        return _siftup(array, pos, cmp);
      };
      nlargest = function(array, n, cmp) {
        var elem, result, _i, _len, _ref;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        result = array.slice(0, n);
        if (!result.length) {
          return result;
        }
        heapify(result, cmp);
        _ref = array.slice(n);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          elem = _ref[_i];
          heappushpop(result, elem, cmp);
        }
        return result.sort(cmp).reverse();
      };
      nsmallest = function(array, n, cmp) {
        var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        if (n * 10 <= array.length) {
          result = array.slice(0, n).sort(cmp);
          if (!result.length) {
            return result;
          }
          los = result[result.length - 1];
          _ref = array.slice(n);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            elem = _ref[_i];
            if (cmp(elem, los) < 0) {
              insort(result, elem, 0, null, cmp);
              result.pop();
              los = result[result.length - 1];
            }
          }
          return result;
        }
        heapify(array, cmp);
        _results = [];
        for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          _results.push(heappop(array, cmp));
        }
        return _results;
      };
      _siftdown = function(array, startpos, pos, cmp) {
        var newitem, parent, parentpos;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        newitem = array[pos];
        while (pos > startpos) {
          parentpos = pos - 1 >> 1;
          parent = array[parentpos];
          if (cmp(newitem, parent) < 0) {
            array[pos] = parent;
            pos = parentpos;
            continue;
          }
          break;
        }
        return array[pos] = newitem;
      };
      _siftup = function(array, pos, cmp) {
        var childpos, endpos, newitem, rightpos, startpos;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        endpos = array.length;
        startpos = pos;
        newitem = array[pos];
        childpos = 2 * pos + 1;
        while (childpos < endpos) {
          rightpos = childpos + 1;
          if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
            childpos = rightpos;
          }
          array[pos] = array[childpos];
          pos = childpos;
          childpos = 2 * pos + 1;
        }
        array[pos] = newitem;
        return _siftdown(array, startpos, pos, cmp);
      };
      Heap = function() {
        Heap2.push = heappush;
        Heap2.pop = heappop;
        Heap2.replace = heapreplace;
        Heap2.pushpop = heappushpop;
        Heap2.heapify = heapify;
        Heap2.updateItem = updateItem;
        Heap2.nlargest = nlargest;
        Heap2.nsmallest = nsmallest;
        function Heap2(cmp) {
          this.cmp = cmp != null ? cmp : defaultCmp;
          this.nodes = [];
        }
        Heap2.prototype.push = function(x) {
          return heappush(this.nodes, x, this.cmp);
        };
        Heap2.prototype.pop = function() {
          return heappop(this.nodes, this.cmp);
        };
        Heap2.prototype.peek = function() {
          return this.nodes[0];
        };
        Heap2.prototype.contains = function(x) {
          return this.nodes.indexOf(x) !== -1;
        };
        Heap2.prototype.replace = function(x) {
          return heapreplace(this.nodes, x, this.cmp);
        };
        Heap2.prototype.pushpop = function(x) {
          return heappushpop(this.nodes, x, this.cmp);
        };
        Heap2.prototype.heapify = function() {
          return heapify(this.nodes, this.cmp);
        };
        Heap2.prototype.updateItem = function(x) {
          return updateItem(this.nodes, x, this.cmp);
        };
        Heap2.prototype.clear = function() {
          return this.nodes = [];
        };
        Heap2.prototype.empty = function() {
          return this.nodes.length === 0;
        };
        Heap2.prototype.size = function() {
          return this.nodes.length;
        };
        Heap2.prototype.clone = function() {
          var heap;
          heap = new Heap2();
          heap.nodes = this.nodes.slice(0);
          return heap;
        };
        Heap2.prototype.toArray = function() {
          return this.nodes.slice(0);
        };
        Heap2.prototype.insert = Heap2.prototype.push;
        Heap2.prototype.top = Heap2.prototype.peek;
        Heap2.prototype.front = Heap2.prototype.peek;
        Heap2.prototype.has = Heap2.prototype.contains;
        Heap2.prototype.copy = Heap2.prototype.clone;
        return Heap2;
      }();
      (function(root, factory) {
        if (typeof define === "function" && define.amd) {
          return define([], factory);
        } else if (typeof exports === "object") {
          return module2.exports = factory();
        } else {
          return root.Heap = factory();
        }
      })(this, function() {
        return Heap;
      });
    }).call(exports);
  }
});

// node_modules/.pnpm/heap@0.2.7/node_modules/heap/index.js
var require_heap2 = __commonJS({
  "node_modules/.pnpm/heap@0.2.7/node_modules/heap/index.js"(exports, module2) {
    module2.exports = require_heap();
  }
});

// node_modules/.pnpm/difflib@0.2.4/node_modules/difflib/lib/difflib.js
var require_difflib = __commonJS({
  "node_modules/.pnpm/difflib@0.2.4/node_modules/difflib/lib/difflib.js"(exports) {
    (function() {
      var Differ, Heap, IS_CHARACTER_JUNK, IS_LINE_JUNK, SequenceMatcher, assert, contextDiff, floor, getCloseMatches, max, min, ndiff, restore, unifiedDiff, _any, _arrayCmp, _calculateRatio, _countLeading, _formatRangeContext, _formatRangeUnified, _has, __indexOf = [].indexOf || function(item) {
        for (var i = 0, l = this.length; i < l; i++) {
          if (i in this && this[i] === item)
            return i;
        }
        return -1;
      };
      floor = Math.floor, max = Math.max, min = Math.min;
      Heap = require_heap2();
      assert = require("assert");
      _calculateRatio = function(matches, length) {
        if (length) {
          return 2 * matches / length;
        } else {
          return 1;
        }
      };
      _arrayCmp = function(a, b) {
        var i, la, lb, _i, _ref, _ref1;
        _ref = [a.length, b.length], la = _ref[0], lb = _ref[1];
        for (i = _i = 0, _ref1 = min(la, lb); 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
          if (a[i] < b[i]) {
            return -1;
          }
          if (a[i] > b[i]) {
            return 1;
          }
        }
        return la - lb;
      };
      _has = function(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key);
      };
      _any = function(items) {
        var item, _i, _len;
        for (_i = 0, _len = items.length; _i < _len; _i++) {
          item = items[_i];
          if (item) {
            return true;
          }
        }
        return false;
      };
      SequenceMatcher = function() {
        SequenceMatcher2.name = "SequenceMatcher";
        function SequenceMatcher2(isjunk, a, b, autojunk) {
          this.isjunk = isjunk;
          if (a == null) {
            a = "";
          }
          if (b == null) {
            b = "";
          }
          this.autojunk = autojunk != null ? autojunk : true;
          this.a = this.b = null;
          this.setSeqs(a, b);
        }
        SequenceMatcher2.prototype.setSeqs = function(a, b) {
          this.setSeq1(a);
          return this.setSeq2(b);
        };
        SequenceMatcher2.prototype.setSeq1 = function(a) {
          if (a === this.a) {
            return;
          }
          this.a = a;
          return this.matchingBlocks = this.opcodes = null;
        };
        SequenceMatcher2.prototype.setSeq2 = function(b) {
          if (b === this.b) {
            return;
          }
          this.b = b;
          this.matchingBlocks = this.opcodes = null;
          this.fullbcount = null;
          return this._chainB();
        };
        SequenceMatcher2.prototype._chainB = function() {
          var b, b2j, elt, i, idxs, indices, isjunk, junk, n, ntest, popular, _i, _j, _len, _len1, _ref;
          b = this.b;
          this.b2j = b2j = {};
          for (i = _i = 0, _len = b.length; _i < _len; i = ++_i) {
            elt = b[i];
            indices = _has(b2j, elt) ? b2j[elt] : b2j[elt] = [];
            indices.push(i);
          }
          junk = {};
          isjunk = this.isjunk;
          if (isjunk) {
            _ref = Object.keys(b2j);
            for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
              elt = _ref[_j];
              if (isjunk(elt)) {
                junk[elt] = true;
                delete b2j[elt];
              }
            }
          }
          popular = {};
          n = b.length;
          if (this.autojunk && n >= 200) {
            ntest = floor(n / 100) + 1;
            for (elt in b2j) {
              idxs = b2j[elt];
              if (idxs.length > ntest) {
                popular[elt] = true;
                delete b2j[elt];
              }
            }
          }
          this.isbjunk = function(b2) {
            return _has(junk, b2);
          };
          return this.isbpopular = function(b2) {
            return _has(popular, b2);
          };
        };
        SequenceMatcher2.prototype.findLongestMatch = function(alo, ahi, blo, bhi) {
          var a, b, b2j, besti, bestj, bestsize, i, isbjunk, j, j2len, k, newj2len, _i, _j, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
          _ref = [this.a, this.b, this.b2j, this.isbjunk], a = _ref[0], b = _ref[1], b2j = _ref[2], isbjunk = _ref[3];
          _ref1 = [alo, blo, 0], besti = _ref1[0], bestj = _ref1[1], bestsize = _ref1[2];
          j2len = {};
          for (i = _i = alo; alo <= ahi ? _i < ahi : _i > ahi; i = alo <= ahi ? ++_i : --_i) {
            newj2len = {};
            _ref2 = _has(b2j, a[i]) ? b2j[a[i]] : [];
            for (_j = 0, _len = _ref2.length; _j < _len; _j++) {
              j = _ref2[_j];
              if (j < blo) {
                continue;
              }
              if (j >= bhi) {
                break;
              }
              k = newj2len[j] = (j2len[j - 1] || 0) + 1;
              if (k > bestsize) {
                _ref3 = [i - k + 1, j - k + 1, k], besti = _ref3[0], bestj = _ref3[1], bestsize = _ref3[2];
              }
            }
            j2len = newj2len;
          }
          while (besti > alo && bestj > blo && !isbjunk(b[bestj - 1]) && a[besti - 1] === b[bestj - 1]) {
            _ref4 = [besti - 1, bestj - 1, bestsize + 1], besti = _ref4[0], bestj = _ref4[1], bestsize = _ref4[2];
          }
          while (besti + bestsize < ahi && bestj + bestsize < bhi && !isbjunk(b[bestj + bestsize]) && a[besti + bestsize] === b[bestj + bestsize]) {
            bestsize++;
          }
          while (besti > alo && bestj > blo && isbjunk(b[bestj - 1]) && a[besti - 1] === b[bestj - 1]) {
            _ref5 = [besti - 1, bestj - 1, bestsize + 1], besti = _ref5[0], bestj = _ref5[1], bestsize = _ref5[2];
          }
          while (besti + bestsize < ahi && bestj + bestsize < bhi && isbjunk(b[bestj + bestsize]) && a[besti + bestsize] === b[bestj + bestsize]) {
            bestsize++;
          }
          return [besti, bestj, bestsize];
        };
        SequenceMatcher2.prototype.getMatchingBlocks = function() {
          var ahi, alo, bhi, blo, i, i1, i2, j, j1, j2, k, k1, k2, la, lb, matchingBlocks, nonAdjacent, queue, x, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4;
          if (this.matchingBlocks) {
            return this.matchingBlocks;
          }
          _ref = [this.a.length, this.b.length], la = _ref[0], lb = _ref[1];
          queue = [[0, la, 0, lb]];
          matchingBlocks = [];
          while (queue.length) {
            _ref1 = queue.pop(), alo = _ref1[0], ahi = _ref1[1], blo = _ref1[2], bhi = _ref1[3];
            _ref2 = x = this.findLongestMatch(alo, ahi, blo, bhi), i = _ref2[0], j = _ref2[1], k = _ref2[2];
            if (k) {
              matchingBlocks.push(x);
              if (alo < i && blo < j) {
                queue.push([alo, i, blo, j]);
              }
              if (i + k < ahi && j + k < bhi) {
                queue.push([i + k, ahi, j + k, bhi]);
              }
            }
          }
          matchingBlocks.sort(_arrayCmp);
          i1 = j1 = k1 = 0;
          nonAdjacent = [];
          for (_i = 0, _len = matchingBlocks.length; _i < _len; _i++) {
            _ref3 = matchingBlocks[_i], i2 = _ref3[0], j2 = _ref3[1], k2 = _ref3[2];
            if (i1 + k1 === i2 && j1 + k1 === j2) {
              k1 += k2;
            } else {
              if (k1) {
                nonAdjacent.push([i1, j1, k1]);
              }
              _ref4 = [i2, j2, k2], i1 = _ref4[0], j1 = _ref4[1], k1 = _ref4[2];
            }
          }
          if (k1) {
            nonAdjacent.push([i1, j1, k1]);
          }
          nonAdjacent.push([la, lb, 0]);
          return this.matchingBlocks = nonAdjacent;
        };
        SequenceMatcher2.prototype.getOpcodes = function() {
          var ai, answer, bj, i, j, size, tag, _i, _len, _ref, _ref1, _ref2;
          if (this.opcodes) {
            return this.opcodes;
          }
          i = j = 0;
          this.opcodes = answer = [];
          _ref = this.getMatchingBlocks();
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            _ref1 = _ref[_i], ai = _ref1[0], bj = _ref1[1], size = _ref1[2];
            tag = "";
            if (i < ai && j < bj) {
              tag = "replace";
            } else if (i < ai) {
              tag = "delete";
            } else if (j < bj) {
              tag = "insert";
            }
            if (tag) {
              answer.push([tag, i, ai, j, bj]);
            }
            _ref2 = [ai + size, bj + size], i = _ref2[0], j = _ref2[1];
            if (size) {
              answer.push(["equal", ai, i, bj, j]);
            }
          }
          return answer;
        };
        SequenceMatcher2.prototype.getGroupedOpcodes = function(n) {
          var codes, group, groups, i1, i2, j1, j2, nn, tag, _i, _len, _ref, _ref1, _ref2, _ref3;
          if (n == null) {
            n = 3;
          }
          codes = this.getOpcodes();
          if (!codes.length) {
            codes = [["equal", 0, 1, 0, 1]];
          }
          if (codes[0][0] === "equal") {
            _ref = codes[0], tag = _ref[0], i1 = _ref[1], i2 = _ref[2], j1 = _ref[3], j2 = _ref[4];
            codes[0] = [tag, max(i1, i2 - n), i2, max(j1, j2 - n), j2];
          }
          if (codes[codes.length - 1][0] === "equal") {
            _ref1 = codes[codes.length - 1], tag = _ref1[0], i1 = _ref1[1], i2 = _ref1[2], j1 = _ref1[3], j2 = _ref1[4];
            codes[codes.length - 1] = [tag, i1, min(i2, i1 + n), j1, min(j2, j1 + n)];
          }
          nn = n + n;
          groups = [];
          group = [];
          for (_i = 0, _len = codes.length; _i < _len; _i++) {
            _ref2 = codes[_i], tag = _ref2[0], i1 = _ref2[1], i2 = _ref2[2], j1 = _ref2[3], j2 = _ref2[4];
            if (tag === "equal" && i2 - i1 > nn) {
              group.push([tag, i1, min(i2, i1 + n), j1, min(j2, j1 + n)]);
              groups.push(group);
              group = [];
              _ref3 = [max(i1, i2 - n), max(j1, j2 - n)], i1 = _ref3[0], j1 = _ref3[1];
            }
            group.push([tag, i1, i2, j1, j2]);
          }
          if (group.length && !(group.length === 1 && group[0][0] === "equal")) {
            groups.push(group);
          }
          return groups;
        };
        SequenceMatcher2.prototype.ratio = function() {
          var match, matches, _i, _len, _ref;
          matches = 0;
          _ref = this.getMatchingBlocks();
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            match = _ref[_i];
            matches += match[2];
          }
          return _calculateRatio(matches, this.a.length + this.b.length);
        };
        SequenceMatcher2.prototype.quickRatio = function() {
          var avail, elt, fullbcount, matches, numb, _i, _j, _len, _len1, _ref, _ref1;
          if (!this.fullbcount) {
            this.fullbcount = fullbcount = {};
            _ref = this.b;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              elt = _ref[_i];
              fullbcount[elt] = (fullbcount[elt] || 0) + 1;
            }
          }
          fullbcount = this.fullbcount;
          avail = {};
          matches = 0;
          _ref1 = this.a;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            elt = _ref1[_j];
            if (_has(avail, elt)) {
              numb = avail[elt];
            } else {
              numb = fullbcount[elt] || 0;
            }
            avail[elt] = numb - 1;
            if (numb > 0) {
              matches++;
            }
          }
          return _calculateRatio(matches, this.a.length + this.b.length);
        };
        SequenceMatcher2.prototype.realQuickRatio = function() {
          var la, lb, _ref;
          _ref = [this.a.length, this.b.length], la = _ref[0], lb = _ref[1];
          return _calculateRatio(min(la, lb), la + lb);
        };
        return SequenceMatcher2;
      }();
      getCloseMatches = function(word, possibilities, n, cutoff) {
        var result, s, score, x, _i, _j, _len, _len1, _ref, _results;
        if (n == null) {
          n = 3;
        }
        if (cutoff == null) {
          cutoff = 0.6;
        }
        if (!(n > 0)) {
          throw new Error("n must be > 0: (" + n + ")");
        }
        if (!(0 <= cutoff && cutoff <= 1)) {
          throw new Error("cutoff must be in [0.0, 1.0]: (" + cutoff + ")");
        }
        result = [];
        s = new SequenceMatcher();
        s.setSeq2(word);
        for (_i = 0, _len = possibilities.length; _i < _len; _i++) {
          x = possibilities[_i];
          s.setSeq1(x);
          if (s.realQuickRatio() >= cutoff && s.quickRatio() >= cutoff && s.ratio() >= cutoff) {
            result.push([s.ratio(), x]);
          }
        }
        result = Heap.nlargest(result, n, _arrayCmp);
        _results = [];
        for (_j = 0, _len1 = result.length; _j < _len1; _j++) {
          _ref = result[_j], score = _ref[0], x = _ref[1];
          _results.push(x);
        }
        return _results;
      };
      _countLeading = function(line, ch) {
        var i, n, _ref;
        _ref = [0, line.length], i = _ref[0], n = _ref[1];
        while (i < n && line[i] === ch) {
          i++;
        }
        return i;
      };
      Differ = function() {
        Differ2.name = "Differ";
        function Differ2(linejunk, charjunk) {
          this.linejunk = linejunk;
          this.charjunk = charjunk;
        }
        Differ2.prototype.compare = function(a, b) {
          var ahi, alo, bhi, blo, cruncher, g, line, lines, tag, _i, _j, _len, _len1, _ref, _ref1;
          cruncher = new SequenceMatcher(this.linejunk, a, b);
          lines = [];
          _ref = cruncher.getOpcodes();
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            _ref1 = _ref[_i], tag = _ref1[0], alo = _ref1[1], ahi = _ref1[2], blo = _ref1[3], bhi = _ref1[4];
            switch (tag) {
              case "replace":
                g = this._fancyReplace(a, alo, ahi, b, blo, bhi);
                break;
              case "delete":
                g = this._dump("-", a, alo, ahi);
                break;
              case "insert":
                g = this._dump("+", b, blo, bhi);
                break;
              case "equal":
                g = this._dump(" ", a, alo, ahi);
                break;
              default:
                throw new Error("unknow tag (" + tag + ")");
            }
            for (_j = 0, _len1 = g.length; _j < _len1; _j++) {
              line = g[_j];
              lines.push(line);
            }
          }
          return lines;
        };
        Differ2.prototype._dump = function(tag, x, lo, hi) {
          var i, _i, _results;
          _results = [];
          for (i = _i = lo; lo <= hi ? _i < hi : _i > hi; i = lo <= hi ? ++_i : --_i) {
            _results.push("" + tag + " " + x[i]);
          }
          return _results;
        };
        Differ2.prototype._plainReplace = function(a, alo, ahi, b, blo, bhi) {
          var first, g, line, lines, second, _i, _j, _len, _len1, _ref;
          assert(alo < ahi && blo < bhi);
          if (bhi - blo < ahi - alo) {
            first = this._dump("+", b, blo, bhi);
            second = this._dump("-", a, alo, ahi);
          } else {
            first = this._dump("-", a, alo, ahi);
            second = this._dump("+", b, blo, bhi);
          }
          lines = [];
          _ref = [first, second];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            g = _ref[_i];
            for (_j = 0, _len1 = g.length; _j < _len1; _j++) {
              line = g[_j];
              lines.push(line);
            }
          }
          return lines;
        };
        Differ2.prototype._fancyReplace = function(a, alo, ahi, b, blo, bhi) {
          var aelt, ai, ai1, ai2, atags, belt, bestRatio, besti, bestj, bj, bj1, bj2, btags, cruncher, cutoff, eqi, eqj, i, j, la, lb, line, lines, tag, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _o, _ref, _ref1, _ref10, _ref11, _ref12, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9;
          _ref = [0.74, 0.75], bestRatio = _ref[0], cutoff = _ref[1];
          cruncher = new SequenceMatcher(this.charjunk);
          _ref1 = [null, null], eqi = _ref1[0], eqj = _ref1[1];
          lines = [];
          for (j = _i = blo; blo <= bhi ? _i < bhi : _i > bhi; j = blo <= bhi ? ++_i : --_i) {
            bj = b[j];
            cruncher.setSeq2(bj);
            for (i = _j = alo; alo <= ahi ? _j < ahi : _j > ahi; i = alo <= ahi ? ++_j : --_j) {
              ai = a[i];
              if (ai === bj) {
                if (eqi === null) {
                  _ref2 = [i, j], eqi = _ref2[0], eqj = _ref2[1];
                }
                continue;
              }
              cruncher.setSeq1(ai);
              if (cruncher.realQuickRatio() > bestRatio && cruncher.quickRatio() > bestRatio && cruncher.ratio() > bestRatio) {
                _ref3 = [cruncher.ratio(), i, j], bestRatio = _ref3[0], besti = _ref3[1], bestj = _ref3[2];
              }
            }
          }
          if (bestRatio < cutoff) {
            if (eqi === null) {
              _ref4 = this._plainReplace(a, alo, ahi, b, blo, bhi);
              for (_k = 0, _len = _ref4.length; _k < _len; _k++) {
                line = _ref4[_k];
                lines.push(line);
              }
              return lines;
            }
            _ref5 = [eqi, eqj, 1], besti = _ref5[0], bestj = _ref5[1], bestRatio = _ref5[2];
          } else {
            eqi = null;
          }
          _ref6 = this._fancyHelper(a, alo, besti, b, blo, bestj);
          for (_l = 0, _len1 = _ref6.length; _l < _len1; _l++) {
            line = _ref6[_l];
            lines.push(line);
          }
          _ref7 = [a[besti], b[bestj]], aelt = _ref7[0], belt = _ref7[1];
          if (eqi === null) {
            atags = btags = "";
            cruncher.setSeqs(aelt, belt);
            _ref8 = cruncher.getOpcodes();
            for (_m = 0, _len2 = _ref8.length; _m < _len2; _m++) {
              _ref9 = _ref8[_m], tag = _ref9[0], ai1 = _ref9[1], ai2 = _ref9[2], bj1 = _ref9[3], bj2 = _ref9[4];
              _ref10 = [ai2 - ai1, bj2 - bj1], la = _ref10[0], lb = _ref10[1];
              switch (tag) {
                case "replace":
                  atags += Array(la + 1).join("^");
                  btags += Array(lb + 1).join("^");
                  break;
                case "delete":
                  atags += Array(la + 1).join("-");
                  break;
                case "insert":
                  btags += Array(lb + 1).join("+");
                  break;
                case "equal":
                  atags += Array(la + 1).join(" ");
                  btags += Array(lb + 1).join(" ");
                  break;
                default:
                  throw new Error("unknow tag (" + tag + ")");
              }
            }
            _ref11 = this._qformat(aelt, belt, atags, btags);
            for (_n = 0, _len3 = _ref11.length; _n < _len3; _n++) {
              line = _ref11[_n];
              lines.push(line);
            }
          } else {
            lines.push("  " + aelt);
          }
          _ref12 = this._fancyHelper(a, besti + 1, ahi, b, bestj + 1, bhi);
          for (_o = 0, _len4 = _ref12.length; _o < _len4; _o++) {
            line = _ref12[_o];
            lines.push(line);
          }
          return lines;
        };
        Differ2.prototype._fancyHelper = function(a, alo, ahi, b, blo, bhi) {
          var g;
          g = [];
          if (alo < ahi) {
            if (blo < bhi) {
              g = this._fancyReplace(a, alo, ahi, b, blo, bhi);
            } else {
              g = this._dump("-", a, alo, ahi);
            }
          } else if (blo < bhi) {
            g = this._dump("+", b, blo, bhi);
          }
          return g;
        };
        Differ2.prototype._qformat = function(aline, bline, atags, btags) {
          var common, lines;
          lines = [];
          common = min(_countLeading(aline, "	"), _countLeading(bline, "	"));
          common = min(common, _countLeading(atags.slice(0, common), " "));
          common = min(common, _countLeading(btags.slice(0, common), " "));
          atags = atags.slice(common).replace(/\s+$/, "");
          btags = btags.slice(common).replace(/\s+$/, "");
          lines.push("- " + aline);
          if (atags.length) {
            lines.push("? " + Array(common + 1).join("	") + atags + "\n");
          }
          lines.push("+ " + bline);
          if (btags.length) {
            lines.push("? " + Array(common + 1).join("	") + btags + "\n");
          }
          return lines;
        };
        return Differ2;
      }();
      IS_LINE_JUNK = function(line, pat) {
        if (pat == null) {
          pat = /^\s*#?\s*$/;
        }
        return pat.test(line);
      };
      IS_CHARACTER_JUNK = function(ch, ws) {
        if (ws == null) {
          ws = " 	";
        }
        return __indexOf.call(ws, ch) >= 0;
      };
      _formatRangeUnified = function(start, stop) {
        var beginning, length;
        beginning = start + 1;
        length = stop - start;
        if (length === 1) {
          return "" + beginning;
        }
        if (!length) {
          beginning--;
        }
        return "" + beginning + "," + length;
      };
      unifiedDiff = function(a, b, _arg) {
        var file1Range, file2Range, first, fromdate, fromfile, fromfiledate, group, i1, i2, j1, j2, last, line, lines, lineterm, n, started, tag, todate, tofile, tofiledate, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
        _ref = _arg != null ? _arg : {}, fromfile = _ref.fromfile, tofile = _ref.tofile, fromfiledate = _ref.fromfiledate, tofiledate = _ref.tofiledate, n = _ref.n, lineterm = _ref.lineterm;
        if (fromfile == null) {
          fromfile = "";
        }
        if (tofile == null) {
          tofile = "";
        }
        if (fromfiledate == null) {
          fromfiledate = "";
        }
        if (tofiledate == null) {
          tofiledate = "";
        }
        if (n == null) {
          n = 3;
        }
        if (lineterm == null) {
          lineterm = "\n";
        }
        lines = [];
        started = false;
        _ref1 = new SequenceMatcher(null, a, b).getGroupedOpcodes();
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          group = _ref1[_i];
          if (!started) {
            started = true;
            fromdate = fromfiledate ? "	" + fromfiledate : "";
            todate = tofiledate ? "	" + tofiledate : "";
            lines.push("--- " + fromfile + fromdate + lineterm);
            lines.push("+++ " + tofile + todate + lineterm);
          }
          _ref2 = [group[0], group[group.length - 1]], first = _ref2[0], last = _ref2[1];
          file1Range = _formatRangeUnified(first[1], last[2]);
          file2Range = _formatRangeUnified(first[3], last[4]);
          lines.push("@@ -" + file1Range + " +" + file2Range + " @@" + lineterm);
          for (_j = 0, _len1 = group.length; _j < _len1; _j++) {
            _ref3 = group[_j], tag = _ref3[0], i1 = _ref3[1], i2 = _ref3[2], j1 = _ref3[3], j2 = _ref3[4];
            if (tag === "equal") {
              _ref4 = a.slice(i1, i2);
              for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
                line = _ref4[_k];
                lines.push(" " + line);
              }
              continue;
            }
            if (tag === "replace" || tag === "delete") {
              _ref5 = a.slice(i1, i2);
              for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {
                line = _ref5[_l];
                lines.push("-" + line);
              }
            }
            if (tag === "replace" || tag === "insert") {
              _ref6 = b.slice(j1, j2);
              for (_m = 0, _len4 = _ref6.length; _m < _len4; _m++) {
                line = _ref6[_m];
                lines.push("+" + line);
              }
            }
          }
        }
        return lines;
      };
      _formatRangeContext = function(start, stop) {
        var beginning, length;
        beginning = start + 1;
        length = stop - start;
        if (!length) {
          beginning--;
        }
        if (length <= 1) {
          return "" + beginning;
        }
        return "" + beginning + "," + (beginning + length - 1);
      };
      contextDiff = function(a, b, _arg) {
        var file1Range, file2Range, first, fromdate, fromfile, fromfiledate, group, i1, i2, j1, j2, last, line, lines, lineterm, n, prefix, started, tag, todate, tofile, tofiledate, _, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
        _ref = _arg != null ? _arg : {}, fromfile = _ref.fromfile, tofile = _ref.tofile, fromfiledate = _ref.fromfiledate, tofiledate = _ref.tofiledate, n = _ref.n, lineterm = _ref.lineterm;
        if (fromfile == null) {
          fromfile = "";
        }
        if (tofile == null) {
          tofile = "";
        }
        if (fromfiledate == null) {
          fromfiledate = "";
        }
        if (tofiledate == null) {
          tofiledate = "";
        }
        if (n == null) {
          n = 3;
        }
        if (lineterm == null) {
          lineterm = "\n";
        }
        prefix = {
          insert: "+ ",
          "delete": "- ",
          replace: "! ",
          equal: "  "
        };
        started = false;
        lines = [];
        _ref1 = new SequenceMatcher(null, a, b).getGroupedOpcodes();
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          group = _ref1[_i];
          if (!started) {
            started = true;
            fromdate = fromfiledate ? "	" + fromfiledate : "";
            todate = tofiledate ? "	" + tofiledate : "";
            lines.push("*** " + fromfile + fromdate + lineterm);
            lines.push("--- " + tofile + todate + lineterm);
            _ref2 = [group[0], group[group.length - 1]], first = _ref2[0], last = _ref2[1];
            lines.push("***************" + lineterm);
            file1Range = _formatRangeContext(first[1], last[2]);
            lines.push("*** " + file1Range + " ****" + lineterm);
            if (_any(function() {
              var _j2, _len12, _ref32, _results;
              _results = [];
              for (_j2 = 0, _len12 = group.length; _j2 < _len12; _j2++) {
                _ref32 = group[_j2], tag = _ref32[0], _ = _ref32[1], _ = _ref32[2], _ = _ref32[3], _ = _ref32[4];
                _results.push(tag === "replace" || tag === "delete");
              }
              return _results;
            }())) {
              for (_j = 0, _len1 = group.length; _j < _len1; _j++) {
                _ref3 = group[_j], tag = _ref3[0], i1 = _ref3[1], i2 = _ref3[2], _ = _ref3[3], _ = _ref3[4];
                if (tag !== "insert") {
                  _ref4 = a.slice(i1, i2);
                  for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
                    line = _ref4[_k];
                    lines.push(prefix[tag] + line);
                  }
                }
              }
            }
            file2Range = _formatRangeContext(first[3], last[4]);
            lines.push("--- " + file2Range + " ----" + lineterm);
            if (_any(function() {
              var _l2, _len32, _ref52, _results;
              _results = [];
              for (_l2 = 0, _len32 = group.length; _l2 < _len32; _l2++) {
                _ref52 = group[_l2], tag = _ref52[0], _ = _ref52[1], _ = _ref52[2], _ = _ref52[3], _ = _ref52[4];
                _results.push(tag === "replace" || tag === "insert");
              }
              return _results;
            }())) {
              for (_l = 0, _len3 = group.length; _l < _len3; _l++) {
                _ref5 = group[_l], tag = _ref5[0], _ = _ref5[1], _ = _ref5[2], j1 = _ref5[3], j2 = _ref5[4];
                if (tag !== "delete") {
                  _ref6 = b.slice(j1, j2);
                  for (_m = 0, _len4 = _ref6.length; _m < _len4; _m++) {
                    line = _ref6[_m];
                    lines.push(prefix[tag] + line);
                  }
                }
              }
            }
          }
        }
        return lines;
      };
      ndiff = function(a, b, linejunk, charjunk) {
        if (charjunk == null) {
          charjunk = IS_CHARACTER_JUNK;
        }
        return new Differ(linejunk, charjunk).compare(a, b);
      };
      restore = function(delta, which) {
        var line, lines, prefixes, tag, _i, _len, _ref;
        tag = {
          1: "- ",
          2: "+ "
        }[which];
        if (!tag) {
          throw new Error("unknow delta choice (must be 1 or 2): " + which);
        }
        prefixes = ["  ", tag];
        lines = [];
        for (_i = 0, _len = delta.length; _i < _len; _i++) {
          line = delta[_i];
          if (_ref = line.slice(0, 2), __indexOf.call(prefixes, _ref) >= 0) {
            lines.push(line.slice(2));
          }
        }
        return lines;
      };
      exports._arrayCmp = _arrayCmp;
      exports.SequenceMatcher = SequenceMatcher;
      exports.getCloseMatches = getCloseMatches;
      exports._countLeading = _countLeading;
      exports.Differ = Differ;
      exports.IS_LINE_JUNK = IS_LINE_JUNK;
      exports.IS_CHARACTER_JUNK = IS_CHARACTER_JUNK;
      exports._formatRangeUnified = _formatRangeUnified;
      exports.unifiedDiff = unifiedDiff;
      exports._formatRangeContext = _formatRangeContext;
      exports.contextDiff = contextDiff;
      exports.ndiff = ndiff;
      exports.restore = restore;
    }).call(exports);
  }
});

// node_modules/.pnpm/difflib@0.2.4/node_modules/difflib/index.js
var require_difflib2 = __commonJS({
  "node_modules/.pnpm/difflib@0.2.4/node_modules/difflib/index.js"(exports, module2) {
    module2.exports = require_difflib();
  }
});

// node_modules/.pnpm/json-diff@0.9.0/node_modules/json-diff/lib/util.js
var require_util = __commonJS({
  "node_modules/.pnpm/json-diff@0.9.0/node_modules/json-diff/lib/util.js"(exports, module2) {
    var extendedTypeOf = function(obj) {
      const result = typeof obj;
      if (obj == null) {
        return "null";
      } else if (result === "object" && obj.constructor === Array) {
        return "array";
      } else {
        return result;
      }
    };
    var roundObj = function(data, precision) {
      const type = typeof data;
      if (type === "array") {
        return data.map((x) => roundObj(x, precision));
      } else if (type === "object") {
        for (const key in data) {
          data[key] = roundObj(data[key], precision);
        }
        return data;
      } else if (type === "number" && Number.isFinite(data) && !Number.isInteger(data)) {
        return +data.toFixed(precision);
      } else {
        return data;
      }
    };
    module2.exports = { extendedTypeOf, roundObj };
  }
});

// node_modules/.pnpm/type@1.2.0/node_modules/type/value/is.js
var require_is = __commonJS({
  "node_modules/.pnpm/type@1.2.0/node_modules/type/value/is.js"(exports, module2) {
    "use strict";
    var _undefined = void 0;
    module2.exports = function(value) {
      return value !== _undefined && value !== null;
    };
  }
});

// node_modules/.pnpm/type@1.2.0/node_modules/type/object/is.js
var require_is2 = __commonJS({
  "node_modules/.pnpm/type@1.2.0/node_modules/type/object/is.js"(exports, module2) {
    "use strict";
    var isValue = require_is();
    var possibleTypes = {
      "object": true,
      "function": true,
      "undefined": true
      /* document.all */
    };
    module2.exports = function(value) {
      if (!isValue(value))
        return false;
      return hasOwnProperty.call(possibleTypes, typeof value);
    };
  }
});

// node_modules/.pnpm/type@1.2.0/node_modules/type/prototype/is.js
var require_is3 = __commonJS({
  "node_modules/.pnpm/type@1.2.0/node_modules/type/prototype/is.js"(exports, module2) {
    "use strict";
    var isObject = require_is2();
    module2.exports = function(value) {
      if (!isObject(value))
        return false;
      try {
        if (!value.constructor)
          return false;
        return value.constructor.prototype === value;
      } catch (error) {
        return false;
      }
    };
  }
});

// node_modules/.pnpm/type@1.2.0/node_modules/type/function/is.js
var require_is4 = __commonJS({
  "node_modules/.pnpm/type@1.2.0/node_modules/type/function/is.js"(exports, module2) {
    "use strict";
    var isPrototype = require_is3();
    module2.exports = function(value) {
      if (typeof value !== "function")
        return false;
      if (!hasOwnProperty.call(value, "length"))
        return false;
      try {
        if (typeof value.length !== "number")
          return false;
        if (typeof value.call !== "function")
          return false;
        if (typeof value.apply !== "function")
          return false;
      } catch (error) {
        return false;
      }
      return !isPrototype(value);
    };
  }
});

// node_modules/.pnpm/type@1.2.0/node_modules/type/plain-function/is.js
var require_is5 = __commonJS({
  "node_modules/.pnpm/type@1.2.0/node_modules/type/plain-function/is.js"(exports, module2) {
    "use strict";
    var isFunction = require_is4();
    var classRe = /^\s*class[\s{/}]/;
    var functionToString = Function.prototype.toString;
    module2.exports = function(value) {
      if (!isFunction(value))
        return false;
      if (classRe.test(functionToString.call(value)))
        return false;
      return true;
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/assign/is-implemented.js
var require_is_implemented = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/assign/is-implemented.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      var assign = Object.assign, obj;
      if (typeof assign !== "function")
        return false;
      obj = { foo: "raz" };
      assign(obj, { bar: "dwa" }, { trzy: "trzy" });
      return obj.foo + obj.bar + obj.trzy === "razdwatrzy";
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/keys/is-implemented.js
var require_is_implemented2 = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/keys/is-implemented.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      try {
        Object.keys("primitive");
        return true;
      } catch (e) {
        return false;
      }
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/function/noop.js
var require_noop = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/function/noop.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/is-value.js
var require_is_value = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/is-value.js"(exports, module2) {
    "use strict";
    var _undefined = require_noop()();
    module2.exports = function(val) {
      return val !== _undefined && val !== null;
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/keys/shim.js
var require_shim = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/keys/shim.js"(exports, module2) {
    "use strict";
    var isValue = require_is_value();
    var keys = Object.keys;
    module2.exports = function(object) {
      return keys(isValue(object) ? Object(object) : object);
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/keys/index.js
var require_keys = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/keys/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_is_implemented2()() ? Object.keys : require_shim();
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/valid-value.js
var require_valid_value = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/valid-value.js"(exports, module2) {
    "use strict";
    var isValue = require_is_value();
    module2.exports = function(value) {
      if (!isValue(value))
        throw new TypeError("Cannot use null or undefined");
      return value;
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/assign/shim.js
var require_shim2 = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/assign/shim.js"(exports, module2) {
    "use strict";
    var keys = require_keys();
    var value = require_valid_value();
    var max = Math.max;
    module2.exports = function(dest, src) {
      var error, i, length = max(arguments.length, 2), assign;
      dest = Object(value(dest));
      assign = function(key) {
        try {
          dest[key] = src[key];
        } catch (e) {
          if (!error)
            error = e;
        }
      };
      for (i = 1; i < length; ++i) {
        src = arguments[i];
        keys(src).forEach(assign);
      }
      if (error !== void 0)
        throw error;
      return dest;
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/assign/index.js
var require_assign = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/assign/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_is_implemented()() ? Object.assign : require_shim2();
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/normalize-options.js
var require_normalize_options = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/normalize-options.js"(exports, module2) {
    "use strict";
    var isValue = require_is_value();
    var forEach = Array.prototype.forEach;
    var create = Object.create;
    var process3 = function(src, obj) {
      var key;
      for (key in src)
        obj[key] = src[key];
    };
    module2.exports = function(opts1) {
      var result = create(null);
      forEach.call(arguments, function(options) {
        if (!isValue(options))
          return;
        process3(Object(options), result);
      });
      return result;
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/string/#/contains/is-implemented.js
var require_is_implemented3 = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/string/#/contains/is-implemented.js"(exports, module2) {
    "use strict";
    var str = "razdwatrzy";
    module2.exports = function() {
      if (typeof str.contains !== "function")
        return false;
      return str.contains("dwa") === true && str.contains("foo") === false;
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/string/#/contains/shim.js
var require_shim3 = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/string/#/contains/shim.js"(exports, module2) {
    "use strict";
    var indexOf = String.prototype.indexOf;
    module2.exports = function(searchString) {
      return indexOf.call(this, searchString, arguments[1]) > -1;
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/string/#/contains/index.js
var require_contains = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/string/#/contains/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_is_implemented3()() ? String.prototype.contains : require_shim3();
  }
});

// node_modules/.pnpm/d@1.0.1/node_modules/d/index.js
var require_d = __commonJS({
  "node_modules/.pnpm/d@1.0.1/node_modules/d/index.js"(exports, module2) {
    "use strict";
    var isValue = require_is();
    var isPlainFunction = require_is5();
    var assign = require_assign();
    var normalizeOpts = require_normalize_options();
    var contains = require_contains();
    var d = module2.exports = function(dscr, value) {
      var c, e, w, options, desc;
      if (arguments.length < 2 || typeof dscr !== "string") {
        options = value;
        value = dscr;
        dscr = null;
      } else {
        options = arguments[2];
      }
      if (isValue(dscr)) {
        c = contains.call(dscr, "c");
        e = contains.call(dscr, "e");
        w = contains.call(dscr, "w");
      } else {
        c = w = true;
        e = false;
      }
      desc = { value, configurable: c, enumerable: e, writable: w };
      return !options ? desc : assign(normalizeOpts(options), desc);
    };
    d.gs = function(dscr, get, set) {
      var c, e, options, desc;
      if (typeof dscr !== "string") {
        options = set;
        set = get;
        get = dscr;
        dscr = null;
      } else {
        options = arguments[3];
      }
      if (!isValue(get)) {
        get = void 0;
      } else if (!isPlainFunction(get)) {
        options = get;
        get = set = void 0;
      } else if (!isValue(set)) {
        set = void 0;
      } else if (!isPlainFunction(set)) {
        options = set;
        set = void 0;
      }
      if (isValue(dscr)) {
        c = contains.call(dscr, "c");
        e = contains.call(dscr, "e");
      } else {
        c = true;
        e = false;
      }
      desc = { get, set, configurable: c, enumerable: e };
      return !options ? desc : assign(normalizeOpts(options), desc);
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/valid-callable.js
var require_valid_callable = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/valid-callable.js"(exports, module2) {
    "use strict";
    module2.exports = function(fn) {
      if (typeof fn !== "function")
        throw new TypeError(fn + " is not a function");
      return fn;
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/_iterate.js
var require_iterate = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/_iterate.js"(exports, module2) {
    "use strict";
    var callable = require_valid_callable();
    var value = require_valid_value();
    var bind = Function.prototype.bind;
    var call = Function.prototype.call;
    var keys = Object.keys;
    var objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;
    module2.exports = function(method, defVal) {
      return function(obj, cb) {
        var list, thisArg = arguments[2], compareFn = arguments[3];
        obj = Object(value(obj));
        callable(cb);
        list = keys(obj);
        if (compareFn) {
          list.sort(typeof compareFn === "function" ? bind.call(compareFn, obj) : void 0);
        }
        if (typeof method !== "function")
          method = list[method];
        return call.call(method, list, function(key, index4) {
          if (!objPropertyIsEnumerable.call(obj, key))
            return defVal;
          return call.call(cb, thisArg, obj[key], key, obj, index4);
        });
      };
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/for-each.js
var require_for_each = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/for-each.js"(exports, module2) {
    "use strict";
    module2.exports = require_iterate()("forEach");
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/map.js
var require_map = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/map.js"(exports, module2) {
    "use strict";
    var callable = require_valid_callable();
    var forEach = require_for_each();
    var call = Function.prototype.call;
    module2.exports = function(obj, cb) {
      var result = {}, thisArg = arguments[2];
      callable(cb);
      forEach(obj, function(value, key, targetObj, index4) {
        result[key] = call.call(cb, thisArg, value, key, targetObj, index4);
      });
      return result;
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/primitive-set.js
var require_primitive_set = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/primitive-set.js"(exports, module2) {
    "use strict";
    var forEach = Array.prototype.forEach;
    var create = Object.create;
    module2.exports = function(arg) {
      var set = create(null);
      forEach.call(arguments, function(name) {
        set[name] = true;
      });
      return set;
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/set-prototype-of/is-implemented.js
var require_is_implemented4 = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/set-prototype-of/is-implemented.js"(exports, module2) {
    "use strict";
    var create = Object.create;
    var getPrototypeOf = Object.getPrototypeOf;
    var plainObject = {};
    module2.exports = function() {
      var setPrototypeOf = Object.setPrototypeOf, customCreate = arguments[0] || create;
      if (typeof setPrototypeOf !== "function")
        return false;
      return getPrototypeOf(setPrototypeOf(customCreate(null), plainObject)) === plainObject;
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/is-object.js
var require_is_object = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/is-object.js"(exports, module2) {
    "use strict";
    var isValue = require_is_value();
    var map = { function: true, object: true };
    module2.exports = function(value) {
      return isValue(value) && map[typeof value] || false;
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/create.js
var require_create = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/create.js"(exports, module2) {
    "use strict";
    var create = Object.create;
    var shim;
    if (!require_is_implemented4()()) {
      shim = require_shim4();
    }
    module2.exports = function() {
      var nullObject, polyProps, desc;
      if (!shim)
        return create;
      if (shim.level !== 1)
        return create;
      nullObject = {};
      polyProps = {};
      desc = { configurable: false, enumerable: false, writable: true, value: void 0 };
      Object.getOwnPropertyNames(Object.prototype).forEach(function(name) {
        if (name === "__proto__") {
          polyProps[name] = {
            configurable: true,
            enumerable: false,
            writable: true,
            value: void 0
          };
          return;
        }
        polyProps[name] = desc;
      });
      Object.defineProperties(nullObject, polyProps);
      Object.defineProperty(shim, "nullPolyfill", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: nullObject
      });
      return function(prototype, props) {
        return create(prototype === null ? nullObject : prototype, props);
      };
    }();
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/set-prototype-of/shim.js
var require_shim4 = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/set-prototype-of/shim.js"(exports, module2) {
    "use strict";
    var isObject = require_is_object();
    var value = require_valid_value();
    var objIsPrototypeOf = Object.prototype.isPrototypeOf;
    var defineProperty = Object.defineProperty;
    var nullDesc = { configurable: true, enumerable: false, writable: true, value: void 0 };
    var validate;
    validate = function(obj, prototype) {
      value(obj);
      if (prototype === null || isObject(prototype))
        return obj;
      throw new TypeError("Prototype must be null or an object");
    };
    module2.exports = function(status) {
      var fn, set;
      if (!status)
        return null;
      if (status.level === 2) {
        if (status.set) {
          set = status.set;
          fn = function(obj, prototype) {
            set.call(validate(obj, prototype), prototype);
            return obj;
          };
        } else {
          fn = function(obj, prototype) {
            validate(obj, prototype).__proto__ = prototype;
            return obj;
          };
        }
      } else {
        fn = function self2(obj, prototype) {
          var isNullBase;
          validate(obj, prototype);
          isNullBase = objIsPrototypeOf.call(self2.nullPolyfill, obj);
          if (isNullBase)
            delete self2.nullPolyfill.__proto__;
          if (prototype === null)
            prototype = self2.nullPolyfill;
          obj.__proto__ = prototype;
          if (isNullBase)
            defineProperty(self2.nullPolyfill, "__proto__", nullDesc);
          return obj;
        };
      }
      return Object.defineProperty(fn, "level", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: status.level
      });
    }(
      function() {
        var tmpObj1 = /* @__PURE__ */ Object.create(null), tmpObj2 = {}, set, desc = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__");
        if (desc) {
          try {
            set = desc.set;
            set.call(tmpObj1, tmpObj2);
          } catch (ignore) {
          }
          if (Object.getPrototypeOf(tmpObj1) === tmpObj2)
            return { set, level: 2 };
        }
        tmpObj1.__proto__ = tmpObj2;
        if (Object.getPrototypeOf(tmpObj1) === tmpObj2)
          return { level: 2 };
        tmpObj1 = {};
        tmpObj1.__proto__ = tmpObj2;
        if (Object.getPrototypeOf(tmpObj1) === tmpObj2)
          return { level: 1 };
        return false;
      }()
    );
    require_create();
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/set-prototype-of/index.js
var require_set_prototype_of = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/set-prototype-of/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_is_implemented4()() ? Object.setPrototypeOf : require_shim4();
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/math/sign/is-implemented.js
var require_is_implemented5 = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/math/sign/is-implemented.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      var sign = Math.sign;
      if (typeof sign !== "function")
        return false;
      return sign(10) === 1 && sign(-20) === -1;
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/math/sign/shim.js
var require_shim5 = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/math/sign/shim.js"(exports, module2) {
    "use strict";
    module2.exports = function(value) {
      value = Number(value);
      if (isNaN(value) || value === 0)
        return value;
      return value > 0 ? 1 : -1;
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/math/sign/index.js
var require_sign = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/math/sign/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_is_implemented5()() ? Math.sign : require_shim5();
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/number/to-integer.js
var require_to_integer = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/number/to-integer.js"(exports, module2) {
    "use strict";
    var sign = require_sign();
    var abs = Math.abs;
    var floor = Math.floor;
    module2.exports = function(value) {
      if (isNaN(value))
        return 0;
      value = Number(value);
      if (value === 0 || !isFinite(value))
        return value;
      return sign(value) * floor(abs(value));
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/number/to-pos-integer.js
var require_to_pos_integer = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/number/to-pos-integer.js"(exports, module2) {
    "use strict";
    var toInteger = require_to_integer();
    var max = Math.max;
    module2.exports = function(value) {
      return max(0, toInteger(value));
    };
  }
});

// node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/lib/resolve-length.js
var require_resolve_length = __commonJS({
  "node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/lib/resolve-length.js"(exports, module2) {
    "use strict";
    var toPosInt = require_to_pos_integer();
    module2.exports = function(optsLength, fnLength, isAsync2) {
      var length;
      if (isNaN(optsLength)) {
        length = fnLength;
        if (!(length >= 0))
          return 1;
        if (isAsync2 && length)
          return length - 1;
        return length;
      }
      if (optsLength === false)
        return false;
      return toPosInt(optsLength);
    };
  }
});

// node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/lib/registered-extensions.js
var require_registered_extensions = __commonJS({
  "node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/lib/registered-extensions.js"() {
    "use strict";
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/error/custom.js
var require_custom = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/error/custom.js"(exports, module2) {
    "use strict";
    var assign = require_assign();
    var isObject = require_is_object();
    var isValue = require_is_value();
    var captureStackTrace = Error.captureStackTrace;
    module2.exports = function(message) {
      var err = new Error(message), code = arguments[1], ext = arguments[2];
      if (!isValue(ext)) {
        if (isObject(code)) {
          ext = code;
          code = null;
        }
      }
      if (isValue(ext))
        assign(err, ext);
      if (isValue(code))
        err.code = code;
      if (captureStackTrace)
        captureStackTrace(err, module2.exports);
      return err;
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/mixin.js
var require_mixin = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/mixin.js"(exports, module2) {
    "use strict";
    var value = require_valid_value();
    var defineProperty = Object.defineProperty;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    module2.exports = function(target, source) {
      var error, sourceObject = Object(value(source));
      target = Object(value(target));
      getOwnPropertyNames(sourceObject).forEach(function(name) {
        try {
          defineProperty(target, name, getOwnPropertyDescriptor(source, name));
        } catch (e) {
          error = e;
        }
      });
      if (typeof getOwnPropertySymbols === "function") {
        getOwnPropertySymbols(sourceObject).forEach(function(symbol) {
          try {
            defineProperty(target, symbol, getOwnPropertyDescriptor(source, symbol));
          } catch (e) {
            error = e;
          }
        });
      }
      if (error !== void 0)
        throw error;
      return target;
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/function/_define-length.js
var require_define_length = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/function/_define-length.js"(exports, module2) {
    "use strict";
    var toPosInt = require_to_pos_integer();
    var test = function(arg1, arg2) {
      return arg2;
    };
    var desc;
    var defineProperty;
    var generate;
    var mixin;
    try {
      Object.defineProperty(test, "length", {
        configurable: true,
        writable: false,
        enumerable: false,
        value: 1
      });
    } catch (ignore) {
    }
    if (test.length === 1) {
      desc = { configurable: true, writable: false, enumerable: false };
      defineProperty = Object.defineProperty;
      module2.exports = function(fn, length) {
        length = toPosInt(length);
        if (fn.length === length)
          return fn;
        desc.value = length;
        return defineProperty(fn, "length", desc);
      };
    } else {
      mixin = require_mixin();
      generate = function() {
        var cache = [];
        return function(length) {
          var args, i = 0;
          if (cache[length])
            return cache[length];
          args = [];
          while (length--)
            args.push("a" + (++i).toString(36));
          return new Function(
            "fn",
            "return function (" + args.join(", ") + ") { return fn.apply(this, arguments); };"
          );
        };
      }();
      module2.exports = function(src, length) {
        var target;
        length = toPosInt(length);
        if (src.length === length)
          return src;
        target = generate(length)(src);
        try {
          mixin(target, src);
        } catch (ignore) {
        }
        return target;
      };
    }
  }
});

// node_modules/.pnpm/event-emitter@0.3.5/node_modules/event-emitter/index.js
var require_event_emitter = __commonJS({
  "node_modules/.pnpm/event-emitter@0.3.5/node_modules/event-emitter/index.js"(exports, module2) {
    "use strict";
    var d = require_d();
    var callable = require_valid_callable();
    var apply = Function.prototype.apply;
    var call = Function.prototype.call;
    var create = Object.create;
    var defineProperty = Object.defineProperty;
    var defineProperties = Object.defineProperties;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var descriptor = { configurable: true, enumerable: false, writable: true };
    var on;
    var once;
    var off;
    var emit;
    var methods;
    var descriptors;
    var base;
    on = function(type, listener) {
      var data;
      callable(listener);
      if (!hasOwnProperty2.call(this, "__ee__")) {
        data = descriptor.value = create(null);
        defineProperty(this, "__ee__", descriptor);
        descriptor.value = null;
      } else {
        data = this.__ee__;
      }
      if (!data[type])
        data[type] = listener;
      else if (typeof data[type] === "object")
        data[type].push(listener);
      else
        data[type] = [data[type], listener];
      return this;
    };
    once = function(type, listener) {
      var once2, self2;
      callable(listener);
      self2 = this;
      on.call(this, type, once2 = function() {
        off.call(self2, type, once2);
        apply.call(listener, this, arguments);
      });
      once2.__eeOnceListener__ = listener;
      return this;
    };
    off = function(type, listener) {
      var data, listeners, candidate, i;
      callable(listener);
      if (!hasOwnProperty2.call(this, "__ee__"))
        return this;
      data = this.__ee__;
      if (!data[type])
        return this;
      listeners = data[type];
      if (typeof listeners === "object") {
        for (i = 0; candidate = listeners[i]; ++i) {
          if (candidate === listener || candidate.__eeOnceListener__ === listener) {
            if (listeners.length === 2)
              data[type] = listeners[i ? 0 : 1];
            else
              listeners.splice(i, 1);
          }
        }
      } else {
        if (listeners === listener || listeners.__eeOnceListener__ === listener) {
          delete data[type];
        }
      }
      return this;
    };
    emit = function(type) {
      var i, l, listener, listeners, args;
      if (!hasOwnProperty2.call(this, "__ee__"))
        return;
      listeners = this.__ee__[type];
      if (!listeners)
        return;
      if (typeof listeners === "object") {
        l = arguments.length;
        args = new Array(l - 1);
        for (i = 1; i < l; ++i)
          args[i - 1] = arguments[i];
        listeners = listeners.slice();
        for (i = 0; listener = listeners[i]; ++i) {
          apply.call(listener, this, args);
        }
      } else {
        switch (arguments.length) {
          case 1:
            call.call(listeners, this);
            break;
          case 2:
            call.call(listeners, this, arguments[1]);
            break;
          case 3:
            call.call(listeners, this, arguments[1], arguments[2]);
            break;
          default:
            l = arguments.length;
            args = new Array(l - 1);
            for (i = 1; i < l; ++i) {
              args[i - 1] = arguments[i];
            }
            apply.call(listeners, this, args);
        }
      }
    };
    methods = {
      on,
      once,
      off,
      emit
    };
    descriptors = {
      on: d(on),
      once: d(once),
      off: d(off),
      emit: d(emit)
    };
    base = defineProperties({}, descriptors);
    module2.exports = exports = function(o) {
      return o == null ? create(base) : defineProperties(Object(o), descriptors);
    };
    exports.methods = methods;
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/array/from/is-implemented.js
var require_is_implemented6 = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/array/from/is-implemented.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      var from = Array.from, arr, result;
      if (typeof from !== "function")
        return false;
      arr = ["raz", "dwa"];
      result = from(arr);
      return Boolean(result && result !== arr && result[1] === "dwa");
    };
  }
});

// node_modules/.pnpm/ext@1.7.0/node_modules/ext/global-this/is-implemented.js
var require_is_implemented7 = __commonJS({
  "node_modules/.pnpm/ext@1.7.0/node_modules/ext/global-this/is-implemented.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      if (typeof globalThis !== "object")
        return false;
      if (!globalThis)
        return false;
      return globalThis.Array === Array;
    };
  }
});

// node_modules/.pnpm/ext@1.7.0/node_modules/ext/global-this/implementation.js
var require_implementation = __commonJS({
  "node_modules/.pnpm/ext@1.7.0/node_modules/ext/global-this/implementation.js"(exports, module2) {
    var naiveFallback = function() {
      if (typeof self === "object" && self)
        return self;
      if (typeof window === "object" && window)
        return window;
      throw new Error("Unable to resolve global `this`");
    };
    module2.exports = function() {
      if (this)
        return this;
      try {
        Object.defineProperty(Object.prototype, "__global__", {
          get: function() {
            return this;
          },
          configurable: true
        });
      } catch (error) {
        return naiveFallback();
      }
      try {
        if (!__global__)
          return naiveFallback();
        return __global__;
      } finally {
        delete Object.prototype.__global__;
      }
    }();
  }
});

// node_modules/.pnpm/ext@1.7.0/node_modules/ext/global-this/index.js
var require_global_this = __commonJS({
  "node_modules/.pnpm/ext@1.7.0/node_modules/ext/global-this/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_is_implemented7()() ? globalThis : require_implementation();
  }
});

// node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/is-implemented.js
var require_is_implemented8 = __commonJS({
  "node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/is-implemented.js"(exports, module2) {
    "use strict";
    var global2 = require_global_this();
    var validTypes = { object: true, symbol: true };
    module2.exports = function() {
      var Symbol2 = global2.Symbol;
      var symbol;
      if (typeof Symbol2 !== "function")
        return false;
      symbol = Symbol2("test symbol");
      try {
        String(symbol);
      } catch (e) {
        return false;
      }
      if (!validTypes[typeof Symbol2.iterator])
        return false;
      if (!validTypes[typeof Symbol2.toPrimitive])
        return false;
      if (!validTypes[typeof Symbol2.toStringTag])
        return false;
      return true;
    };
  }
});

// node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/is-symbol.js
var require_is_symbol = __commonJS({
  "node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/is-symbol.js"(exports, module2) {
    "use strict";
    module2.exports = function(value) {
      if (!value)
        return false;
      if (typeof value === "symbol")
        return true;
      if (!value.constructor)
        return false;
      if (value.constructor.name !== "Symbol")
        return false;
      return value[value.constructor.toStringTag] === "Symbol";
    };
  }
});

// node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/validate-symbol.js
var require_validate_symbol = __commonJS({
  "node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/validate-symbol.js"(exports, module2) {
    "use strict";
    var isSymbol = require_is_symbol();
    module2.exports = function(value) {
      if (!isSymbol(value))
        throw new TypeError(value + " is not a symbol");
      return value;
    };
  }
});

// node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/lib/private/generate-name.js
var require_generate_name = __commonJS({
  "node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/lib/private/generate-name.js"(exports, module2) {
    "use strict";
    var d = require_d();
    var create = Object.create;
    var defineProperty = Object.defineProperty;
    var objPrototype = Object.prototype;
    var created = create(null);
    module2.exports = function(desc) {
      var postfix = 0, name, ie11BugWorkaround;
      while (created[desc + (postfix || "")])
        ++postfix;
      desc += postfix || "";
      created[desc] = true;
      name = "@@" + desc;
      defineProperty(
        objPrototype,
        name,
        d.gs(null, function(value) {
          if (ie11BugWorkaround)
            return;
          ie11BugWorkaround = true;
          defineProperty(this, name, d(value));
          ie11BugWorkaround = false;
        })
      );
      return name;
    };
  }
});

// node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/lib/private/setup/standard-symbols.js
var require_standard_symbols = __commonJS({
  "node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/lib/private/setup/standard-symbols.js"(exports, module2) {
    "use strict";
    var d = require_d();
    var NativeSymbol = require_global_this().Symbol;
    module2.exports = function(SymbolPolyfill) {
      return Object.defineProperties(SymbolPolyfill, {
        // To ensure proper interoperability with other native functions (e.g. Array.from)
        // fallback to eventual native implementation of given symbol
        hasInstance: d(
          "",
          NativeSymbol && NativeSymbol.hasInstance || SymbolPolyfill("hasInstance")
        ),
        isConcatSpreadable: d(
          "",
          NativeSymbol && NativeSymbol.isConcatSpreadable || SymbolPolyfill("isConcatSpreadable")
        ),
        iterator: d("", NativeSymbol && NativeSymbol.iterator || SymbolPolyfill("iterator")),
        match: d("", NativeSymbol && NativeSymbol.match || SymbolPolyfill("match")),
        replace: d("", NativeSymbol && NativeSymbol.replace || SymbolPolyfill("replace")),
        search: d("", NativeSymbol && NativeSymbol.search || SymbolPolyfill("search")),
        species: d("", NativeSymbol && NativeSymbol.species || SymbolPolyfill("species")),
        split: d("", NativeSymbol && NativeSymbol.split || SymbolPolyfill("split")),
        toPrimitive: d(
          "",
          NativeSymbol && NativeSymbol.toPrimitive || SymbolPolyfill("toPrimitive")
        ),
        toStringTag: d(
          "",
          NativeSymbol && NativeSymbol.toStringTag || SymbolPolyfill("toStringTag")
        ),
        unscopables: d(
          "",
          NativeSymbol && NativeSymbol.unscopables || SymbolPolyfill("unscopables")
        )
      });
    };
  }
});

// node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/lib/private/setup/symbol-registry.js
var require_symbol_registry = __commonJS({
  "node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/lib/private/setup/symbol-registry.js"(exports, module2) {
    "use strict";
    var d = require_d();
    var validateSymbol = require_validate_symbol();
    var registry = /* @__PURE__ */ Object.create(null);
    module2.exports = function(SymbolPolyfill) {
      return Object.defineProperties(SymbolPolyfill, {
        for: d(function(key) {
          if (registry[key])
            return registry[key];
          return registry[key] = SymbolPolyfill(String(key));
        }),
        keyFor: d(function(symbol) {
          var key;
          validateSymbol(symbol);
          for (key in registry) {
            if (registry[key] === symbol)
              return key;
          }
          return void 0;
        })
      });
    };
  }
});

// node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/polyfill.js"(exports, module2) {
    "use strict";
    var d = require_d();
    var validateSymbol = require_validate_symbol();
    var NativeSymbol = require_global_this().Symbol;
    var generateName = require_generate_name();
    var setupStandardSymbols = require_standard_symbols();
    var setupSymbolRegistry = require_symbol_registry();
    var create = Object.create;
    var defineProperties = Object.defineProperties;
    var defineProperty = Object.defineProperty;
    var SymbolPolyfill;
    var HiddenSymbol;
    var isNativeSafe;
    if (typeof NativeSymbol === "function") {
      try {
        String(NativeSymbol());
        isNativeSafe = true;
      } catch (ignore) {
      }
    } else {
      NativeSymbol = null;
    }
    HiddenSymbol = function Symbol2(description) {
      if (this instanceof HiddenSymbol)
        throw new TypeError("Symbol is not a constructor");
      return SymbolPolyfill(description);
    };
    module2.exports = SymbolPolyfill = function Symbol2(description) {
      var symbol;
      if (this instanceof Symbol2)
        throw new TypeError("Symbol is not a constructor");
      if (isNativeSafe)
        return NativeSymbol(description);
      symbol = create(HiddenSymbol.prototype);
      description = description === void 0 ? "" : String(description);
      return defineProperties(symbol, {
        __description__: d("", description),
        __name__: d("", generateName(description))
      });
    };
    setupStandardSymbols(SymbolPolyfill);
    setupSymbolRegistry(SymbolPolyfill);
    defineProperties(HiddenSymbol.prototype, {
      constructor: d(SymbolPolyfill),
      toString: d("", function() {
        return this.__name__;
      })
    });
    defineProperties(SymbolPolyfill.prototype, {
      toString: d(function() {
        return "Symbol (" + validateSymbol(this).__description__ + ")";
      }),
      valueOf: d(function() {
        return validateSymbol(this);
      })
    });
    defineProperty(
      SymbolPolyfill.prototype,
      SymbolPolyfill.toPrimitive,
      d("", function() {
        var symbol = validateSymbol(this);
        if (typeof symbol === "symbol")
          return symbol;
        return symbol.toString();
      })
    );
    defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d("c", "Symbol"));
    defineProperty(
      HiddenSymbol.prototype,
      SymbolPolyfill.toStringTag,
      d("c", SymbolPolyfill.prototype[SymbolPolyfill.toStringTag])
    );
    defineProperty(
      HiddenSymbol.prototype,
      SymbolPolyfill.toPrimitive,
      d("c", SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive])
    );
  }
});

// node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/index.js
var require_es6_symbol = __commonJS({
  "node_modules/.pnpm/es6-symbol@3.1.3/node_modules/es6-symbol/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_is_implemented8()() ? require_global_this().Symbol : require_polyfill();
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/function/is-arguments.js
var require_is_arguments = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/function/is-arguments.js"(exports, module2) {
    "use strict";
    var objToString = Object.prototype.toString;
    var id = objToString.call(function() {
      return arguments;
    }());
    module2.exports = function(value) {
      return objToString.call(value) === id;
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/function/is-function.js
var require_is_function = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/function/is-function.js"(exports, module2) {
    "use strict";
    var objToString = Object.prototype.toString;
    var isFunctionStringTag = RegExp.prototype.test.bind(/^[object [A-Za-z0-9]*Function]$/);
    module2.exports = function(value) {
      return typeof value === "function" && isFunctionStringTag(objToString.call(value));
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/string/is-string.js
var require_is_string = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/string/is-string.js"(exports, module2) {
    "use strict";
    var objToString = Object.prototype.toString;
    var id = objToString.call("");
    module2.exports = function(value) {
      return typeof value === "string" || value && typeof value === "object" && (value instanceof String || objToString.call(value) === id) || false;
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/array/from/shim.js
var require_shim6 = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/array/from/shim.js"(exports, module2) {
    "use strict";
    var iteratorSymbol = require_es6_symbol().iterator;
    var isArguments = require_is_arguments();
    var isFunction = require_is_function();
    var toPosInt = require_to_pos_integer();
    var callable = require_valid_callable();
    var validValue = require_valid_value();
    var isValue = require_is_value();
    var isString = require_is_string();
    var isArray = Array.isArray;
    var call = Function.prototype.call;
    var desc = { configurable: true, enumerable: true, writable: true, value: null };
    var defineProperty = Object.defineProperty;
    module2.exports = function(arrayLike) {
      var mapFn = arguments[1], thisArg = arguments[2], Context, i, j, arr, length, code, iterator, result, getIterator, value;
      arrayLike = Object(validValue(arrayLike));
      if (isValue(mapFn))
        callable(mapFn);
      if (!this || this === Array || !isFunction(this)) {
        if (!mapFn) {
          if (isArguments(arrayLike)) {
            length = arrayLike.length;
            if (length !== 1)
              return Array.apply(null, arrayLike);
            arr = new Array(1);
            arr[0] = arrayLike[0];
            return arr;
          }
          if (isArray(arrayLike)) {
            arr = new Array(length = arrayLike.length);
            for (i = 0; i < length; ++i)
              arr[i] = arrayLike[i];
            return arr;
          }
        }
        arr = [];
      } else {
        Context = this;
      }
      if (!isArray(arrayLike)) {
        if ((getIterator = arrayLike[iteratorSymbol]) !== void 0) {
          iterator = callable(getIterator).call(arrayLike);
          if (Context)
            arr = new Context();
          result = iterator.next();
          i = 0;
          while (!result.done) {
            value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
            if (Context) {
              desc.value = value;
              defineProperty(arr, i, desc);
            } else {
              arr[i] = value;
            }
            result = iterator.next();
            ++i;
          }
          length = i;
        } else if (isString(arrayLike)) {
          length = arrayLike.length;
          if (Context)
            arr = new Context();
          for (i = 0, j = 0; i < length; ++i) {
            value = arrayLike[i];
            if (i + 1 < length) {
              code = value.charCodeAt(0);
              if (code >= 55296 && code <= 56319)
                value += arrayLike[++i];
            }
            value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
            if (Context) {
              desc.value = value;
              defineProperty(arr, j, desc);
            } else {
              arr[j] = value;
            }
            ++j;
          }
          length = j;
        }
      }
      if (length === void 0) {
        length = toPosInt(arrayLike.length);
        if (Context)
          arr = new Context(length);
        for (i = 0; i < length; ++i) {
          value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
          if (Context) {
            desc.value = value;
            defineProperty(arr, i, desc);
          } else {
            arr[i] = value;
          }
        }
      }
      if (Context) {
        desc.value = null;
        arr.length = length;
      }
      return arr;
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/array/from/index.js
var require_from = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/array/from/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_is_implemented6()() ? Array.from : require_shim6();
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/array/to-array.js
var require_to_array = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/array/to-array.js"(exports, module2) {
    "use strict";
    var from = require_from();
    var isArray = Array.isArray;
    module2.exports = function(arrayLike) {
      return isArray(arrayLike) ? arrayLike : from(arrayLike);
    };
  }
});

// node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/lib/resolve-resolve.js
var require_resolve_resolve = __commonJS({
  "node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/lib/resolve-resolve.js"(exports, module2) {
    "use strict";
    var toArray = require_to_array();
    var isValue = require_is_value();
    var callable = require_valid_callable();
    var slice = Array.prototype.slice;
    var resolveArgs;
    resolveArgs = function(args) {
      return this.map(function(resolve, i) {
        return resolve ? resolve(args[i]) : args[i];
      }).concat(slice.call(args, this.length));
    };
    module2.exports = function(resolvers) {
      resolvers = toArray(resolvers);
      resolvers.forEach(function(resolve) {
        if (isValue(resolve))
          callable(resolve);
      });
      return resolveArgs.bind(resolvers);
    };
  }
});

// node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/lib/resolve-normalize.js
var require_resolve_normalize = __commonJS({
  "node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/lib/resolve-normalize.js"(exports, module2) {
    "use strict";
    var callable = require_valid_callable();
    module2.exports = function(userNormalizer) {
      var normalizer;
      if (typeof userNormalizer === "function")
        return { set: userNormalizer, get: userNormalizer };
      normalizer = { get: callable(userNormalizer.get) };
      if (userNormalizer.set !== void 0) {
        normalizer.set = callable(userNormalizer.set);
        if (userNormalizer.delete)
          normalizer.delete = callable(userNormalizer.delete);
        if (userNormalizer.clear)
          normalizer.clear = callable(userNormalizer.clear);
        return normalizer;
      }
      normalizer.set = normalizer.get;
      return normalizer;
    };
  }
});

// node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/lib/configure-map.js
var require_configure_map = __commonJS({
  "node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/lib/configure-map.js"(exports, module2) {
    "use strict";
    var customError = require_custom();
    var defineLength = require_define_length();
    var d = require_d();
    var ee = require_event_emitter().methods;
    var resolveResolve = require_resolve_resolve();
    var resolveNormalize = require_resolve_normalize();
    var apply = Function.prototype.apply;
    var call = Function.prototype.call;
    var create = Object.create;
    var defineProperties = Object.defineProperties;
    var on = ee.on;
    var emit = ee.emit;
    module2.exports = function(original, length, options) {
      var cache = create(null), conf, memLength, get, set, del, clear, extDel, extGet, extHas, normalizer, getListeners, setListeners, deleteListeners, memoized, resolve;
      if (length !== false)
        memLength = length;
      else if (isNaN(original.length))
        memLength = 1;
      else
        memLength = original.length;
      if (options.normalizer) {
        normalizer = resolveNormalize(options.normalizer);
        get = normalizer.get;
        set = normalizer.set;
        del = normalizer.delete;
        clear = normalizer.clear;
      }
      if (options.resolvers != null)
        resolve = resolveResolve(options.resolvers);
      if (get) {
        memoized = defineLength(function(arg) {
          var id, result, args = arguments;
          if (resolve)
            args = resolve(args);
          id = get(args);
          if (id !== null) {
            if (hasOwnProperty.call(cache, id)) {
              if (getListeners)
                conf.emit("get", id, args, this);
              return cache[id];
            }
          }
          if (args.length === 1)
            result = call.call(original, this, args[0]);
          else
            result = apply.call(original, this, args);
          if (id === null) {
            id = get(args);
            if (id !== null)
              throw customError("Circular invocation", "CIRCULAR_INVOCATION");
            id = set(args);
          } else if (hasOwnProperty.call(cache, id)) {
            throw customError("Circular invocation", "CIRCULAR_INVOCATION");
          }
          cache[id] = result;
          if (setListeners)
            conf.emit("set", id, null, result);
          return result;
        }, memLength);
      } else if (length === 0) {
        memoized = function() {
          var result;
          if (hasOwnProperty.call(cache, "data")) {
            if (getListeners)
              conf.emit("get", "data", arguments, this);
            return cache.data;
          }
          if (arguments.length)
            result = apply.call(original, this, arguments);
          else
            result = call.call(original, this);
          if (hasOwnProperty.call(cache, "data")) {
            throw customError("Circular invocation", "CIRCULAR_INVOCATION");
          }
          cache.data = result;
          if (setListeners)
            conf.emit("set", "data", null, result);
          return result;
        };
      } else {
        memoized = function(arg) {
          var result, args = arguments, id;
          if (resolve)
            args = resolve(arguments);
          id = String(args[0]);
          if (hasOwnProperty.call(cache, id)) {
            if (getListeners)
              conf.emit("get", id, args, this);
            return cache[id];
          }
          if (args.length === 1)
            result = call.call(original, this, args[0]);
          else
            result = apply.call(original, this, args);
          if (hasOwnProperty.call(cache, id)) {
            throw customError("Circular invocation", "CIRCULAR_INVOCATION");
          }
          cache[id] = result;
          if (setListeners)
            conf.emit("set", id, null, result);
          return result;
        };
      }
      conf = {
        original,
        memoized,
        profileName: options.profileName,
        get: function(args) {
          if (resolve)
            args = resolve(args);
          if (get)
            return get(args);
          return String(args[0]);
        },
        has: function(id) {
          return hasOwnProperty.call(cache, id);
        },
        delete: function(id) {
          var result;
          if (!hasOwnProperty.call(cache, id))
            return;
          if (del)
            del(id);
          result = cache[id];
          delete cache[id];
          if (deleteListeners)
            conf.emit("delete", id, result);
        },
        clear: function() {
          var oldCache = cache;
          if (clear)
            clear();
          cache = create(null);
          conf.emit("clear", oldCache);
        },
        on: function(type, listener) {
          if (type === "get")
            getListeners = true;
          else if (type === "set")
            setListeners = true;
          else if (type === "delete")
            deleteListeners = true;
          return on.call(this, type, listener);
        },
        emit,
        updateEnv: function() {
          original = conf.original;
        }
      };
      if (get) {
        extDel = defineLength(function(arg) {
          var id, args = arguments;
          if (resolve)
            args = resolve(args);
          id = get(args);
          if (id === null)
            return;
          conf.delete(id);
        }, memLength);
      } else if (length === 0) {
        extDel = function() {
          return conf.delete("data");
        };
      } else {
        extDel = function(arg) {
          if (resolve)
            arg = resolve(arguments)[0];
          return conf.delete(arg);
        };
      }
      extGet = defineLength(function() {
        var id, args = arguments;
        if (length === 0)
          return cache.data;
        if (resolve)
          args = resolve(args);
        if (get)
          id = get(args);
        else
          id = String(args[0]);
        return cache[id];
      });
      extHas = defineLength(function() {
        var id, args = arguments;
        if (length === 0)
          return conf.has("data");
        if (resolve)
          args = resolve(args);
        if (get)
          id = get(args);
        else
          id = String(args[0]);
        if (id === null)
          return false;
        return conf.has(id);
      });
      defineProperties(memoized, {
        __memoized__: d(true),
        delete: d(extDel),
        clear: d(conf.clear),
        _get: d(extGet),
        _has: d(extHas)
      });
      return conf;
    };
  }
});

// node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/plain.js
var require_plain = __commonJS({
  "node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/plain.js"(exports, module2) {
    "use strict";
    var callable = require_valid_callable();
    var forEach = require_for_each();
    var extensions = require_registered_extensions();
    var configure = require_configure_map();
    var resolveLength = require_resolve_length();
    module2.exports = function self2(fn) {
      var options, length, conf;
      callable(fn);
      options = Object(arguments[1]);
      if (options.async && options.promise) {
        throw new Error("Options 'async' and 'promise' cannot be used together");
      }
      if (hasOwnProperty.call(fn, "__memoized__") && !options.force)
        return fn;
      length = resolveLength(options.length, fn.length, options.async && extensions.async);
      conf = configure(fn, length, options);
      forEach(extensions, function(extFn, name) {
        if (options[name])
          extFn(options[name], conf, options);
      });
      if (self2.__profiler__)
        self2.__profiler__(conf);
      conf.updateEnv();
      return conf.memoized;
    };
  }
});

// node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/normalizers/primitive.js
var require_primitive = __commonJS({
  "node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/normalizers/primitive.js"(exports, module2) {
    "use strict";
    module2.exports = function(args) {
      var id, i, length = args.length;
      if (!length)
        return "";
      id = String(args[i = 0]);
      while (--length)
        id += "" + args[++i];
      return id;
    };
  }
});

// node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/normalizers/get-primitive-fixed.js
var require_get_primitive_fixed = __commonJS({
  "node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/normalizers/get-primitive-fixed.js"(exports, module2) {
    "use strict";
    module2.exports = function(length) {
      if (!length) {
        return function() {
          return "";
        };
      }
      return function(args) {
        var id = String(args[0]), i = 0, currentLength = length;
        while (--currentLength) {
          id += "" + args[++i];
        }
        return id;
      };
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/number/is-nan/is-implemented.js
var require_is_implemented9 = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/number/is-nan/is-implemented.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      var numberIsNaN = Number.isNaN;
      if (typeof numberIsNaN !== "function")
        return false;
      return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/number/is-nan/shim.js
var require_shim7 = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/number/is-nan/shim.js"(exports, module2) {
    "use strict";
    module2.exports = function(value) {
      return value !== value;
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/number/is-nan/index.js
var require_is_nan = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/number/is-nan/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_is_implemented9()() ? Number.isNaN : require_shim7();
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/array/#/e-index-of.js
var require_e_index_of = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/array/#/e-index-of.js"(exports, module2) {
    "use strict";
    var numberIsNaN = require_is_nan();
    var toPosInt = require_to_pos_integer();
    var value = require_valid_value();
    var indexOf = Array.prototype.indexOf;
    var objHasOwnProperty = Object.prototype.hasOwnProperty;
    var abs = Math.abs;
    var floor = Math.floor;
    module2.exports = function(searchElement) {
      var i, length, fromIndex, val;
      if (!numberIsNaN(searchElement))
        return indexOf.apply(this, arguments);
      length = toPosInt(value(this).length);
      fromIndex = arguments[1];
      if (isNaN(fromIndex))
        fromIndex = 0;
      else if (fromIndex >= 0)
        fromIndex = floor(fromIndex);
      else
        fromIndex = toPosInt(this.length) - floor(abs(fromIndex));
      for (i = fromIndex; i < length; ++i) {
        if (objHasOwnProperty.call(this, i)) {
          val = this[i];
          if (numberIsNaN(val))
            return i;
        }
      }
      return -1;
    };
  }
});

// node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/normalizers/get.js
var require_get = __commonJS({
  "node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/normalizers/get.js"(exports, module2) {
    "use strict";
    var indexOf = require_e_index_of();
    var create = Object.create;
    module2.exports = function() {
      var lastId = 0, map = [], cache = create(null);
      return {
        get: function(args) {
          var index4 = 0, set = map, i, length = args.length;
          if (length === 0)
            return set[length] || null;
          if (set = set[length]) {
            while (index4 < length - 1) {
              i = indexOf.call(set[0], args[index4]);
              if (i === -1)
                return null;
              set = set[1][i];
              ++index4;
            }
            i = indexOf.call(set[0], args[index4]);
            if (i === -1)
              return null;
            return set[1][i] || null;
          }
          return null;
        },
        set: function(args) {
          var index4 = 0, set = map, i, length = args.length;
          if (length === 0) {
            set[length] = ++lastId;
          } else {
            if (!set[length]) {
              set[length] = [[], []];
            }
            set = set[length];
            while (index4 < length - 1) {
              i = indexOf.call(set[0], args[index4]);
              if (i === -1) {
                i = set[0].push(args[index4]) - 1;
                set[1].push([[], []]);
              }
              set = set[1][i];
              ++index4;
            }
            i = indexOf.call(set[0], args[index4]);
            if (i === -1) {
              i = set[0].push(args[index4]) - 1;
            }
            set[1][i] = ++lastId;
          }
          cache[lastId] = args;
          return lastId;
        },
        delete: function(id) {
          var index4 = 0, set = map, i, args = cache[id], length = args.length, path = [];
          if (length === 0) {
            delete set[length];
          } else if (set = set[length]) {
            while (index4 < length - 1) {
              i = indexOf.call(set[0], args[index4]);
              if (i === -1) {
                return;
              }
              path.push(set, i);
              set = set[1][i];
              ++index4;
            }
            i = indexOf.call(set[0], args[index4]);
            if (i === -1) {
              return;
            }
            id = set[1][i];
            set[0].splice(i, 1);
            set[1].splice(i, 1);
            while (!set[0].length && path.length) {
              i = path.pop();
              set = path.pop();
              set[0].splice(i, 1);
              set[1].splice(i, 1);
            }
          }
          delete cache[id];
        },
        clear: function() {
          map = [];
          cache = create(null);
        }
      };
    };
  }
});

// node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/normalizers/get-1.js
var require_get_1 = __commonJS({
  "node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/normalizers/get-1.js"(exports, module2) {
    "use strict";
    var indexOf = require_e_index_of();
    module2.exports = function() {
      var lastId = 0, argsMap = [], cache = [];
      return {
        get: function(args) {
          var index4 = indexOf.call(argsMap, args[0]);
          return index4 === -1 ? null : cache[index4];
        },
        set: function(args) {
          argsMap.push(args[0]);
          cache.push(++lastId);
          return lastId;
        },
        delete: function(id) {
          var index4 = indexOf.call(cache, id);
          if (index4 !== -1) {
            argsMap.splice(index4, 1);
            cache.splice(index4, 1);
          }
        },
        clear: function() {
          argsMap = [];
          cache = [];
        }
      };
    };
  }
});

// node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/normalizers/get-fixed.js
var require_get_fixed = __commonJS({
  "node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/normalizers/get-fixed.js"(exports, module2) {
    "use strict";
    var indexOf = require_e_index_of();
    var create = Object.create;
    module2.exports = function(length) {
      var lastId = 0, map = [[], []], cache = create(null);
      return {
        get: function(args) {
          var index4 = 0, set = map, i;
          while (index4 < length - 1) {
            i = indexOf.call(set[0], args[index4]);
            if (i === -1)
              return null;
            set = set[1][i];
            ++index4;
          }
          i = indexOf.call(set[0], args[index4]);
          if (i === -1)
            return null;
          return set[1][i] || null;
        },
        set: function(args) {
          var index4 = 0, set = map, i;
          while (index4 < length - 1) {
            i = indexOf.call(set[0], args[index4]);
            if (i === -1) {
              i = set[0].push(args[index4]) - 1;
              set[1].push([[], []]);
            }
            set = set[1][i];
            ++index4;
          }
          i = indexOf.call(set[0], args[index4]);
          if (i === -1) {
            i = set[0].push(args[index4]) - 1;
          }
          set[1][i] = ++lastId;
          cache[lastId] = args;
          return lastId;
        },
        delete: function(id) {
          var index4 = 0, set = map, i, path = [], args = cache[id];
          while (index4 < length - 1) {
            i = indexOf.call(set[0], args[index4]);
            if (i === -1) {
              return;
            }
            path.push(set, i);
            set = set[1][i];
            ++index4;
          }
          i = indexOf.call(set[0], args[index4]);
          if (i === -1) {
            return;
          }
          id = set[1][i];
          set[0].splice(i, 1);
          set[1].splice(i, 1);
          while (!set[0].length && path.length) {
            i = path.pop();
            set = path.pop();
            set[0].splice(i, 1);
            set[1].splice(i, 1);
          }
          delete cache[id];
        },
        clear: function() {
          map = [[], []];
          cache = create(null);
        }
      };
    };
  }
});

// node_modules/.pnpm/next-tick@1.1.0/node_modules/next-tick/index.js
var require_next_tick = __commonJS({
  "node_modules/.pnpm/next-tick@1.1.0/node_modules/next-tick/index.js"(exports, module2) {
    "use strict";
    var ensureCallable = function(fn) {
      if (typeof fn !== "function")
        throw new TypeError(fn + " is not a function");
      return fn;
    };
    var byObserver = function(Observer) {
      var node = document.createTextNode(""), queue, currentQueue, i = 0;
      new Observer(function() {
        var callback;
        if (!queue) {
          if (!currentQueue)
            return;
          queue = currentQueue;
        } else if (currentQueue) {
          queue = currentQueue.concat(queue);
        }
        currentQueue = queue;
        queue = null;
        if (typeof currentQueue === "function") {
          callback = currentQueue;
          currentQueue = null;
          callback();
          return;
        }
        node.data = i = ++i % 2;
        while (currentQueue) {
          callback = currentQueue.shift();
          if (!currentQueue.length)
            currentQueue = null;
          callback();
        }
      }).observe(node, { characterData: true });
      return function(fn) {
        ensureCallable(fn);
        if (queue) {
          if (typeof queue === "function")
            queue = [queue, fn];
          else
            queue.push(fn);
          return;
        }
        queue = fn;
        node.data = i = ++i % 2;
      };
    };
    module2.exports = function() {
      if (typeof process === "object" && process && typeof process.nextTick === "function") {
        return process.nextTick;
      }
      if (typeof queueMicrotask === "function") {
        return function(cb) {
          queueMicrotask(ensureCallable(cb));
        };
      }
      if (typeof document === "object" && document) {
        if (typeof MutationObserver === "function")
          return byObserver(MutationObserver);
        if (typeof WebKitMutationObserver === "function")
          return byObserver(WebKitMutationObserver);
      }
      if (typeof setImmediate === "function") {
        return function(cb) {
          setImmediate(ensureCallable(cb));
        };
      }
      if (typeof setTimeout === "function" || typeof setTimeout === "object") {
        return function(cb) {
          setTimeout(ensureCallable(cb), 0);
        };
      }
      return null;
    }();
  }
});

// node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/ext/async.js
var require_async = __commonJS({
  "node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/ext/async.js"() {
    "use strict";
    var aFrom = require_from();
    var objectMap = require_map();
    var mixin = require_mixin();
    var defineLength = require_define_length();
    var nextTick = require_next_tick();
    var slice = Array.prototype.slice;
    var apply = Function.prototype.apply;
    var create = Object.create;
    require_registered_extensions().async = function(tbi, conf) {
      var waiting = create(null), cache = create(null), base = conf.memoized, original = conf.original, currentCallback, currentContext, currentArgs;
      conf.memoized = defineLength(function(arg) {
        var args = arguments, last = args[args.length - 1];
        if (typeof last === "function") {
          currentCallback = last;
          args = slice.call(args, 0, -1);
        }
        return base.apply(currentContext = this, currentArgs = args);
      }, base);
      try {
        mixin(conf.memoized, base);
      } catch (ignore) {
      }
      conf.on("get", function(id) {
        var cb, context, args;
        if (!currentCallback)
          return;
        if (waiting[id]) {
          if (typeof waiting[id] === "function")
            waiting[id] = [waiting[id], currentCallback];
          else
            waiting[id].push(currentCallback);
          currentCallback = null;
          return;
        }
        cb = currentCallback;
        context = currentContext;
        args = currentArgs;
        currentCallback = currentContext = currentArgs = null;
        nextTick(function() {
          var data;
          if (hasOwnProperty.call(cache, id)) {
            data = cache[id];
            conf.emit("getasync", id, args, context);
            apply.call(cb, data.context, data.args);
          } else {
            currentCallback = cb;
            currentContext = context;
            currentArgs = args;
            base.apply(context, args);
          }
        });
      });
      conf.original = function() {
        var args, cb, origCb, result;
        if (!currentCallback)
          return apply.call(original, this, arguments);
        args = aFrom(arguments);
        cb = function self2(err) {
          var cb2, args2, id = self2.id;
          if (id == null) {
            nextTick(apply.bind(self2, this, arguments));
            return void 0;
          }
          delete self2.id;
          cb2 = waiting[id];
          delete waiting[id];
          if (!cb2) {
            return void 0;
          }
          args2 = aFrom(arguments);
          if (conf.has(id)) {
            if (err) {
              conf.delete(id);
            } else {
              cache[id] = { context: this, args: args2 };
              conf.emit("setasync", id, typeof cb2 === "function" ? 1 : cb2.length);
            }
          }
          if (typeof cb2 === "function") {
            result = apply.call(cb2, this, args2);
          } else {
            cb2.forEach(function(cb3) {
              result = apply.call(cb3, this, args2);
            }, this);
          }
          return result;
        };
        origCb = currentCallback;
        currentCallback = currentContext = currentArgs = null;
        args.push(cb);
        result = apply.call(original, this, args);
        cb.cb = origCb;
        currentCallback = cb;
        return result;
      };
      conf.on("set", function(id) {
        if (!currentCallback) {
          conf.delete(id);
          return;
        }
        if (waiting[id]) {
          if (typeof waiting[id] === "function")
            waiting[id] = [waiting[id], currentCallback.cb];
          else
            waiting[id].push(currentCallback.cb);
        } else {
          waiting[id] = currentCallback.cb;
        }
        delete currentCallback.cb;
        currentCallback.id = id;
        currentCallback = null;
      });
      conf.on("delete", function(id) {
        var result;
        if (hasOwnProperty.call(waiting, id))
          return;
        if (!cache[id])
          return;
        result = cache[id];
        delete cache[id];
        conf.emit("deleteasync", id, slice.call(result.args, 1));
      });
      conf.on("clear", function() {
        var oldCache = cache;
        cache = create(null);
        conf.emit(
          "clearasync",
          objectMap(oldCache, function(data) {
            return slice.call(data.args, 1);
          })
        );
      });
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/is-callable.js
var require_is_callable = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/is-callable.js"(exports, module2) {
    "use strict";
    module2.exports = function(obj) {
      return typeof obj === "function";
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/validate-stringifiable.js
var require_validate_stringifiable = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/validate-stringifiable.js"(exports, module2) {
    "use strict";
    var isCallable = require_is_callable();
    module2.exports = function(stringifiable) {
      try {
        if (stringifiable && isCallable(stringifiable.toString))
          return stringifiable.toString();
        return String(stringifiable);
      } catch (e) {
        throw new TypeError("Passed argument cannot be stringifed");
      }
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/validate-stringifiable-value.js
var require_validate_stringifiable_value = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/validate-stringifiable-value.js"(exports, module2) {
    "use strict";
    var ensureValue = require_valid_value();
    var stringifiable = require_validate_stringifiable();
    module2.exports = function(value) {
      return stringifiable(ensureValue(value));
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/safe-to-string.js
var require_safe_to_string = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/safe-to-string.js"(exports, module2) {
    "use strict";
    var isCallable = require_is_callable();
    module2.exports = function(value) {
      try {
        if (value && isCallable(value.toString))
          return value.toString();
        return String(value);
      } catch (e) {
        return "<Non-coercible to string value>";
      }
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/to-short-string-representation.js
var require_to_short_string_representation = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/to-short-string-representation.js"(exports, module2) {
    "use strict";
    var safeToString = require_safe_to_string();
    var reNewLine = /[\n\r\u2028\u2029]/g;
    module2.exports = function(value) {
      var string = safeToString(value);
      if (string.length > 100)
        string = string.slice(0, 99) + "\u2026";
      string = string.replace(reNewLine, function(char) {
        return JSON.stringify(char).slice(1, -1);
      });
      return string;
    };
  }
});

// node_modules/.pnpm/is-promise@2.2.2/node_modules/is-promise/index.js
var require_is_promise = __commonJS({
  "node_modules/.pnpm/is-promise@2.2.2/node_modules/is-promise/index.js"(exports, module2) {
    module2.exports = isPromise;
    module2.exports.default = isPromise;
    function isPromise(obj) {
      return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
    }
  }
});

// node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/ext/promise.js
var require_promise = __commonJS({
  "node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/ext/promise.js"() {
    "use strict";
    var objectMap = require_map();
    var primitiveSet = require_primitive_set();
    var ensureString = require_validate_stringifiable_value();
    var toShortString = require_to_short_string_representation();
    var isPromise = require_is_promise();
    var nextTick = require_next_tick();
    var create = Object.create;
    var supportedModes = primitiveSet("then", "then:finally", "done", "done:finally");
    require_registered_extensions().promise = function(mode, conf) {
      var waiting = create(null), cache = create(null), promises = create(null);
      if (mode === true) {
        mode = null;
      } else {
        mode = ensureString(mode);
        if (!supportedModes[mode]) {
          throw new TypeError("'" + toShortString(mode) + "' is not valid promise mode");
        }
      }
      conf.on("set", function(id, ignore, promise) {
        var isFailed = false;
        if (!isPromise(promise)) {
          cache[id] = promise;
          conf.emit("setasync", id, 1);
          return;
        }
        waiting[id] = 1;
        promises[id] = promise;
        var onSuccess = function(result) {
          var count = waiting[id];
          if (isFailed) {
            throw new Error(
              "Memoizee error: Detected unordered then|done & finally resolution, which in turn makes proper detection of success/failure impossible (when in 'done:finally' mode)\nConsider to rely on 'then' or 'done' mode instead."
            );
          }
          if (!count)
            return;
          delete waiting[id];
          cache[id] = result;
          conf.emit("setasync", id, count);
        };
        var onFailure = function() {
          isFailed = true;
          if (!waiting[id])
            return;
          delete waiting[id];
          delete promises[id];
          conf.delete(id);
        };
        var resolvedMode = mode;
        if (!resolvedMode)
          resolvedMode = "then";
        if (resolvedMode === "then") {
          var nextTickFailure = function() {
            nextTick(onFailure);
          };
          promise = promise.then(function(result) {
            nextTick(onSuccess.bind(this, result));
          }, nextTickFailure);
          if (typeof promise.finally === "function") {
            promise.finally(nextTickFailure);
          }
        } else if (resolvedMode === "done") {
          if (typeof promise.done !== "function") {
            throw new Error(
              "Memoizee error: Retrieved promise does not implement 'done' in 'done' mode"
            );
          }
          promise.done(onSuccess, onFailure);
        } else if (resolvedMode === "done:finally") {
          if (typeof promise.done !== "function") {
            throw new Error(
              "Memoizee error: Retrieved promise does not implement 'done' in 'done:finally' mode"
            );
          }
          if (typeof promise.finally !== "function") {
            throw new Error(
              "Memoizee error: Retrieved promise does not implement 'finally' in 'done:finally' mode"
            );
          }
          promise.done(onSuccess);
          promise.finally(onFailure);
        }
      });
      conf.on("get", function(id, args, context) {
        var promise;
        if (waiting[id]) {
          ++waiting[id];
          return;
        }
        promise = promises[id];
        var emit = function() {
          conf.emit("getasync", id, args, context);
        };
        if (isPromise(promise)) {
          if (typeof promise.done === "function")
            promise.done(emit);
          else {
            promise.then(function() {
              nextTick(emit);
            });
          }
        } else {
          emit();
        }
      });
      conf.on("delete", function(id) {
        delete promises[id];
        if (waiting[id]) {
          delete waiting[id];
          return;
        }
        if (!hasOwnProperty.call(cache, id))
          return;
        var result = cache[id];
        delete cache[id];
        conf.emit("deleteasync", id, [result]);
      });
      conf.on("clear", function() {
        var oldCache = cache;
        cache = create(null);
        waiting = create(null);
        promises = create(null);
        conf.emit("clearasync", objectMap(oldCache, function(data) {
          return [data];
        }));
      });
    };
  }
});

// node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/ext/dispose.js
var require_dispose = __commonJS({
  "node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/ext/dispose.js"() {
    "use strict";
    var callable = require_valid_callable();
    var forEach = require_for_each();
    var extensions = require_registered_extensions();
    var apply = Function.prototype.apply;
    extensions.dispose = function(dispose, conf, options) {
      var del;
      callable(dispose);
      if (options.async && extensions.async || options.promise && extensions.promise) {
        conf.on("deleteasync", del = function(id, resultArray) {
          apply.call(dispose, null, resultArray);
        });
        conf.on("clearasync", function(cache) {
          forEach(cache, function(result, id) {
            del(id, result);
          });
        });
        return;
      }
      conf.on("delete", del = function(id, result) {
        dispose(result);
      });
      conf.on("clear", function(cache) {
        forEach(cache, function(result, id) {
          del(id, result);
        });
      });
    };
  }
});

// node_modules/.pnpm/timers-ext@0.1.7/node_modules/timers-ext/max-timeout.js
var require_max_timeout = __commonJS({
  "node_modules/.pnpm/timers-ext@0.1.7/node_modules/timers-ext/max-timeout.js"(exports, module2) {
    "use strict";
    module2.exports = 2147483647;
  }
});

// node_modules/.pnpm/timers-ext@0.1.7/node_modules/timers-ext/valid-timeout.js
var require_valid_timeout = __commonJS({
  "node_modules/.pnpm/timers-ext@0.1.7/node_modules/timers-ext/valid-timeout.js"(exports, module2) {
    "use strict";
    var toPosInt = require_to_pos_integer();
    var maxTimeout = require_max_timeout();
    module2.exports = function(value) {
      value = toPosInt(value);
      if (value > maxTimeout)
        throw new TypeError(value + " exceeds maximum possible timeout");
      return value;
    };
  }
});

// node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/ext/max-age.js
var require_max_age = __commonJS({
  "node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/ext/max-age.js"() {
    "use strict";
    var aFrom = require_from();
    var forEach = require_for_each();
    var nextTick = require_next_tick();
    var isPromise = require_is_promise();
    var timeout = require_valid_timeout();
    var extensions = require_registered_extensions();
    var noop = Function.prototype;
    var max = Math.max;
    var min = Math.min;
    var create = Object.create;
    extensions.maxAge = function(maxAge, conf, options) {
      var timeouts, postfix, preFetchAge, preFetchTimeouts;
      maxAge = timeout(maxAge);
      if (!maxAge)
        return;
      timeouts = create(null);
      postfix = options.async && extensions.async || options.promise && extensions.promise ? "async" : "";
      conf.on("set" + postfix, function(id) {
        timeouts[id] = setTimeout(function() {
          conf.delete(id);
        }, maxAge);
        if (typeof timeouts[id].unref === "function")
          timeouts[id].unref();
        if (!preFetchTimeouts)
          return;
        if (preFetchTimeouts[id]) {
          if (preFetchTimeouts[id] !== "nextTick")
            clearTimeout(preFetchTimeouts[id]);
        }
        preFetchTimeouts[id] = setTimeout(function() {
          delete preFetchTimeouts[id];
        }, preFetchAge);
        if (typeof preFetchTimeouts[id].unref === "function")
          preFetchTimeouts[id].unref();
      });
      conf.on("delete" + postfix, function(id) {
        clearTimeout(timeouts[id]);
        delete timeouts[id];
        if (!preFetchTimeouts)
          return;
        if (preFetchTimeouts[id] !== "nextTick")
          clearTimeout(preFetchTimeouts[id]);
        delete preFetchTimeouts[id];
      });
      if (options.preFetch) {
        if (options.preFetch === true || isNaN(options.preFetch)) {
          preFetchAge = 0.333;
        } else {
          preFetchAge = max(min(Number(options.preFetch), 1), 0);
        }
        if (preFetchAge) {
          preFetchTimeouts = {};
          preFetchAge = (1 - preFetchAge) * maxAge;
          conf.on("get" + postfix, function(id, args, context) {
            if (!preFetchTimeouts[id]) {
              preFetchTimeouts[id] = "nextTick";
              nextTick(function() {
                var result;
                if (preFetchTimeouts[id] !== "nextTick")
                  return;
                delete preFetchTimeouts[id];
                conf.delete(id);
                if (options.async) {
                  args = aFrom(args);
                  args.push(noop);
                }
                result = conf.memoized.apply(context, args);
                if (options.promise) {
                  if (isPromise(result)) {
                    if (typeof result.done === "function")
                      result.done(noop, noop);
                    else
                      result.then(noop, noop);
                  }
                }
              });
            }
          });
        }
      }
      conf.on("clear" + postfix, function() {
        forEach(timeouts, function(id) {
          clearTimeout(id);
        });
        timeouts = {};
        if (preFetchTimeouts) {
          forEach(preFetchTimeouts, function(id) {
            if (id !== "nextTick")
              clearTimeout(id);
          });
          preFetchTimeouts = {};
        }
      });
    };
  }
});

// node_modules/.pnpm/lru-queue@0.1.0/node_modules/lru-queue/index.js
var require_lru_queue = __commonJS({
  "node_modules/.pnpm/lru-queue@0.1.0/node_modules/lru-queue/index.js"(exports, module2) {
    "use strict";
    var toPosInt = require_to_pos_integer();
    var create = Object.create;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    module2.exports = function(limit) {
      var size = 0, base = 1, queue = create(null), map = create(null), index4 = 0, del;
      limit = toPosInt(limit);
      return {
        hit: function(id) {
          var oldIndex = map[id], nuIndex = ++index4;
          queue[nuIndex] = id;
          map[id] = nuIndex;
          if (!oldIndex) {
            ++size;
            if (size <= limit)
              return;
            id = queue[base];
            del(id);
            return id;
          }
          delete queue[oldIndex];
          if (base !== oldIndex)
            return;
          while (!hasOwnProperty2.call(queue, ++base))
            continue;
        },
        delete: del = function(id) {
          var oldIndex = map[id];
          if (!oldIndex)
            return;
          delete queue[oldIndex];
          delete map[id];
          --size;
          if (base !== oldIndex)
            return;
          if (!size) {
            index4 = 0;
            base = 1;
            return;
          }
          while (!hasOwnProperty2.call(queue, ++base))
            continue;
        },
        clear: function() {
          size = 0;
          base = 1;
          queue = create(null);
          map = create(null);
          index4 = 0;
        }
      };
    };
  }
});

// node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/ext/max.js
var require_max = __commonJS({
  "node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/ext/max.js"() {
    "use strict";
    var toPosInteger = require_to_pos_integer();
    var lruQueue = require_lru_queue();
    var extensions = require_registered_extensions();
    extensions.max = function(max, conf, options) {
      var postfix, queue, hit;
      max = toPosInteger(max);
      if (!max)
        return;
      queue = lruQueue(max);
      postfix = options.async && extensions.async || options.promise && extensions.promise ? "async" : "";
      conf.on("set" + postfix, hit = function(id) {
        id = queue.hit(id);
        if (id === void 0)
          return;
        conf.delete(id);
      });
      conf.on("get" + postfix, hit);
      conf.on("delete" + postfix, queue.delete);
      conf.on("clear" + postfix, queue.clear);
    };
  }
});

// node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/ext/ref-counter.js
var require_ref_counter = __commonJS({
  "node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/ext/ref-counter.js"() {
    "use strict";
    var d = require_d();
    var extensions = require_registered_extensions();
    var create = Object.create;
    var defineProperties = Object.defineProperties;
    extensions.refCounter = function(ignore, conf, options) {
      var cache, postfix;
      cache = create(null);
      postfix = options.async && extensions.async || options.promise && extensions.promise ? "async" : "";
      conf.on("set" + postfix, function(id, length) {
        cache[id] = length || 1;
      });
      conf.on("get" + postfix, function(id) {
        ++cache[id];
      });
      conf.on("delete" + postfix, function(id) {
        delete cache[id];
      });
      conf.on("clear" + postfix, function() {
        cache = {};
      });
      defineProperties(conf.memoized, {
        deleteRef: d(function() {
          var id = conf.get(arguments);
          if (id === null)
            return null;
          if (!cache[id])
            return null;
          if (!--cache[id]) {
            conf.delete(id);
            return true;
          }
          return false;
        }),
        getRefCount: d(function() {
          var id = conf.get(arguments);
          if (id === null)
            return 0;
          if (!cache[id])
            return 0;
          return cache[id];
        })
      });
    };
  }
});

// node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/index.js
var require_memoizee = __commonJS({
  "node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/index.js"(exports, module2) {
    "use strict";
    var normalizeOpts = require_normalize_options();
    var resolveLength = require_resolve_length();
    var plain = require_plain();
    module2.exports = function(fn) {
      var options = normalizeOpts(arguments[1]), length;
      if (!options.normalizer) {
        length = options.length = resolveLength(options.length, fn.length, options.async);
        if (length !== 0) {
          if (options.primitive) {
            if (length === false) {
              options.normalizer = require_primitive();
            } else if (length > 1) {
              options.normalizer = require_get_primitive_fixed()(length);
            }
          } else if (length === false)
            options.normalizer = require_get()();
          else if (length === 1)
            options.normalizer = require_get_1()();
          else
            options.normalizer = require_get_fixed()(length);
        }
      }
      if (options.async)
        require_async();
      if (options.promise)
        require_promise();
      if (options.dispose)
        require_dispose();
      if (options.maxAge)
        require_max_age();
      if (options.max)
        require_max();
      if (options.refCounter)
        require_ref_counter();
      return plain(fn, options);
    };
  }
});

// node_modules/.pnpm/type@1.2.0/node_modules/type/string/coerce.js
var require_coerce = __commonJS({
  "node_modules/.pnpm/type@1.2.0/node_modules/type/string/coerce.js"(exports, module2) {
    "use strict";
    var isValue = require_is();
    var isObject = require_is2();
    var objectToString = Object.prototype.toString;
    module2.exports = function(value) {
      if (!isValue(value))
        return null;
      if (isObject(value)) {
        var valueToString = value.toString;
        if (typeof valueToString !== "function")
          return null;
        if (valueToString === objectToString)
          return null;
      }
      try {
        return "" + value;
      } catch (error) {
        return null;
      }
    };
  }
});

// node_modules/.pnpm/type@1.2.0/node_modules/type/lib/safe-to-string.js
var require_safe_to_string2 = __commonJS({
  "node_modules/.pnpm/type@1.2.0/node_modules/type/lib/safe-to-string.js"(exports, module2) {
    "use strict";
    module2.exports = function(value) {
      try {
        return value.toString();
      } catch (error) {
        try {
          return String(value);
        } catch (error2) {
          return null;
        }
      }
    };
  }
});

// node_modules/.pnpm/type@1.2.0/node_modules/type/lib/to-short-string.js
var require_to_short_string = __commonJS({
  "node_modules/.pnpm/type@1.2.0/node_modules/type/lib/to-short-string.js"(exports, module2) {
    "use strict";
    var safeToString = require_safe_to_string2();
    var reNewLine = /[\n\r\u2028\u2029]/g;
    module2.exports = function(value) {
      var string = safeToString(value);
      if (string === null)
        return "<Non-coercible to string value>";
      if (string.length > 100)
        string = string.slice(0, 99) + "\u2026";
      string = string.replace(reNewLine, function(char) {
        switch (char) {
          case "\n":
            return "\\n";
          case "\r":
            return "\\r";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw new Error("Unexpected character");
        }
      });
      return string;
    };
  }
});

// node_modules/.pnpm/type@1.2.0/node_modules/type/lib/resolve-exception.js
var require_resolve_exception = __commonJS({
  "node_modules/.pnpm/type@1.2.0/node_modules/type/lib/resolve-exception.js"(exports, module2) {
    "use strict";
    var isValue = require_is();
    var isObject = require_is2();
    var stringCoerce = require_coerce();
    var toShortString = require_to_short_string();
    var resolveMessage = function(message, value) {
      return message.replace("%v", toShortString(value));
    };
    module2.exports = function(value, defaultMessage, inputOptions) {
      if (!isObject(inputOptions))
        throw new TypeError(resolveMessage(defaultMessage, value));
      if (!isValue(value)) {
        if ("default" in inputOptions)
          return inputOptions["default"];
        if (inputOptions.isOptional)
          return null;
      }
      var errorMessage = stringCoerce(inputOptions.errorMessage);
      if (!isValue(errorMessage))
        errorMessage = defaultMessage;
      throw new TypeError(resolveMessage(errorMessage, value));
    };
  }
});

// node_modules/.pnpm/type@1.2.0/node_modules/type/value/ensure.js
var require_ensure = __commonJS({
  "node_modules/.pnpm/type@1.2.0/node_modules/type/value/ensure.js"(exports, module2) {
    "use strict";
    var resolveException = require_resolve_exception();
    var is = require_is();
    module2.exports = function(value) {
      if (is(value))
        return value;
      return resolveException(value, "Cannot use %v", arguments[1]);
    };
  }
});

// node_modules/.pnpm/d@1.0.1/node_modules/d/lazy.js
var require_lazy = __commonJS({
  "node_modules/.pnpm/d@1.0.1/node_modules/d/lazy.js"(exports, module2) {
    "use strict";
    var isPlainFunction = require_is5();
    var ensureValue = require_ensure();
    var isValue = require_is();
    var map = require_map();
    var contains = require_contains();
    var call = Function.prototype.call;
    var defineProperty = Object.defineProperty;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var cacheDesc = { configurable: false, enumerable: false, writable: false, value: null };
    var define2;
    define2 = function(name, options) {
      var value, dgs, cacheName, desc, writable = false, resolvable, flat;
      options = Object(ensureValue(options));
      cacheName = options.cacheName;
      flat = options.flat;
      if (!isValue(cacheName))
        cacheName = name;
      delete options.cacheName;
      value = options.value;
      resolvable = isPlainFunction(value);
      delete options.value;
      dgs = { configurable: Boolean(options.configurable), enumerable: Boolean(options.enumerable) };
      if (name !== cacheName) {
        dgs.get = function() {
          if (hasOwnProperty2.call(this, cacheName))
            return this[cacheName];
          cacheDesc.value = resolvable ? call.call(value, this, options) : value;
          cacheDesc.writable = writable;
          defineProperty(this, cacheName, cacheDesc);
          cacheDesc.value = null;
          if (desc)
            defineProperty(this, name, desc);
          return this[cacheName];
        };
      } else if (!flat) {
        dgs.get = function self2() {
          var ownDesc;
          if (hasOwnProperty2.call(this, name)) {
            ownDesc = getOwnPropertyDescriptor(this, name);
            if (ownDesc) {
              if (ownDesc.hasOwnProperty("value"))
                return ownDesc.value;
              if (typeof ownDesc.get === "function" && ownDesc.get !== self2) {
                return ownDesc.get.call(this);
              }
              return value;
            }
          }
          desc.value = resolvable ? call.call(value, this, options) : value;
          defineProperty(this, name, desc);
          desc.value = null;
          return this[name];
        };
      } else {
        dgs.get = function self2() {
          var base = this, ownDesc;
          if (hasOwnProperty2.call(this, name)) {
            ownDesc = getOwnPropertyDescriptor(this, name);
            if (ownDesc.hasOwnProperty("value"))
              return ownDesc.value;
            if (typeof ownDesc.get === "function" && ownDesc.get !== self2) {
              return ownDesc.get.call(this);
            }
          }
          while (!hasOwnProperty2.call(base, name))
            base = getPrototypeOf(base);
          desc.value = resolvable ? call.call(value, base, options) : value;
          defineProperty(base, name, desc);
          desc.value = null;
          return base[name];
        };
      }
      dgs.set = function(value2) {
        if (hasOwnProperty2.call(this, name)) {
          throw new TypeError("Cannot assign to lazy defined '" + name + "' property of " + this);
        }
        dgs.get.call(this);
        this[cacheName] = value2;
      };
      if (options.desc) {
        desc = {
          configurable: contains.call(options.desc, "c"),
          enumerable: contains.call(options.desc, "e")
        };
        if (cacheName === name) {
          desc.writable = contains.call(options.desc, "w");
          desc.value = null;
        } else {
          writable = contains.call(options.desc, "w");
          desc.get = dgs.get;
          desc.set = dgs.set;
        }
        delete options.desc;
      } else if (cacheName === name) {
        desc = {
          configurable: Boolean(options.configurable),
          enumerable: Boolean(options.enumerable),
          writable: Boolean(options.writable),
          value: null
        };
      }
      delete options.configurable;
      delete options.enumerable;
      delete options.writable;
      return dgs;
    };
    module2.exports = function(props) {
      return map(props, function(desc, name) {
        return define2(name, desc);
      });
    };
  }
});

// node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/lib/methods.js
var require_methods = __commonJS({
  "node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/lib/methods.js"(exports, module2) {
    "use strict";
    var forEach = require_for_each();
    var normalizeOpts = require_normalize_options();
    var callable = require_valid_callable();
    var lazy = require_lazy();
    var resolveLength = require_resolve_length();
    var extensions = require_registered_extensions();
    module2.exports = function(memoize) {
      return function(props) {
        forEach(props, function(desc) {
          var fn = callable(desc.value), length;
          desc.value = function(options) {
            if (options.getNormalizer) {
              options = normalizeOpts(options);
              if (length === void 0) {
                length = resolveLength(
                  options.length,
                  fn.length,
                  options.async && extensions.async
                );
              }
              options.normalizer = options.getNormalizer(length);
              delete options.getNormalizer;
            }
            return memoize(fn.bind(this), options);
          };
        });
        return lazy(props);
      };
    };
  }
});

// node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/methods.js
var require_methods2 = __commonJS({
  "node_modules/.pnpm/memoizee@0.4.15/node_modules/memoizee/methods.js"(exports, module2) {
    "use strict";
    module2.exports = require_methods()(require_memoizee());
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/first-key.js
var require_first_key = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/first-key.js"(exports, module2) {
    "use strict";
    var value = require_valid_value();
    var objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;
    module2.exports = function(obj) {
      var i;
      value(obj);
      for (i in obj) {
        if (objPropertyIsEnumerable.call(obj, i))
          return i;
      }
      return null;
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/array/#/for-each-right.js
var require_for_each_right = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/array/#/for-each-right.js"(exports, module2) {
    "use strict";
    var toPosInt = require_to_pos_integer();
    var callable = require_valid_callable();
    var value = require_valid_value();
    var objHasOwnProperty = Object.prototype.hasOwnProperty;
    var call = Function.prototype.call;
    module2.exports = function(cb) {
      var i, self2, thisArg;
      self2 = Object(value(this));
      callable(cb);
      thisArg = arguments[1];
      for (i = toPosInt(self2.length) - 1; i >= 0; --i) {
        if (objHasOwnProperty.call(self2, i))
          call.call(cb, thisArg, self2[i], i, self2);
      }
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/array/#/uniq.js
var require_uniq = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/array/#/uniq.js"(exports, module2) {
    "use strict";
    var indexOf = require_e_index_of();
    var filter = Array.prototype.filter;
    var isFirst;
    isFirst = function(value, index4) {
      return indexOf.call(this, value) === index4;
    };
    module2.exports = function() {
      return filter.call(this, isFirst, this);
    };
  }
});

// node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/lib/sgr.js
var require_sgr = __commonJS({
  "node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/lib/sgr.js"(exports, module2) {
    "use strict";
    var assign = require_assign();
    var includes = require_contains();
    var forOwn = require_for_each();
    var onlyKey = require_first_key();
    var forEachRight = require_for_each_right();
    var uniq = require_uniq();
    var CSI = "\x1B[";
    var sgr = function(code) {
      return CSI + code + "m";
    };
    sgr.CSI = CSI;
    var mods = assign(
      {
        // Style
        bold: { _bold: [1, 22] },
        italic: { _italic: [3, 23] },
        underline: { _underline: [4, 24] },
        blink: { _blink: [5, 25] },
        inverse: { _inverse: [7, 27] },
        strike: { _strike: [9, 29] }
        // Color
      },
      ["black", "red", "green", "yellow", "blue", "magenta", "cyan", "white"].reduce(function(obj, color, index4) {
        obj[color] = { _fg: [30 + index4, 39] };
        obj[color + "Bright"] = { _fg: [90 + index4, 39] };
        obj["bg" + color[0].toUpperCase() + color.slice(1)] = { _bg: [40 + index4, 49] };
        obj["bg" + color[0].toUpperCase() + color.slice(1) + "Bright"] = { _bg: [100 + index4, 49] };
        return obj;
      }, {})
    );
    sgr.mods = mods;
    sgr.openers = {};
    sgr.closers = {};
    forOwn(mods, function(mod) {
      var modPair = mod[onlyKey(mod)];
      sgr.openers[modPair[0]] = modPair;
      sgr.closers[modPair[1]] = modPair;
    });
    sgr.openStyle = function(openedMods, code) {
      openedMods.push(sgr.openers[code]);
    };
    sgr.closeStyle = function(openedMods, code) {
      forEachRight.call(openedMods, function(modPair, index4) {
        if (modPair[1] === code) {
          openedMods.splice(index4, 1);
        }
      });
    };
    sgr.prepend = function(currentMods) {
      return currentMods.map(function(modPair) {
        return sgr(modPair[0]);
      });
    };
    sgr.complete = function(openedMods, closerCodes) {
      closerCodes.forEach(function(code) {
        sgr.closeStyle(openedMods, code);
      });
      openedMods = openedMods.reverse();
      openedMods = openedMods.map(function(modPair) {
        return modPair[1];
      });
      openedMods = uniq.call(openedMods);
      return openedMods.map(sgr);
    };
    var hasCSI = function(str) {
      return includes.call(str, CSI);
    };
    sgr.hasCSI = hasCSI;
    var extractCode = function(csi) {
      var code = csi.slice(2, -1);
      code = Number(code);
      return code;
    };
    sgr.extractCode = extractCode;
    module2.exports = sgr;
  }
});

// node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/lib/supports-color.js
var require_supports_color = __commonJS({
  "node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/lib/supports-color.js"(exports, module2) {
    "use strict";
    var state = null;
    var enableColor = function() {
      state = true;
    };
    var disableColor = function() {
      state = false;
    };
    var autoDetectSupport = function() {
      state = null;
    };
    var isColorSupported = function() {
      return state === null ? !process.env.NO_COLOR : state;
    };
    module2.exports = {
      enableColor,
      disableColor,
      autoDetectSupport,
      isColorSupported
    };
  }
});

// node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/lib/xterm-colors.js
var require_xterm_colors = __commonJS({
  "node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/lib/xterm-colors.js"(exports, module2) {
    "use strict";
    module2.exports = [
      "000000",
      "800000",
      "008000",
      "808000",
      "000080",
      "800080",
      "008080",
      "c0c0c0",
      "808080",
      "ff0000",
      "00ff00",
      "ffff00",
      "0000ff",
      "ff00ff",
      "00ffff",
      "ffffff",
      "000000",
      "00005f",
      "000087",
      "0000af",
      "0000d7",
      "0000ff",
      "005f00",
      "005f5f",
      "005f87",
      "005faf",
      "005fd7",
      "005fff",
      "008700",
      "00875f",
      "008787",
      "0087af",
      "0087d7",
      "0087ff",
      "00af00",
      "00af5f",
      "00af87",
      "00afaf",
      "00afd7",
      "00afff",
      "00d700",
      "00d75f",
      "00d787",
      "00d7af",
      "00d7d7",
      "00d7ff",
      "00ff00",
      "00ff5f",
      "00ff87",
      "00ffaf",
      "00ffd7",
      "00ffff",
      "5f0000",
      "5f005f",
      "5f0087",
      "5f00af",
      "5f00d7",
      "5f00ff",
      "5f5f00",
      "5f5f5f",
      "5f5f87",
      "5f5faf",
      "5f5fd7",
      "5f5fff",
      "5f8700",
      "5f875f",
      "5f8787",
      "5f87af",
      "5f87d7",
      "5f87ff",
      "5faf00",
      "5faf5f",
      "5faf87",
      "5fafaf",
      "5fafd7",
      "5fafff",
      "5fd700",
      "5fd75f",
      "5fd787",
      "5fd7af",
      "5fd7d7",
      "5fd7ff",
      "5fff00",
      "5fff5f",
      "5fff87",
      "5fffaf",
      "5fffd7",
      "5fffff",
      "870000",
      "87005f",
      "870087",
      "8700af",
      "8700d7",
      "8700ff",
      "875f00",
      "875f5f",
      "875f87",
      "875faf",
      "875fd7",
      "875fff",
      "878700",
      "87875f",
      "878787",
      "8787af",
      "8787d7",
      "8787ff",
      "87af00",
      "87af5f",
      "87af87",
      "87afaf",
      "87afd7",
      "87afff",
      "87d700",
      "87d75f",
      "87d787",
      "87d7af",
      "87d7d7",
      "87d7ff",
      "87ff00",
      "87ff5f",
      "87ff87",
      "87ffaf",
      "87ffd7",
      "87ffff",
      "af0000",
      "af005f",
      "af0087",
      "af00af",
      "af00d7",
      "af00ff",
      "af5f00",
      "af5f5f",
      "af5f87",
      "af5faf",
      "af5fd7",
      "af5fff",
      "af8700",
      "af875f",
      "af8787",
      "af87af",
      "af87d7",
      "af87ff",
      "afaf00",
      "afaf5f",
      "afaf87",
      "afafaf",
      "afafd7",
      "afafff",
      "afd700",
      "afd75f",
      "afd787",
      "afd7af",
      "afd7d7",
      "afd7ff",
      "afff00",
      "afff5f",
      "afff87",
      "afffaf",
      "afffd7",
      "afffff",
      "d70000",
      "d7005f",
      "d70087",
      "d700af",
      "d700d7",
      "d700ff",
      "d75f00",
      "d75f5f",
      "d75f87",
      "d75faf",
      "d75fd7",
      "d75fff",
      "d78700",
      "d7875f",
      "d78787",
      "d787af",
      "d787d7",
      "d787ff",
      "d7af00",
      "d7af5f",
      "d7af87",
      "d7afaf",
      "d7afd7",
      "d7afff",
      "d7d700",
      "d7d75f",
      "d7d787",
      "d7d7af",
      "d7d7d7",
      "d7d7ff",
      "d7ff00",
      "d7ff5f",
      "d7ff87",
      "d7ffaf",
      "d7ffd7",
      "d7ffff",
      "ff0000",
      "ff005f",
      "ff0087",
      "ff00af",
      "ff00d7",
      "ff00ff",
      "ff5f00",
      "ff5f5f",
      "ff5f87",
      "ff5faf",
      "ff5fd7",
      "ff5fff",
      "ff8700",
      "ff875f",
      "ff8787",
      "ff87af",
      "ff87d7",
      "ff87ff",
      "ffaf00",
      "ffaf5f",
      "ffaf87",
      "ffafaf",
      "ffafd7",
      "ffafff",
      "ffd700",
      "ffd75f",
      "ffd787",
      "ffd7af",
      "ffd7d7",
      "ffd7ff",
      "ffff00",
      "ffff5f",
      "ffff87",
      "ffffaf",
      "ffffd7",
      "ffffff",
      "080808",
      "121212",
      "1c1c1c",
      "262626",
      "303030",
      "3a3a3a",
      "444444",
      "4e4e4e",
      "585858",
      "626262",
      "6c6c6c",
      "767676",
      "808080",
      "8a8a8a",
      "949494",
      "9e9e9e",
      "a8a8a8",
      "b2b2b2",
      "bcbcbc",
      "c6c6c6",
      "d0d0d0",
      "dadada",
      "e4e4e4",
      "eeeeee"
    ];
  }
});

// node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/lib/xterm-match.js
var require_xterm_match = __commonJS({
  "node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/lib/xterm-match.js"(exports, module2) {
    "use strict";
    var push = Array.prototype.push;
    var reduce = Array.prototype.reduce;
    var abs = Math.abs;
    var colors;
    var match;
    var result;
    var i;
    colors = require_xterm_colors().map(function(color) {
      return {
        r: parseInt(color.slice(0, 2), 16),
        g: parseInt(color.slice(2, 4), 16),
        b: parseInt(color.slice(4), 16)
      };
    });
    match = colors.slice(0, 16);
    module2.exports = result = [];
    i = 0;
    while (i < 8) {
      result.push(30 + i++);
    }
    i = 0;
    while (i < 8) {
      result.push(90 + i++);
    }
    push.apply(
      result,
      colors.slice(16).map(function(data) {
        var index4, diff2 = Infinity;
        match.every(function(innerMatch, currentIndex) {
          var ndiff = reduce.call(
            "rgb",
            function(currentDiff, channel) {
              currentDiff += abs(innerMatch[channel] - data[channel]);
              return currentDiff;
            },
            0
          );
          if (ndiff < diff2) {
            index4 = currentIndex;
            diff2 = ndiff;
          }
          return ndiff;
        });
        return result[index4];
      })
    );
  }
});

// node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/bare.js
var require_bare = __commonJS({
  "node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/bare.js"(exports, module2) {
    "use strict";
    var d = require_d();
    var assign = require_assign();
    var forEach = require_for_each();
    var map = require_map();
    var primitiveSet = require_primitive_set();
    var setPrototypeOf = require_set_prototype_of();
    var memoize = require_memoizee();
    var memoizeMethods = require_methods2();
    var sgr = require_sgr();
    var supportsColor2 = require_supports_color();
    var mods = sgr.mods;
    var join2 = Array.prototype.join;
    var defineProperty = Object.defineProperty;
    var max = Math.max;
    var min = Math.min;
    var variantModes = primitiveSet("_fg", "_bg");
    var xtermMatch = process.platform === "win32" ? require_xterm_match() : null;
    var getFn;
    var memoized = memoize(function(scope, mod) {
      return defineProperty(getFn(), "_cliColorData", d(assign({}, scope._cliColorData, mod)));
    });
    var proto2 = Object.create(
      Function.prototype,
      assign(
        map(mods, function(mod) {
          return d.gs(function() {
            return memoized(this, mod);
          });
        }),
        memoizeMethods({
          // xterm (255) color
          xterm: d(function(code) {
            code = isNaN(code) ? 255 : min(max(code, 0), 255);
            return defineProperty(
              getFn(),
              "_cliColorData",
              d(
                assign({}, this._cliColorData, {
                  _fg: [xtermMatch ? xtermMatch[code] : "38;5;" + code, 39]
                })
              )
            );
          }),
          bgXterm: d(function(code) {
            code = isNaN(code) ? 255 : min(max(code, 0), 255);
            return defineProperty(
              getFn(),
              "_cliColorData",
              d(
                assign({}, this._cliColorData, {
                  _bg: [xtermMatch ? xtermMatch[code] + 10 : "48;5;" + code, 49]
                })
              )
            );
          })
        })
      )
    );
    var getEndRe = memoize(function(code) {
      return new RegExp("\x1B\\[" + code + "m", "g");
    }, {
      primitive: true
    });
    getFn = function() {
      return setPrototypeOf(
        function self2() {
          var start = "", end = "", msg = join2.call(arguments, " "), conf = self2._cliColorData, hasAnsi = sgr.hasCSI(msg);
          forEach(
            conf,
            function(mod, key) {
              end = sgr(mod[1]) + end;
              start += sgr(mod[0]);
              if (hasAnsi) {
                msg = msg.replace(getEndRe(mod[1]), variantModes[key] ? sgr(mod[0]) : "");
              }
            },
            null,
            true
          );
          if (!supportsColor2.isColorSupported())
            return msg;
          return start + msg + end;
        },
        proto2
      );
    };
    module2.exports = Object.defineProperties(getFn(), {
      xtermSupported: d(!xtermMatch),
      _cliColorData: d("", {})
    });
  }
});

// node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/window-size.js
var require_window_size = __commonJS({
  "node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/window-size.js"(exports) {
    "use strict";
    var d = require_d();
    Object.defineProperties(exports, {
      width: d.gs("ce", function() {
        return process.stdout.columns || 0;
      }),
      height: d.gs("ce", function() {
        return process.stdout.rows || 0;
      })
    });
  }
});

// node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/erase.js
var require_erase = __commonJS({
  "node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/erase.js"(exports, module2) {
    "use strict";
    module2.exports = {
      screen: "\x1B[2J",
      screenLeft: "\x1B[1J",
      screenRight: "\x1B[J",
      line: "\x1B[2K",
      lineLeft: "\x1B[1K",
      lineRight: "\x1B[K"
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/math/trunc/is-implemented.js
var require_is_implemented10 = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/math/trunc/is-implemented.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      var trunc = Math.trunc;
      if (typeof trunc !== "function")
        return false;
      return trunc(13.67) === 13 && trunc(-13.67) === -13;
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/math/trunc/shim.js
var require_shim8 = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/math/trunc/shim.js"(exports, module2) {
    "use strict";
    var floor = Math.floor;
    module2.exports = function(value) {
      if (isNaN(value))
        return NaN;
      value = Number(value);
      if (value === 0)
        return value;
      if (value === Infinity)
        return Infinity;
      if (value === -Infinity)
        return -Infinity;
      if (value > 0)
        return floor(value);
      return -floor(-value);
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/math/trunc/index.js
var require_trunc = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/math/trunc/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_is_implemented10()() ? Math.trunc : require_shim8();
  }
});

// node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/move.js
var require_move = __commonJS({
  "node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/move.js"(exports, module2) {
    "use strict";
    var d = require_d();
    var trunc = require_trunc();
    var up;
    var down;
    var right;
    var left;
    var abs = Math.abs;
    var floor = Math.floor;
    var max = Math.max;
    var getMove = function(control) {
      return function(num) {
        num = isNaN(num) ? 0 : max(floor(num), 0);
        return num ? "\x1B[" + num + control : "";
      };
    };
    module2.exports = Object.defineProperties(
      function(x, y) {
        x = isNaN(x) ? 0 : floor(x);
        y = isNaN(y) ? 0 : floor(y);
        return (x > 0 ? right(x) : left(-x)) + (y > 0 ? down(y) : up(-y));
      },
      {
        up: d(up = getMove("A")),
        down: d(down = getMove("B")),
        right: d(right = getMove("C")),
        left: d(left = getMove("D")),
        to: d(function(x, y) {
          x = isNaN(x) ? 1 : max(floor(x), 0) + 1;
          y = isNaN(y) ? 1 : max(floor(y), 0) + 1;
          return "\x1B[" + y + ";" + x + "H";
        }),
        lines: d(function(n) {
          var dir;
          n = trunc(n) || 0;
          dir = n >= 0 ? "B" : "A";
          n = floor(abs(n));
          return "\x1B[" + n + dir + "\x1B[1G";
        }),
        top: d("\x1B[5000F"),
        bottom: d("\x1B[5000B"),
        lineBegin: d("\x1B[5000D"),
        lineEnd: d("\x1B[5000C")
      }
    );
  }
});

// node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/beep.js
var require_beep = __commonJS({
  "node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/beep.js"(exports, module2) {
    "use strict";
    module2.exports = "\x07";
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/array/generate.js
var require_generate = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/array/generate.js"(exports, module2) {
    "use strict";
    var toPosInt = require_to_pos_integer();
    var value = require_valid_value();
    var slice = Array.prototype.slice;
    module2.exports = function(length) {
      var arr, currentLength;
      length = toPosInt(value(length));
      if (length === 0)
        return [];
      arr = arguments.length < 2 ? [void 0] : slice.call(arguments, 1, 1 + length);
      while ((currentLength = arr.length) < length) {
        arr = arr.concat(arr.slice(0, length - currentLength));
      }
      return arr;
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/is-array-like.js
var require_is_array_like = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/is-array-like.js"(exports, module2) {
    "use strict";
    var isFunction = require_is_function();
    var isObject = require_is_object();
    var isValue = require_is_value();
    module2.exports = function(value) {
      return isValue(value) && typeof value.length === "number" && // Just checking ((typeof x === 'object') && (typeof x !== 'function'))
      // won't work right for some cases, e.g.:
      // type of instance of NodeList in Safari is a 'function'
      (isObject(value) && !isFunction(value) || typeof value === "string") || false;
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/iterable/is.js
var require_is6 = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/iterable/is.js"(exports, module2) {
    "use strict";
    var iteratorSymbol = require_es6_symbol().iterator;
    var isValue = require_is_value();
    var isArrayLike = require_is_array_like();
    module2.exports = function(value) {
      if (!isValue(value))
        return false;
      if (typeof value[iteratorSymbol] === "function")
        return true;
      return isArrayLike(value);
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/iterable/validate-object.js
var require_validate_object = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/iterable/validate-object.js"(exports, module2) {
    "use strict";
    var isObject = require_is_object();
    var is = require_is6();
    module2.exports = function(value) {
      if (is(value) && isObject(value))
        return value;
      throw new TypeError(value + " is not an iterable or array-like object");
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/string/#/repeat/is-implemented.js
var require_is_implemented11 = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/string/#/repeat/is-implemented.js"(exports, module2) {
    "use strict";
    var str = "foo";
    module2.exports = function() {
      if (typeof str.repeat !== "function")
        return false;
      return str.repeat(2) === "foofoo";
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/string/#/repeat/shim.js
var require_shim9 = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/string/#/repeat/shim.js"(exports, module2) {
    "use strict";
    var value = require_valid_value();
    var toInteger = require_to_integer();
    module2.exports = function(count) {
      var str = String(value(this)), result;
      count = toInteger(count);
      if (count < 0)
        throw new RangeError("Count must be >= 0");
      if (!isFinite(count))
        throw new RangeError("Count must be < \u221E");
      result = "";
      while (count) {
        if (count % 2)
          result += str;
        if (count > 1)
          str += str;
        count >>= 1;
      }
      return result;
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/string/#/repeat/index.js
var require_repeat = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/string/#/repeat/index.js"(exports, module2) {
    "use strict";
    module2.exports = require_is_implemented11()() ? String.prototype.repeat : require_shim9();
  }
});

// node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/regex-ansi.js
var require_regex_ansi = __commonJS({
  "node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/regex-ansi.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      return new RegExp(
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))",
        "g"
      );
    };
  }
});

// node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/strip.js
var require_strip = __commonJS({
  "node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/strip.js"(exports, module2) {
    "use strict";
    var stringifiable = require_validate_stringifiable();
    var r = require_regex_ansi()();
    module2.exports = function(str) {
      return stringifiable(str).replace(r, "");
    };
  }
});

// node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/get-stripped-length.js
var require_get_stripped_length = __commonJS({
  "node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/get-stripped-length.js"(exports, module2) {
    "use strict";
    var strip = require_strip();
    module2.exports = function(str) {
      return strip(str).length;
    };
  }
});

// node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/columns.js
var require_columns = __commonJS({
  "node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/columns.js"(exports, module2) {
    "use strict";
    var generate = require_generate();
    var from = require_from();
    var iterable = require_validate_object();
    var isValue = require_is_value();
    var stringifiable = require_validate_stringifiable();
    var repeat = require_repeat();
    var getStrippedLength = require_get_stripped_length();
    var push = Array.prototype.push;
    module2.exports = function(inputRows) {
      var options = Object(arguments[1]), colsMeta = [], colsOptions = options.columns || [], rows = [];
      from(iterable(inputRows), function(row) {
        var rowRows = [[]];
        from(iterable(row), function(cellStr, columnIndex) {
          var cellRows = stringifiable(cellStr).split("\n");
          while (cellRows.length > rowRows.length)
            rowRows.push(generate(columnIndex, ""));
          cellRows.forEach(function(cellRow, rowRowIndex) {
            rowRows[rowRowIndex][columnIndex] = cellRow;
          });
        });
        push.apply(rows, rowRows);
      });
      return rows.map(function(row) {
        return from(iterable(row), function(str, index4) {
          var col = colsMeta[index4], strLength;
          if (!col)
            col = colsMeta[index4] = { width: 0 };
          str = stringifiable(str);
          strLength = getStrippedLength(str);
          if (strLength > col.width)
            col.width = strLength;
          return { str, length: strLength };
        });
      }).map(function(row) {
        return row.map(function(item, index4) {
          var pad, align = "left", colOptions = colsOptions && colsOptions[index4];
          align = colOptions && colOptions.align === "right" ? "right" : "left";
          pad = repeat.call(" ", colsMeta[index4].width - item.length);
          if (align === "left")
            return item.str + pad;
          return pad + item.str;
        }).join(isValue(options.sep) ? options.sep : " | ");
      }).join("\n") + "\n";
    };
  }
});

// node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/slice.js
var require_slice = __commonJS({
  "node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/slice.js"(exports, module2) {
    "use strict";
    var reAnsi = require_regex_ansi();
    var stringifiable = require_validate_stringifiable_value();
    var length = require_get_stripped_length();
    var sgr = require_sgr();
    var max = Math.max;
    var Token = function(token) {
      this.token = token;
    };
    var tokenize = function(str) {
      var match = reAnsi().exec(str);
      if (!match) {
        return [str];
      }
      var index4 = match.index, head, prehead, tail;
      if (index4 === 0) {
        head = match[0];
        tail = str.slice(head.length);
        return [new Token(head)].concat(tokenize(tail));
      }
      prehead = str.slice(0, index4);
      head = match[0];
      tail = str.slice(index4 + head.length);
      return [prehead, new Token(head)].concat(tokenize(tail));
    };
    var isChunkInSlice = function(chunk, index4, begin, end) {
      var endIndex = chunk.length + index4;
      if (begin > endIndex)
        return false;
      if (end < index4)
        return false;
      return true;
    };
    var sliceSeq = function(seq, begin, end) {
      var sliced = seq.reduce(
        function(state, chunk) {
          var index4 = state.index;
          if (chunk instanceof Token) {
            var code = sgr.extractCode(chunk.token);
            if (index4 <= begin) {
              if (code in sgr.openers) {
                sgr.openStyle(state.preOpeners, code);
              }
              if (code in sgr.closers) {
                sgr.closeStyle(state.preOpeners, code);
              }
            } else if (index4 < end) {
              if (code in sgr.openers) {
                sgr.openStyle(state.inOpeners, code);
                state.seq.push(chunk);
              } else if (code in sgr.closers) {
                state.inClosers.push(code);
                state.seq.push(chunk);
              }
            }
          } else {
            var nextChunk = "";
            if (isChunkInSlice(chunk, index4, begin, end)) {
              var relBegin = Math.max(begin - index4, 0), relEnd = Math.min(end - index4, chunk.length);
              nextChunk = chunk.slice(relBegin, relEnd);
            }
            state.seq.push(nextChunk);
            state.index = index4 + chunk.length;
          }
          return state;
        },
        {
          index: 0,
          seq: [],
          // preOpeners -> [ mod ]
          // preOpeners must be prepended to the slice if they wasn't closed til the end of it
          // preOpeners must be closed if they wasn't closed til the end of the slice
          preOpeners: [],
          // inOpeners  -> [ mod ]
          // inOpeners already in the slice and must not be prepended to the slice
          // inOpeners must be closed if they wasn't closed til the end of the slice
          inOpeners: [],
          // opener CSI inside slice
          // inClosers -> [ code ]
          // closer CSIs for determining which pre/in-Openers must be closed
          inClosers: []
        }
      );
      sliced.seq = [].concat(
        sgr.prepend(sliced.preOpeners),
        sliced.seq,
        sgr.complete([].concat(sliced.preOpeners, sliced.inOpeners), sliced.inClosers)
      );
      return sliced.seq;
    };
    module2.exports = function(str) {
      var seq, begin = Number(arguments[1]), end = Number(arguments[2]), len;
      str = stringifiable(str);
      len = length(str);
      if (isNaN(begin)) {
        begin = 0;
      }
      if (isNaN(end)) {
        end = len;
      }
      if (begin < 0) {
        begin = max(len + begin, 0);
      }
      if (end < 0) {
        end = max(len + end, 0);
      }
      seq = tokenize(str);
      seq = sliceSeq(seq, begin, end);
      return seq.map(function(chunk) {
        if (chunk instanceof Token) {
          return chunk.token;
        }
        return chunk;
      }).join("");
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/function/#/compose.js
var require_compose = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/function/#/compose.js"(exports, module2) {
    "use strict";
    var isValue = require_is_value();
    var callable = require_valid_callable();
    var aFrom = require_from();
    var apply = Function.prototype.apply;
    var call = Function.prototype.call;
    var callFn = function(arg, fn) {
      return call.call(fn, this, arg);
    };
    module2.exports = function(fnIgnored) {
      var fns, first;
      var args = aFrom(arguments);
      fns = isValue(this) ? [this].concat(args) : args;
      fns.forEach(callable);
      fns = fns.reverse();
      first = fns[0];
      fns = fns.slice(1);
      return function(argIgnored) {
        return fns.reduce(callFn, apply.call(first, this, arguments));
      };
    };
  }
});

// node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/throbber.js
var require_throbber = __commonJS({
  "node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/throbber.js"(exports, module2) {
    "use strict";
    var compose = require_compose();
    var callable = require_valid_callable();
    var d = require_d();
    var validTimeout = require_valid_timeout();
    var chars = "-\\|/";
    var l = chars.length;
    var ThrobberIterator;
    ThrobberIterator = function() {
    };
    Object.defineProperties(ThrobberIterator.prototype, {
      index: d(-1),
      running: d(false),
      next: d(function() {
        var str = this.running ? "\b" : "";
        if (!this.running)
          this.running = true;
        return str + chars[this.index = (this.index + 1) % l];
      }),
      reset: d(function() {
        if (!this.running)
          return "";
        this.index = -1;
        this.running = false;
        return "\b";
      })
    });
    module2.exports = exports = function(write, interval) {
      var format = arguments[2], token, iterator = new ThrobberIterator();
      callable(write);
      interval = validTimeout(interval);
      if (format !== void 0)
        write = compose.call(write, callable(format));
      return {
        start: function() {
          if (token)
            return;
          token = setInterval(function() {
            write(iterator.next());
          }, interval);
        },
        restart: function() {
          this.stop();
          this.start();
        },
        stop: function() {
          if (!token)
            return;
          clearInterval(token);
          token = null;
          write(iterator.reset());
        }
      };
    };
    Object.defineProperty(exports, "Iterator", d(ThrobberIterator));
  }
});

// node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/reset.js
var require_reset = __commonJS({
  "node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/reset.js"(exports, module2) {
    "use strict";
    module2.exports = "\x1B[2J\x1B[0;0H";
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/valid-object.js
var require_valid_object = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/valid-object.js"(exports, module2) {
    "use strict";
    var isObject = require_is_object();
    module2.exports = function(value) {
      if (!isObject(value))
        throw new TypeError(value + " is not an Object");
      return value;
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/array/#/clear.js
var require_clear = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/array/#/clear.js"(exports, module2) {
    "use strict";
    var value = require_valid_value();
    module2.exports = function() {
      value(this).length = 0;
      return this;
    };
  }
});

// node_modules/.pnpm/type@1.2.0/node_modules/type/plain-function/ensure.js
var require_ensure2 = __commonJS({
  "node_modules/.pnpm/type@1.2.0/node_modules/type/plain-function/ensure.js"(exports, module2) {
    "use strict";
    var resolveException = require_resolve_exception();
    var is = require_is5();
    module2.exports = function(value) {
      if (is(value))
        return value;
      return resolveException(value, "%v is not a plain function", arguments[1]);
    };
  }
});

// node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/copy.js
var require_copy = __commonJS({
  "node_modules/.pnpm/es5-ext@0.10.62/node_modules/es5-ext/object/copy.js"(exports, module2) {
    "use strict";
    var aFrom = require_from();
    var assign = require_assign();
    var value = require_valid_value();
    module2.exports = function(obj) {
      var copy = Object(value(obj)), propertyNames = arguments[1], options = Object(arguments[2]);
      if (copy !== obj && !propertyNames)
        return copy;
      var result = {};
      if (propertyNames) {
        aFrom(propertyNames, function(propertyName) {
          if (options.ensure || propertyName in obj)
            result[propertyName] = obj[propertyName];
        });
      } else {
        assign(result, obj);
      }
      return result;
    };
  }
});

// node_modules/.pnpm/d@1.0.1/node_modules/d/auto-bind.js
var require_auto_bind = __commonJS({
  "node_modules/.pnpm/d@1.0.1/node_modules/d/auto-bind.js"(exports, module2) {
    "use strict";
    var isValue = require_is();
    var ensureValue = require_ensure();
    var ensurePlainFunction = require_ensure2();
    var copy = require_copy();
    var normalizeOptions = require_normalize_options();
    var map = require_map();
    var bind = Function.prototype.bind;
    var defineProperty = Object.defineProperty;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var define2;
    define2 = function(name, desc, options) {
      var value = ensureValue(desc) && ensurePlainFunction(desc.value), dgs;
      dgs = copy(desc);
      delete dgs.writable;
      delete dgs.value;
      dgs.get = function() {
        if (!options.overwriteDefinition && hasOwnProperty2.call(this, name))
          return value;
        desc.value = bind.call(value, options.resolveContext ? options.resolveContext(this) : this);
        defineProperty(this, name, desc);
        return this[name];
      };
      return dgs;
    };
    module2.exports = function(props) {
      var options = normalizeOptions(arguments[1]);
      if (isValue(options.resolveContext))
        ensurePlainFunction(options.resolveContext);
      return map(props, function(desc, name) {
        return define2(name, desc, options);
      });
    };
  }
});

// node_modules/.pnpm/es6-iterator@2.0.3/node_modules/es6-iterator/index.js
var require_es6_iterator = __commonJS({
  "node_modules/.pnpm/es6-iterator@2.0.3/node_modules/es6-iterator/index.js"(exports, module2) {
    "use strict";
    var clear = require_clear();
    var assign = require_assign();
    var callable = require_valid_callable();
    var value = require_valid_value();
    var d = require_d();
    var autoBind = require_auto_bind();
    var Symbol2 = require_es6_symbol();
    var defineProperty = Object.defineProperty;
    var defineProperties = Object.defineProperties;
    var Iterator;
    module2.exports = Iterator = function(list, context) {
      if (!(this instanceof Iterator))
        throw new TypeError("Constructor requires 'new'");
      defineProperties(this, {
        __list__: d("w", value(list)),
        __context__: d("w", context),
        __nextIndex__: d("w", 0)
      });
      if (!context)
        return;
      callable(context.on);
      context.on("_add", this._onAdd);
      context.on("_delete", this._onDelete);
      context.on("_clear", this._onClear);
    };
    delete Iterator.prototype.constructor;
    defineProperties(
      Iterator.prototype,
      assign(
        {
          _next: d(function() {
            var i;
            if (!this.__list__)
              return void 0;
            if (this.__redo__) {
              i = this.__redo__.shift();
              if (i !== void 0)
                return i;
            }
            if (this.__nextIndex__ < this.__list__.length)
              return this.__nextIndex__++;
            this._unBind();
            return void 0;
          }),
          next: d(function() {
            return this._createResult(this._next());
          }),
          _createResult: d(function(i) {
            if (i === void 0)
              return { done: true, value: void 0 };
            return { done: false, value: this._resolve(i) };
          }),
          _resolve: d(function(i) {
            return this.__list__[i];
          }),
          _unBind: d(function() {
            this.__list__ = null;
            delete this.__redo__;
            if (!this.__context__)
              return;
            this.__context__.off("_add", this._onAdd);
            this.__context__.off("_delete", this._onDelete);
            this.__context__.off("_clear", this._onClear);
            this.__context__ = null;
          }),
          toString: d(function() {
            return "[object " + (this[Symbol2.toStringTag] || "Object") + "]";
          })
        },
        autoBind({
          _onAdd: d(function(index4) {
            if (index4 >= this.__nextIndex__)
              return;
            ++this.__nextIndex__;
            if (!this.__redo__) {
              defineProperty(this, "__redo__", d("c", [index4]));
              return;
            }
            this.__redo__.forEach(function(redo, i) {
              if (redo >= index4)
                this.__redo__[i] = ++redo;
            }, this);
            this.__redo__.push(index4);
          }),
          _onDelete: d(function(index4) {
            var i;
            if (index4 >= this.__nextIndex__)
              return;
            --this.__nextIndex__;
            if (!this.__redo__)
              return;
            i = this.__redo__.indexOf(index4);
            if (i !== -1)
              this.__redo__.splice(i, 1);
            this.__redo__.forEach(function(redo, j) {
              if (redo > index4)
                this.__redo__[j] = --redo;
            }, this);
          }),
          _onClear: d(function() {
            if (this.__redo__)
              clear.call(this.__redo__);
            this.__nextIndex__ = 0;
          })
        })
      )
    );
    defineProperty(
      Iterator.prototype,
      Symbol2.iterator,
      d(function() {
        return this;
      })
    );
  }
});

// node_modules/.pnpm/es6-iterator@2.0.3/node_modules/es6-iterator/array.js
var require_array = __commonJS({
  "node_modules/.pnpm/es6-iterator@2.0.3/node_modules/es6-iterator/array.js"(exports, module2) {
    "use strict";
    var setPrototypeOf = require_set_prototype_of();
    var contains = require_contains();
    var d = require_d();
    var Symbol2 = require_es6_symbol();
    var Iterator = require_es6_iterator();
    var defineProperty = Object.defineProperty;
    var ArrayIterator;
    ArrayIterator = module2.exports = function(arr, kind) {
      if (!(this instanceof ArrayIterator))
        throw new TypeError("Constructor requires 'new'");
      Iterator.call(this, arr);
      if (!kind)
        kind = "value";
      else if (contains.call(kind, "key+value"))
        kind = "key+value";
      else if (contains.call(kind, "key"))
        kind = "key";
      else
        kind = "value";
      defineProperty(this, "__kind__", d("", kind));
    };
    if (setPrototypeOf)
      setPrototypeOf(ArrayIterator, Iterator);
    delete ArrayIterator.prototype.constructor;
    ArrayIterator.prototype = Object.create(Iterator.prototype, {
      _resolve: d(function(i) {
        if (this.__kind__ === "value")
          return this.__list__[i];
        if (this.__kind__ === "key+value")
          return [i, this.__list__[i]];
        return i;
      })
    });
    defineProperty(ArrayIterator.prototype, Symbol2.toStringTag, d("c", "Array Iterator"));
  }
});

// node_modules/.pnpm/es6-iterator@2.0.3/node_modules/es6-iterator/string.js
var require_string = __commonJS({
  "node_modules/.pnpm/es6-iterator@2.0.3/node_modules/es6-iterator/string.js"(exports, module2) {
    "use strict";
    var setPrototypeOf = require_set_prototype_of();
    var d = require_d();
    var Symbol2 = require_es6_symbol();
    var Iterator = require_es6_iterator();
    var defineProperty = Object.defineProperty;
    var StringIterator;
    StringIterator = module2.exports = function(str) {
      if (!(this instanceof StringIterator))
        throw new TypeError("Constructor requires 'new'");
      str = String(str);
      Iterator.call(this, str);
      defineProperty(this, "__length__", d("", str.length));
    };
    if (setPrototypeOf)
      setPrototypeOf(StringIterator, Iterator);
    delete StringIterator.prototype.constructor;
    StringIterator.prototype = Object.create(Iterator.prototype, {
      _next: d(function() {
        if (!this.__list__)
          return void 0;
        if (this.__nextIndex__ < this.__length__)
          return this.__nextIndex__++;
        this._unBind();
        return void 0;
      }),
      _resolve: d(function(i) {
        var char = this.__list__[i], code;
        if (this.__nextIndex__ === this.__length__)
          return char;
        code = char.charCodeAt(0);
        if (code >= 55296 && code <= 56319)
          return char + this.__list__[this.__nextIndex__++];
        return char;
      })
    });
    defineProperty(StringIterator.prototype, Symbol2.toStringTag, d("c", "String Iterator"));
  }
});

// node_modules/.pnpm/es6-iterator@2.0.3/node_modules/es6-iterator/is-iterable.js
var require_is_iterable = __commonJS({
  "node_modules/.pnpm/es6-iterator@2.0.3/node_modules/es6-iterator/is-iterable.js"(exports, module2) {
    "use strict";
    var isArguments = require_is_arguments();
    var isValue = require_is_value();
    var isString = require_is_string();
    var iteratorSymbol = require_es6_symbol().iterator;
    var isArray = Array.isArray;
    module2.exports = function(value) {
      if (!isValue(value))
        return false;
      if (isArray(value))
        return true;
      if (isString(value))
        return true;
      if (isArguments(value))
        return true;
      return typeof value[iteratorSymbol] === "function";
    };
  }
});

// node_modules/.pnpm/es6-iterator@2.0.3/node_modules/es6-iterator/valid-iterable.js
var require_valid_iterable = __commonJS({
  "node_modules/.pnpm/es6-iterator@2.0.3/node_modules/es6-iterator/valid-iterable.js"(exports, module2) {
    "use strict";
    var isIterable = require_is_iterable();
    module2.exports = function(value) {
      if (!isIterable(value))
        throw new TypeError(value + " is not iterable");
      return value;
    };
  }
});

// node_modules/.pnpm/es6-iterator@2.0.3/node_modules/es6-iterator/get.js
var require_get2 = __commonJS({
  "node_modules/.pnpm/es6-iterator@2.0.3/node_modules/es6-iterator/get.js"(exports, module2) {
    "use strict";
    var isArguments = require_is_arguments();
    var isString = require_is_string();
    var ArrayIterator = require_array();
    var StringIterator = require_string();
    var iterable = require_valid_iterable();
    var iteratorSymbol = require_es6_symbol().iterator;
    module2.exports = function(obj) {
      if (typeof iterable(obj)[iteratorSymbol] === "function")
        return obj[iteratorSymbol]();
      if (isArguments(obj))
        return new ArrayIterator(obj);
      if (isString(obj))
        return new StringIterator(obj);
      return new ArrayIterator(obj);
    };
  }
});

// node_modules/.pnpm/es6-iterator@2.0.3/node_modules/es6-iterator/for-of.js
var require_for_of = __commonJS({
  "node_modules/.pnpm/es6-iterator@2.0.3/node_modules/es6-iterator/for-of.js"(exports, module2) {
    "use strict";
    var isArguments = require_is_arguments();
    var callable = require_valid_callable();
    var isString = require_is_string();
    var get = require_get2();
    var isArray = Array.isArray;
    var call = Function.prototype.call;
    var some = Array.prototype.some;
    module2.exports = function(iterable, cb) {
      var mode, thisArg = arguments[2], result, doBreak, broken, i, length, char, code;
      if (isArray(iterable) || isArguments(iterable))
        mode = "array";
      else if (isString(iterable))
        mode = "string";
      else
        iterable = get(iterable);
      callable(cb);
      doBreak = function() {
        broken = true;
      };
      if (mode === "array") {
        some.call(iterable, function(value) {
          call.call(cb, thisArg, value, doBreak);
          return broken;
        });
        return;
      }
      if (mode === "string") {
        length = iterable.length;
        for (i = 0; i < length; ++i) {
          char = iterable[i];
          if (i + 1 < length) {
            code = char.charCodeAt(0);
            if (code >= 55296 && code <= 56319)
              char += iterable[++i];
          }
          call.call(cb, thisArg, char, doBreak);
          if (broken)
            break;
        }
        return;
      }
      result = iterable.next();
      while (!result.done) {
        call.call(cb, thisArg, result.value, doBreak);
        if (broken)
          return;
        result = iterable.next();
      }
    };
  }
});

// node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/art.js
var require_art = __commonJS({
  "node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/art.js"(exports, module2) {
    "use strict";
    var object = require_valid_object();
    var stringifiable = require_validate_stringifiable_value();
    var forOf = require_for_of();
    module2.exports = function(text, style) {
      var result = "";
      text = stringifiable(text);
      object(style);
      forOf(text, function(char) {
        result += style[char] || char;
      });
      return result;
    };
  }
});

// node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/index.js
var require_cli_color = __commonJS({
  "node_modules/.pnpm/cli-color@2.0.3/node_modules/cli-color/index.js"(exports, module2) {
    "use strict";
    var d = require_d();
    module2.exports = Object.defineProperties(require_bare(), {
      windowSize: d(require_window_size()),
      erase: d(require_erase()),
      move: d(require_move()),
      beep: d(require_beep()),
      columns: d(require_columns()),
      strip: d(require_strip()),
      getStrippedLength: d(require_get_stripped_length()),
      slice: d(require_slice()),
      throbber: d(require_throbber()),
      reset: d(require_reset()),
      art: d(require_art())
    });
  }
});

// node_modules/.pnpm/json-diff@0.9.0/node_modules/json-diff/lib/colorize.js
var require_colorize = __commonJS({
  "node_modules/.pnpm/json-diff@0.9.0/node_modules/json-diff/lib/colorize.js"(exports, module2) {
    var color = require_cli_color();
    var { extendedTypeOf } = require_util();
    var Theme = {
      " "(s) {
        return s;
      },
      "+": color.green,
      "-": color.red
    };
    var subcolorizeToCallback = function(options, key, diff2, output, color2, indent) {
      let subvalue;
      const prefix = key ? `${key}: ` : "";
      const subindent = indent + "  ";
      const outputElisions = (n) => {
        let maxElisions = options.maxElisions === void 0 ? Infinity : options.maxElisions;
        if (n < maxElisions) {
          for (let i = 0; i < n; i++) {
            output(" ", subindent + "...");
          }
        } else {
          output(" ", subindent + `... (${n} entries)`);
        }
      };
      switch (extendedTypeOf(diff2)) {
        case "object":
          if ("__old" in diff2 && "__new" in diff2 && Object.keys(diff2).length === 2) {
            subcolorizeToCallback(options, key, diff2.__old, output, "-", indent);
            return subcolorizeToCallback(options, key, diff2.__new, output, "+", indent);
          } else {
            output(color2, `${indent}${prefix}{`);
            for (const subkey of Object.keys(diff2)) {
              let m;
              subvalue = diff2[subkey];
              if (m = subkey.match(/^(.*)__deleted$/)) {
                subcolorizeToCallback(options, m[1], subvalue, output, "-", subindent);
              } else if (m = subkey.match(/^(.*)__added$/)) {
                subcolorizeToCallback(options, m[1], subvalue, output, "+", subindent);
              } else {
                subcolorizeToCallback(options, subkey, subvalue, output, color2, subindent);
              }
            }
            return output(color2, `${indent}}`);
          }
        case "array": {
          output(color2, `${indent}${prefix}[`);
          let looksLikeDiff = true;
          for (const item of diff2) {
            if (extendedTypeOf(item) !== "array" || !(item.length === 2 || item.length === 1 && item[0] === " ") || !(typeof item[0] === "string") || item[0].length !== 1 || ![" ", "-", "+", "~"].includes(item[0])) {
              looksLikeDiff = false;
            }
          }
          if (looksLikeDiff) {
            let op;
            let elisionCount = 0;
            for ([op, subvalue] of diff2) {
              if (op === " " && subvalue == null) {
                elisionCount++;
              } else {
                if (elisionCount > 0) {
                  outputElisions(elisionCount);
                }
                elisionCount = 0;
                if (![" ", "~", "+", "-"].includes(op)) {
                  throw new Error(`Unexpected op '${op}' in ${JSON.stringify(diff2, null, 2)}`);
                }
                if (op === "~") {
                  op = " ";
                }
                subcolorizeToCallback(options, "", subvalue, output, op, subindent);
              }
            }
            if (elisionCount > 0) {
              outputElisions(elisionCount);
            }
          } else {
            for (subvalue of diff2) {
              subcolorizeToCallback(options, "", subvalue, output, color2, subindent);
            }
          }
          return output(color2, `${indent}]`);
        }
        default:
          if (diff2 === 0 || diff2 === null || diff2 === false || diff2 === "" || diff2) {
            return output(color2, indent + prefix + JSON.stringify(diff2));
          }
      }
    };
    var colorizeToCallback = (diff2, options, output) => subcolorizeToCallback(options, "", diff2, output, " ", "");
    var colorizeToArray = function(diff2, options = {}) {
      const output = [];
      colorizeToCallback(diff2, options, (color2, line) => output.push(`${color2}${line}`));
      return output;
    };
    var colorize = function(diff2, options = {}) {
      const output = [];
      colorizeToCallback(diff2, options, function(color2, line) {
        if (options.color != null ? options.color : true) {
          return output.push(((options.theme != null ? options.theme[color2] : void 0) != null ? options.theme != null ? options.theme[color2] : void 0 : Theme[color2])(`${color2}${line}`) + "\n");
        } else {
          return output.push(`${color2}${line}
`);
        }
      });
      return output.join("");
    };
    module2.exports = { colorize, colorizeToArray, colorizeToCallback };
  }
});

// node_modules/.pnpm/json-diff@0.9.0/node_modules/json-diff/lib/index.js
var require_lib = __commonJS({
  "node_modules/.pnpm/json-diff@0.9.0/node_modules/json-diff/lib/index.js"(exports, module2) {
    var { SequenceMatcher } = require_difflib2();
    var { extendedTypeOf, roundObj } = require_util();
    var { colorize } = require_colorize();
    var JsonDiff = class {
      constructor(options) {
        options.outputKeys = options.outputKeys || [];
        this.options = options;
      }
      isScalar(obj) {
        return typeof obj !== "object" || obj === null;
      }
      objectDiff(obj1, obj2) {
        let result = {};
        let score = 0;
        let equal = true;
        for (const [key, value] of Object.entries(obj1)) {
          if (!this.options.outputNewOnly) {
            let postfix = "__deleted";
            if (!(key in obj2)) {
              result[`${key}${postfix}`] = value;
              score -= 30;
              equal = false;
            }
          }
        }
        for (const [key, value] of Object.entries(obj2)) {
          let postfix = !this.options.outputNewOnly ? "__added" : "";
          if (!(key in obj1)) {
            result[`${key}${postfix}`] = value;
            score -= 30;
            equal = false;
          }
        }
        for (const [key, value1] of Object.entries(obj1)) {
          if (key in obj2) {
            score += 20;
            const value2 = obj2[key];
            const change = this.diff(value1, value2);
            if (!change.equal) {
              result[key] = change.result;
              equal = false;
            } else if (this.options.full || this.options.outputKeys.includes(key)) {
              result[key] = value1;
            }
            score += Math.min(20, Math.max(-10, change.score / 5));
          }
        }
        if (equal) {
          score = 100 * Math.max(Object.keys(obj1).length, 0.5);
          if (!this.options.full) {
            result = void 0;
          }
        } else {
          score = Math.max(0, score);
        }
        return { score, result, equal };
      }
      findMatchingObject(item, index4, fuzzyOriginals) {
        let bestMatch = null;
        for (const [key, { item: candidate, index: matchIndex }] of Object.entries(fuzzyOriginals)) {
          if (key !== "__next") {
            const indexDistance = Math.abs(matchIndex - index4);
            if (extendedTypeOf(item) === extendedTypeOf(candidate)) {
              const { score } = this.diff(item, candidate);
              if (!bestMatch || score > bestMatch.score || score === bestMatch.score && indexDistance < bestMatch.indexDistance) {
                bestMatch = { score, key, indexDistance };
              }
            }
          }
        }
        return bestMatch;
      }
      scalarize(array, originals, fuzzyOriginals) {
        const fuzzyMatches = [];
        if (fuzzyOriginals) {
          const keyScores = {};
          for (let index4 = 0; index4 < array.length; index4++) {
            const item = array[index4];
            if (this.isScalar(item)) {
              continue;
            }
            const bestMatch = this.findMatchingObject(item, index4, fuzzyOriginals);
            if (bestMatch && (!keyScores[bestMatch.key] || bestMatch.score > keyScores[bestMatch.key].score)) {
              keyScores[bestMatch.key] = { score: bestMatch.score, index: index4 };
            }
          }
          for (const [key, match] of Object.entries(keyScores)) {
            fuzzyMatches[match.index] = key;
          }
        }
        const result = [];
        for (let index4 = 0; index4 < array.length; index4++) {
          const item = array[index4];
          if (this.isScalar(item)) {
            result.push(item);
          } else {
            const key = fuzzyMatches[index4] || "__$!SCALAR" + originals.__next++;
            originals[key] = { item, index: index4 };
            result.push(key);
          }
        }
        return result;
      }
      isScalarized(item, originals) {
        return typeof item === "string" && item in originals;
      }
      descalarize(item, originals) {
        if (this.isScalarized(item, originals)) {
          return originals[item].item;
        } else {
          return item;
        }
      }
      arrayDiff(obj1, obj2) {
        const originals1 = { __next: 1 };
        const seq1 = this.scalarize(obj1, originals1);
        const originals2 = { __next: originals1.__next };
        const seq2 = this.scalarize(obj2, originals2, originals1);
        if (this.options.sort) {
          seq1.sort();
          seq2.sort();
        }
        const opcodes = new SequenceMatcher(null, seq1, seq2).getOpcodes();
        let result = [];
        let score = 0;
        let equal = true;
        for (const [op, i1, i2, j1, j2] of opcodes) {
          let i, j;
          let asc, end;
          let asc1, end1;
          let asc2, end2;
          if (!(op === "equal" || this.options.keysOnly && op === "replace")) {
            equal = false;
          }
          switch (op) {
            case "equal":
              for (i = i1, end = i2, asc = i1 <= end; asc ? i < end : i > end; asc ? i++ : i--) {
                const item = seq1[i];
                if (this.isScalarized(item, originals1)) {
                  if (!this.isScalarized(item, originals2)) {
                    throw new Error(
                      `internal bug: isScalarized(item, originals1) != isScalarized(item, originals2) for item ${JSON.stringify(
                        item
                      )}`
                    );
                  }
                  const item1 = this.descalarize(item, originals1);
                  const item2 = this.descalarize(item, originals2);
                  const change = this.diff(item1, item2);
                  if (!change.equal) {
                    result.push(["~", change.result]);
                    equal = false;
                  } else {
                    if (this.options.full || this.options.keepUnchangedValues) {
                      result.push([" ", item1]);
                    } else {
                      result.push([" "]);
                    }
                  }
                } else {
                  if (this.options.full || this.options.keepUnchangedValues) {
                    result.push([" ", item]);
                  } else {
                    result.push([" "]);
                  }
                }
                score += 10;
              }
              break;
            case "delete":
              for (i = i1, end1 = i2, asc1 = i1 <= end1; asc1 ? i < end1 : i > end1; asc1 ? i++ : i--) {
                result.push(["-", this.descalarize(seq1[i], originals1)]);
                score -= 5;
              }
              break;
            case "insert":
              for (j = j1, end2 = j2, asc2 = j1 <= end2; asc2 ? j < end2 : j > end2; asc2 ? j++ : j--) {
                result.push(["+", this.descalarize(seq2[j], originals2)]);
                score -= 5;
              }
              break;
            case "replace":
              if (!this.options.keysOnly) {
                let asc3, end3;
                let asc4, end4;
                for (i = i1, end3 = i2, asc3 = i1 <= end3; asc3 ? i < end3 : i > end3; asc3 ? i++ : i--) {
                  result.push(["-", this.descalarize(seq1[i], originals1)]);
                  score -= 5;
                }
                for (j = j1, end4 = j2, asc4 = j1 <= end4; asc4 ? j < end4 : j > end4; asc4 ? j++ : j--) {
                  result.push(["+", this.descalarize(seq2[j], originals2)]);
                  score -= 5;
                }
              } else {
                let asc5, end5;
                for (i = i1, end5 = i2, asc5 = i1 <= end5; asc5 ? i < end5 : i > end5; asc5 ? i++ : i--) {
                  const change = this.diff(
                    this.descalarize(seq1[i], originals1),
                    this.descalarize(seq2[i - i1 + j1], originals2)
                  );
                  if (!change.equal) {
                    result.push(["~", change.result]);
                    equal = false;
                  } else {
                    result.push([" "]);
                  }
                }
              }
              break;
          }
        }
        if (equal || opcodes.length === 0) {
          if (!this.options.full) {
            result = void 0;
          } else {
            result = obj1;
          }
          score = 100;
        } else {
          score = Math.max(0, score);
        }
        return { score, result, equal };
      }
      diff(obj1, obj2) {
        const type1 = extendedTypeOf(obj1);
        const type2 = extendedTypeOf(obj2);
        if (type1 === type2) {
          switch (type1) {
            case "object":
              return this.objectDiff(obj1, obj2);
            case "array":
              return this.arrayDiff(obj1, obj2);
          }
        }
        let score = 100;
        let result = obj1;
        let equal;
        if (!this.options.keysOnly) {
          equal = obj1 === obj2;
          if (!equal) {
            score = 0;
            if (this.options.outputNewOnly) {
              result = obj2;
            } else {
              result = { __old: obj1, __new: obj2 };
            }
          } else if (!this.options.full) {
            result = void 0;
          }
        } else {
          equal = true;
          result = void 0;
        }
        return { score, result, equal };
      }
    };
    function diff2(obj1, obj2, options = {}) {
      if (options.precision !== void 0) {
        obj1 = roundObj(obj1, options.precision);
        obj2 = roundObj(obj2, options.precision);
      }
      return new JsonDiff(options).diff(obj1, obj2).result;
    }
    function diffString(obj1, obj2, options = {}) {
      return colorize(diff2(obj1, obj2, options), options);
    }
    module2.exports = { diff: diff2, diffString };
  }
});

// node_modules/.pnpm/fs.realpath@1.0.0/node_modules/fs.realpath/old.js
var require_old = __commonJS({
  "node_modules/.pnpm/fs.realpath@1.0.0/node_modules/fs.realpath/old.js"(exports) {
    var pathModule = require("path");
    var isWindows = process.platform === "win32";
    var fs = require("fs");
    var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
    function rethrow() {
      var callback;
      if (DEBUG) {
        var backtrace = new Error();
        callback = debugCallback;
      } else
        callback = missingCallback;
      return callback;
      function debugCallback(err) {
        if (err) {
          backtrace.message = err.message;
          err = backtrace;
          missingCallback(err);
        }
      }
      function missingCallback(err) {
        if (err) {
          if (process.throwDeprecation)
            throw err;
          else if (!process.noDeprecation) {
            var msg = "fs: missing callback " + (err.stack || err.message);
            if (process.traceDeprecation)
              console.trace(msg);
            else
              console.error(msg);
          }
        }
      }
    }
    function maybeCallback(cb) {
      return typeof cb === "function" ? cb : rethrow();
    }
    var normalize = pathModule.normalize;
    if (isWindows) {
      nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
    } else {
      nextPartRe = /(.*?)(?:[\/]+|$)/g;
    }
    var nextPartRe;
    if (isWindows) {
      splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
    } else {
      splitRootRe = /^[\/]*/;
    }
    var splitRootRe;
    exports.realpathSync = function realpathSync(p, cache) {
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return cache[p];
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs.lstatSync(base);
          knownHard[base] = true;
        }
      }
      while (pos < p.length) {
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          continue;
        }
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          resolvedLink = cache[base];
        } else {
          var stat = fs.lstatSync(base);
          if (!stat.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache)
              cache[base] = base;
            continue;
          }
          var linkTarget = null;
          if (!isWindows) {
            var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              linkTarget = seenLinks[id];
            }
          }
          if (linkTarget === null) {
            fs.statSync(base);
            linkTarget = fs.readlinkSync(base);
          }
          resolvedLink = pathModule.resolve(previous, linkTarget);
          if (cache)
            cache[base] = resolvedLink;
          if (!isWindows)
            seenLinks[id] = linkTarget;
        }
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
      if (cache)
        cache[original] = p;
      return p;
    };
    exports.realpath = function realpath(p, cache, cb) {
      if (typeof cb !== "function") {
        cb = maybeCallback(cache);
        cache = null;
      }
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return process.nextTick(cb.bind(null, null, cache[p]));
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs.lstat(base, function(err) {
            if (err)
              return cb(err);
            knownHard[base] = true;
            LOOP();
          });
        } else {
          process.nextTick(LOOP);
        }
      }
      function LOOP() {
        if (pos >= p.length) {
          if (cache)
            cache[original] = p;
          return cb(null, p);
        }
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          return process.nextTick(LOOP);
        }
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          return gotResolvedLink(cache[base]);
        }
        return fs.lstat(base, gotStat);
      }
      function gotStat(err, stat) {
        if (err)
          return cb(err);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          return process.nextTick(LOOP);
        }
        if (!isWindows) {
          var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            return gotTarget(null, seenLinks[id], base);
          }
        }
        fs.stat(base, function(err2) {
          if (err2)
            return cb(err2);
          fs.readlink(base, function(err3, target) {
            if (!isWindows)
              seenLinks[id] = target;
            gotTarget(err3, target);
          });
        });
      }
      function gotTarget(err, target, base2) {
        if (err)
          return cb(err);
        var resolvedLink = pathModule.resolve(previous, target);
        if (cache)
          cache[base2] = resolvedLink;
        gotResolvedLink(resolvedLink);
      }
      function gotResolvedLink(resolvedLink) {
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
    };
  }
});

// node_modules/.pnpm/fs.realpath@1.0.0/node_modules/fs.realpath/index.js
var require_fs = __commonJS({
  "node_modules/.pnpm/fs.realpath@1.0.0/node_modules/fs.realpath/index.js"(exports, module2) {
    module2.exports = realpath;
    realpath.realpath = realpath;
    realpath.sync = realpathSync;
    realpath.realpathSync = realpathSync;
    realpath.monkeypatch = monkeypatch;
    realpath.unmonkeypatch = unmonkeypatch;
    var fs = require("fs");
    var origRealpath = fs.realpath;
    var origRealpathSync = fs.realpathSync;
    var version = process.version;
    var ok = /^v[0-5]\./.test(version);
    var old = require_old();
    function newError(er) {
      return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
    }
    function realpath(p, cache, cb) {
      if (ok) {
        return origRealpath(p, cache, cb);
      }
      if (typeof cache === "function") {
        cb = cache;
        cache = null;
      }
      origRealpath(p, cache, function(er, result) {
        if (newError(er)) {
          old.realpath(p, cache, cb);
        } else {
          cb(er, result);
        }
      });
    }
    function realpathSync(p, cache) {
      if (ok) {
        return origRealpathSync(p, cache);
      }
      try {
        return origRealpathSync(p, cache);
      } catch (er) {
        if (newError(er)) {
          return old.realpathSync(p, cache);
        } else {
          throw er;
        }
      }
    }
    function monkeypatch() {
      fs.realpath = realpath;
      fs.realpathSync = realpathSync;
    }
    function unmonkeypatch() {
      fs.realpath = origRealpath;
      fs.realpathSync = origRealpathSync;
    }
  }
});

// node_modules/.pnpm/minimatch@5.1.6/node_modules/minimatch/lib/path.js
var require_path = __commonJS({
  "node_modules/.pnpm/minimatch@5.1.6/node_modules/minimatch/lib/path.js"(exports, module2) {
    var isWindows = typeof process === "object" && process && process.platform === "win32";
    module2.exports = isWindows ? { sep: "\\" } : { sep: "/" };
  }
});

// node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js"(exports, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js"(exports, module2) {
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m)
        return [str];
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      if (/\$$/.test(m.pre)) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + "{" + m.body + "}" + post[k];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,.*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand(n[0], false).map(embrace);
            if (n.length === 1) {
              return post.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n.some(isPadded);
          N = [];
          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\")
                c = "";
            } else {
              c = String(i);
              if (pad) {
                var need = width - c.length;
                if (need > 0) {
                  var z2 = new Array(need + 1).join("0");
                  if (i < 0)
                    c = "-" + z2 + c.slice(1);
                  else
                    c = z2 + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = [];
          for (var j = 0; j < n.length; j++) {
            N.push.apply(N, expand(n[j], false));
          }
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
  }
});

// node_modules/.pnpm/minimatch@5.1.6/node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "node_modules/.pnpm/minimatch@5.1.6/node_modules/minimatch/minimatch.js"(exports, module2) {
    var minimatch = module2.exports = (p, pattern, options = {}) => {
      assertValidPattern(pattern);
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    };
    module2.exports = minimatch;
    var path = require_path();
    minimatch.sep = path.sep;
    var GLOBSTAR = Symbol("globstar **");
    minimatch.GLOBSTAR = GLOBSTAR;
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var charSet = (s) => s.split("").reduce((set, c) => {
      set[c] = true;
      return set;
    }, {});
    var reSpecials = charSet("().*{}+?[]^$\\!");
    var addPatternStartSet = charSet("[.(");
    var slashSplit = /\/+/;
    minimatch.filter = (pattern, options = {}) => (p, i, list) => minimatch(p, pattern, options);
    var ext = (a, b = {}) => {
      const t = {};
      Object.keys(a).forEach((k) => t[k] = a[k]);
      Object.keys(b).forEach((k) => t[k] = b[k]);
      return t;
    };
    minimatch.defaults = (def) => {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      const orig = minimatch;
      const m = (p, pattern, options) => orig(p, pattern, ext(def, options));
      m.Minimatch = class Minimatch extends orig.Minimatch {
        constructor(pattern, options) {
          super(pattern, ext(def, options));
        }
      };
      m.Minimatch.defaults = (options) => orig.defaults(ext(def, options)).Minimatch;
      m.filter = (pattern, options) => orig.filter(pattern, ext(def, options));
      m.defaults = (options) => orig.defaults(ext(def, options));
      m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options));
      m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options));
      m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options));
      return m;
    };
    minimatch.braceExpand = (pattern, options) => braceExpand(pattern, options);
    var braceExpand = (pattern, options = {}) => {
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    };
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = (pattern) => {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    var SUBPARSE = Symbol("subparse");
    minimatch.makeRe = (pattern, options) => new Minimatch(pattern, options || {}).makeRe();
    minimatch.match = (list, pattern, options = {}) => {
      const mm = new Minimatch(pattern, options);
      list = list.filter((f) => mm.match(f));
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    var globUnescape = (s) => s.replace(/\\(.)/g, "$1");
    var charUnescape = (s) => s.replace(/\\([^-\]])/g, "$1");
    var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var braExpEscape = (s) => s.replace(/[[\]\\]/g, "\\$&");
    var Minimatch = class {
      constructor(pattern, options) {
        assertValidPattern(pattern);
        if (!options)
          options = {};
        this.options = options;
        this.set = [];
        this.pattern = pattern;
        this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          this.pattern = this.pattern.replace(/\\/g, "/");
        }
        this.regexp = null;
        this.negate = false;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.make();
      }
      debug() {
      }
      make() {
        const pattern = this.pattern;
        const options = this.options;
        if (!options.nocomment && pattern.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        let set = this.globSet = this.braceExpand();
        if (options.debug)
          this.debug = (...args) => console.error(...args);
        this.debug(this.pattern, set);
        set = this.globParts = set.map((s) => s.split(slashSplit));
        this.debug(this.pattern, set);
        set = set.map((s, si, set2) => s.map(this.parse, this));
        this.debug(this.pattern, set);
        set = set.filter((s) => s.indexOf(false) === -1);
        this.debug(this.pattern, set);
        this.set = set;
      }
      parseNegate() {
        if (this.options.nonegate)
          return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset)
          this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
      }
      // set partial to true to test if, for example,
      // "/a/b" matches the start of "/*/b/*/d"
      // Partial means, if you run out of file before you run
      // out of pattern, then that's fine, as long as all
      // the parts match.
      matchOne(file, pattern, partial) {
        var options = this.options;
        this.debug(
          "matchOne",
          { "this": this, file, pattern }
        );
        this.debug("matchOne", file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern[pi];
          var f = file[fi];
          this.debug(pattern, p, f);
          if (p === false)
            return false;
          if (p === GLOBSTAR) {
            this.debug("GLOBSTAR", [pattern, p, f]);
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                  return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern, pr);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial) {
              this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
              if (fr === fl)
                return true;
            }
            return false;
          }
          var hit;
          if (typeof p === "string") {
            hit = f === p;
            this.debug("string match", p, f, hit);
          } else {
            hit = f.match(p);
            this.debug("pattern match", p, f, hit);
          }
          if (!hit)
            return false;
        }
        if (fi === fl && pi === pl) {
          return true;
        } else if (fi === fl) {
          return partial;
        } else if (pi === pl) {
          return fi === fl - 1 && file[fi] === "";
        }
        throw new Error("wtf?");
      }
      braceExpand() {
        return braceExpand(this.pattern, this.options);
      }
      parse(pattern, isSub) {
        assertValidPattern(pattern);
        const options = this.options;
        if (pattern === "**") {
          if (!options.noglobstar)
            return GLOBSTAR;
          else
            pattern = "*";
        }
        if (pattern === "")
          return "";
        let re = "";
        let hasMagic = false;
        let escaping = false;
        const patternListStack = [];
        const negativeLists = [];
        let stateChar;
        let inClass = false;
        let reClassStart = -1;
        let classStart = -1;
        let cs;
        let pl;
        let sp;
        let dotTravAllowed = pattern.charAt(0) === ".";
        let dotFileAllowed = options.dot || dotTravAllowed;
        const patternStart = () => dotTravAllowed ? "" : dotFileAllowed ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        const subPatternStart = (p) => p.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        const clearStateChar = () => {
          if (stateChar) {
            switch (stateChar) {
              case "*":
                re += star;
                hasMagic = true;
                break;
              case "?":
                re += qmark;
                hasMagic = true;
                break;
              default:
                re += "\\" + stateChar;
                break;
            }
            this.debug("clearStateChar %j %j", stateChar, re);
            stateChar = false;
          }
        };
        for (let i = 0, c; i < pattern.length && (c = pattern.charAt(i)); i++) {
          this.debug("%s	%s %s %j", pattern, i, re, c);
          if (escaping) {
            if (c === "/") {
              return false;
            }
            if (reSpecials[c]) {
              re += "\\";
            }
            re += c;
            escaping = false;
            continue;
          }
          switch (c) {
            case "/": {
              return false;
            }
            case "\\":
              if (inClass && pattern.charAt(i + 1) === "-") {
                re += c;
                continue;
              }
              clearStateChar();
              escaping = true;
              continue;
            case "?":
            case "*":
            case "+":
            case "@":
            case "!":
              this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
              if (inClass) {
                this.debug("  in class");
                if (c === "!" && i === classStart + 1)
                  c = "^";
                re += c;
                continue;
              }
              this.debug("call clearStateChar %j", stateChar);
              clearStateChar();
              stateChar = c;
              if (options.noext)
                clearStateChar();
              continue;
            case "(": {
              if (inClass) {
                re += "(";
                continue;
              }
              if (!stateChar) {
                re += "\\(";
                continue;
              }
              const plEntry = {
                type: stateChar,
                start: i - 1,
                reStart: re.length,
                open: plTypes[stateChar].open,
                close: plTypes[stateChar].close
              };
              this.debug(this.pattern, "	", plEntry);
              patternListStack.push(plEntry);
              re += plEntry.open;
              if (plEntry.start === 0 && plEntry.type !== "!") {
                dotTravAllowed = true;
                re += subPatternStart(pattern.slice(i + 1));
              }
              this.debug("plType %j %j", stateChar, re);
              stateChar = false;
              continue;
            }
            case ")": {
              const plEntry = patternListStack[patternListStack.length - 1];
              if (inClass || !plEntry) {
                re += "\\)";
                continue;
              }
              patternListStack.pop();
              clearStateChar();
              hasMagic = true;
              pl = plEntry;
              re += pl.close;
              if (pl.type === "!") {
                negativeLists.push(Object.assign(pl, { reEnd: re.length }));
              }
              continue;
            }
            case "|": {
              const plEntry = patternListStack[patternListStack.length - 1];
              if (inClass || !plEntry) {
                re += "\\|";
                continue;
              }
              clearStateChar();
              re += "|";
              if (plEntry.start === 0 && plEntry.type !== "!") {
                dotTravAllowed = true;
                re += subPatternStart(pattern.slice(i + 1));
              }
              continue;
            }
            case "[":
              clearStateChar();
              if (inClass) {
                re += "\\" + c;
                continue;
              }
              inClass = true;
              classStart = i;
              reClassStart = re.length;
              re += c;
              continue;
            case "]":
              if (i === classStart + 1 || !inClass) {
                re += "\\" + c;
                continue;
              }
              cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + braExpEscape(charUnescape(cs)) + "]");
                re += c;
              } catch (er) {
                re = re.substring(0, reClassStart) + "(?:$.)";
              }
              hasMagic = true;
              inClass = false;
              continue;
            default:
              clearStateChar();
              if (reSpecials[c] && !(c === "^" && inClass)) {
                re += "\\";
              }
              re += c;
              break;
          }
        }
        if (inClass) {
          cs = pattern.slice(classStart + 1);
          sp = this.parse(cs, SUBPARSE);
          re = re.substring(0, reClassStart) + "\\[" + sp[0];
          hasMagic = hasMagic || sp[1];
        }
        for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
          let tail;
          tail = re.slice(pl.reStart + pl.open.length);
          this.debug("setting tail", re, pl);
          tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_, $1, $2) => {
            if (!$2) {
              $2 = "\\";
            }
            return $1 + $1 + $2 + "|";
          });
          this.debug("tail=%j\n   %s", tail, tail, pl, re);
          const t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
          hasMagic = true;
          re = re.slice(0, pl.reStart) + t + "\\(" + tail;
        }
        clearStateChar();
        if (escaping) {
          re += "\\\\";
        }
        const addPatternStart = addPatternStartSet[re.charAt(0)];
        for (let n = negativeLists.length - 1; n > -1; n--) {
          const nl = negativeLists[n];
          const nlBefore = re.slice(0, nl.reStart);
          const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
          let nlAfter = re.slice(nl.reEnd);
          const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
          const closeParensBefore = nlBefore.split(")").length;
          const openParensBefore = nlBefore.split("(").length - closeParensBefore;
          let cleanAfter = nlAfter;
          for (let i = 0; i < openParensBefore; i++) {
            cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
          }
          nlAfter = cleanAfter;
          const dollar = nlAfter === "" && isSub !== SUBPARSE ? "(?:$|\\/)" : "";
          re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        }
        if (re !== "" && hasMagic) {
          re = "(?=.)" + re;
        }
        if (addPatternStart) {
          re = patternStart() + re;
        }
        if (isSub === SUBPARSE) {
          return [re, hasMagic];
        }
        if (options.nocase && !hasMagic) {
          hasMagic = pattern.toUpperCase() !== pattern.toLowerCase();
        }
        if (!hasMagic) {
          return globUnescape(pattern);
        }
        const flags = options.nocase ? "i" : "";
        try {
          return Object.assign(new RegExp("^" + re + "$", flags), {
            _glob: pattern,
            _src: re
          });
        } catch (er) {
          return new RegExp("$.");
        }
      }
      makeRe() {
        if (this.regexp || this.regexp === false)
          return this.regexp;
        const set = this.set;
        if (!set.length) {
          this.regexp = false;
          return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
        const flags = options.nocase ? "i" : "";
        let re = set.map((pattern) => {
          pattern = pattern.map(
            (p) => typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src
          ).reduce((set2, p) => {
            if (!(set2[set2.length - 1] === GLOBSTAR && p === GLOBSTAR)) {
              set2.push(p);
            }
            return set2;
          }, []);
          pattern.forEach((p, i) => {
            if (p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR) {
              return;
            }
            if (i === 0) {
              if (pattern.length > 1) {
                pattern[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i + 1];
              } else {
                pattern[i] = twoStar;
              }
            } else if (i === pattern.length - 1) {
              pattern[i - 1] += "(?:\\/|" + twoStar + ")?";
            } else {
              pattern[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i + 1];
              pattern[i + 1] = GLOBSTAR;
            }
          });
          return pattern.filter((p) => p !== GLOBSTAR).join("/");
        }).join("|");
        re = "^(?:" + re + ")$";
        if (this.negate)
          re = "^(?!" + re + ").*$";
        try {
          this.regexp = new RegExp(re, flags);
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      match(f, partial = this.partial) {
        this.debug("match", f, this.pattern);
        if (this.comment)
          return false;
        if (this.empty)
          return f === "";
        if (f === "/" && partial)
          return true;
        const options = this.options;
        if (path.sep !== "/") {
          f = f.split(path.sep).join("/");
        }
        f = f.split(slashSplit);
        this.debug(this.pattern, "split", f);
        const set = this.set;
        this.debug(this.pattern, "set", set);
        let filename;
        for (let i = f.length - 1; i >= 0; i--) {
          filename = f[i];
          if (filename)
            break;
        }
        for (let i = 0; i < set.length; i++) {
          const pattern = set[i];
          let file = f;
          if (options.matchBase && pattern.length === 1) {
            file = [filename];
          }
          const hit = this.matchOne(file, pattern, partial);
          if (hit) {
            if (options.flipNegate)
              return true;
            return !this.negate;
          }
        }
        if (options.flipNegate)
          return false;
        return this.negate;
      }
      static defaults(def) {
        return minimatch.defaults(def).Minimatch;
      }
    };
    minimatch.Minimatch = Minimatch;
  }
});

// node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js"(exports, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js"(exports, module2) {
    try {
      util2 = require("util");
      if (typeof util2.inherits !== "function")
        throw "";
      module2.exports = util2.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util2;
  }
});

// node_modules/.pnpm/glob@8.1.0/node_modules/glob/common.js
var require_common = __commonJS({
  "node_modules/.pnpm/glob@8.1.0/node_modules/glob/common.js"(exports) {
    exports.setopts = setopts;
    exports.ownProp = ownProp;
    exports.makeAbs = makeAbs;
    exports.finish = finish;
    exports.mark = mark;
    exports.isIgnored = isIgnored;
    exports.childrenIgnored = childrenIgnored;
    function ownProp(obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field);
    }
    var fs = require("fs");
    var path = require("path");
    var minimatch = require_minimatch();
    var isAbsolute = require("path").isAbsolute;
    var Minimatch = minimatch.Minimatch;
    function alphasort(a, b) {
      return a.localeCompare(b, "en");
    }
    function setupIgnores(self2, options) {
      self2.ignore = options.ignore || [];
      if (!Array.isArray(self2.ignore))
        self2.ignore = [self2.ignore];
      if (self2.ignore.length) {
        self2.ignore = self2.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, { dot: true });
      }
      return {
        matcher: new Minimatch(pattern, { dot: true }),
        gmatcher
      };
    }
    function setopts(self2, pattern, options) {
      if (!options)
        options = {};
      if (options.matchBase && -1 === pattern.indexOf("/")) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self2.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
      if (self2.windowsPathsNoEscape) {
        pattern = pattern.replace(/\\/g, "/");
      }
      self2.silent = !!options.silent;
      self2.pattern = pattern;
      self2.strict = options.strict !== false;
      self2.realpath = !!options.realpath;
      self2.realpathCache = options.realpathCache || /* @__PURE__ */ Object.create(null);
      self2.follow = !!options.follow;
      self2.dot = !!options.dot;
      self2.mark = !!options.mark;
      self2.nodir = !!options.nodir;
      if (self2.nodir)
        self2.mark = true;
      self2.sync = !!options.sync;
      self2.nounique = !!options.nounique;
      self2.nonull = !!options.nonull;
      self2.nosort = !!options.nosort;
      self2.nocase = !!options.nocase;
      self2.stat = !!options.stat;
      self2.noprocess = !!options.noprocess;
      self2.absolute = !!options.absolute;
      self2.fs = options.fs || fs;
      self2.maxLength = options.maxLength || Infinity;
      self2.cache = options.cache || /* @__PURE__ */ Object.create(null);
      self2.statCache = options.statCache || /* @__PURE__ */ Object.create(null);
      self2.symlinks = options.symlinks || /* @__PURE__ */ Object.create(null);
      setupIgnores(self2, options);
      self2.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options, "cwd"))
        self2.cwd = path.resolve(cwd);
      else {
        self2.cwd = path.resolve(options.cwd);
        self2.changedCwd = self2.cwd !== cwd;
      }
      self2.root = options.root || path.resolve(self2.cwd, "/");
      self2.root = path.resolve(self2.root);
      self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
      self2.nomount = !!options.nomount;
      if (process.platform === "win32") {
        self2.root = self2.root.replace(/\\/g, "/");
        self2.cwd = self2.cwd.replace(/\\/g, "/");
        self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
      }
      options.nonegate = true;
      options.nocomment = true;
      self2.minimatch = new Minimatch(pattern, options);
      self2.options = self2.minimatch.options;
    }
    function finish(self2) {
      var nou = self2.nounique;
      var all = nou ? [] : /* @__PURE__ */ Object.create(null);
      for (var i = 0, l = self2.matches.length; i < l; i++) {
        var matches = self2.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self2.nonull) {
            var literal = self2.minimatch.globSet[i];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function(m2) {
              all[m2] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self2.nosort)
        all = all.sort(alphasort);
      if (self2.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self2._mark(all[i]);
        }
        if (self2.nodir) {
          all = all.filter(function(e) {
            var notDir = !/\/$/.test(e);
            var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
            if (notDir && c)
              notDir = c !== "DIR" && !Array.isArray(c);
            return notDir;
          });
        }
      }
      if (self2.ignore.length)
        all = all.filter(function(m2) {
          return !isIgnored(self2, m2);
        });
      self2.found = all;
    }
    function mark(self2, p) {
      var abs = makeAbs(self2, p);
      var c = self2.cache[abs];
      var m = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m += "/";
        else if (!isDir && slash)
          m = m.slice(0, -1);
        if (m !== p) {
          var mabs = makeAbs(self2, m);
          self2.statCache[mabs] = self2.statCache[abs];
          self2.cache[mabs] = self2.cache[abs];
        }
      }
      return m;
    }
    function makeAbs(self2, f) {
      var abs = f;
      if (f.charAt(0) === "/") {
        abs = path.join(self2.root, f);
      } else if (isAbsolute(f) || f === "") {
        abs = f;
      } else if (self2.changedCwd) {
        abs = path.resolve(self2.cwd, f);
      } else {
        abs = path.resolve(f);
      }
      if (process.platform === "win32")
        abs = abs.replace(/\\/g, "/");
      return abs;
    }
    function isIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return item.matcher.match(path2) || !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
    function childrenIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
  }
});

// node_modules/.pnpm/glob@8.1.0/node_modules/glob/sync.js
var require_sync = __commonJS({
  "node_modules/.pnpm/glob@8.1.0/node_modules/glob/sync.js"(exports, module2) {
    module2.exports = globSync;
    globSync.GlobSync = GlobSync;
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var Glob = require_glob().Glob;
    var util2 = require("util");
    var path = require("path");
    var assert = require("assert");
    var isAbsolute = require("path").isAbsolute;
    var common = require_common();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    function globSync(pattern, options) {
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options).found;
    }
    function GlobSync(pattern, options) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options);
      setopts(this, pattern, options);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert.ok(this instanceof GlobSync);
      if (this.realpath) {
        var self2 = this;
        this.matches.forEach(function(matchset, index4) {
          var set = self2.matches[index4] = /* @__PURE__ */ Object.create(null);
          for (var p in matchset) {
            try {
              p = self2._makeAbs(p);
              var real = rp.realpathSync(p, self2.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self2._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index4, inGlobStar) {
      assert.ok(this instanceof GlobSync);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index4);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === "string" ? p : "[*]";
      }).join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return;
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index4, inGlobStar);
      else
        this._processReaddir(prefix, read, abs, remain, index4, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index4, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index4])
          this.matches[index4] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index4, e);
        }
        return;
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index4, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index4, e) {
      if (isIgnored(this, e))
        return;
      var abs = this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute) {
        e = abs;
      }
      if (this.matches[index4][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index4][e] = true;
      if (this.stat)
        this._stat(e);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat;
      var stat;
      try {
        lstat = this.fs.lstatSync(abs);
      } catch (er) {
        if (er.code === "ENOENT") {
          return null;
        }
      }
      var isSym = lstat && lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs, this.fs.readdirSync(abs));
      } catch (er) {
        this._readdirError(abs, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            throw error;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index4, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index4, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index4, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index4, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index4) {
      var exists = this._stat(prefix);
      if (!this.matches[index4])
        this.matches[index4] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index4, prefix);
    };
    GlobSync.prototype._stat = function(f) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists;
      var stat = this.statCache[abs];
      if (!stat) {
        var lstat;
        try {
          lstat = this.fs.lstatSync(abs);
        } catch (er) {
          if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
            this.statCache[abs] = false;
            return false;
          }
        }
        if (lstat && lstat.isSymbolicLink()) {
          try {
            stat = this.fs.statSync(abs);
          } catch (er) {
            stat = lstat;
          }
        } else {
          stat = lstat;
        }
      }
      this.statCache[abs] = stat;
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return false;
      return c;
    };
    GlobSync.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
  }
});

// node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js"(exports, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/.pnpm/once@1.4.0/node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/.pnpm/once@1.4.0/node_modules/once/once.js"(exports, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// node_modules/.pnpm/inflight@1.0.6/node_modules/inflight/inflight.js
var require_inflight = __commonJS({
  "node_modules/.pnpm/inflight@1.0.6/node_modules/inflight/inflight.js"(exports, module2) {
    var wrappy = require_wrappy();
    var reqs = /* @__PURE__ */ Object.create(null);
    var once = require_once();
    module2.exports = wrappy(inflight);
    function inflight(key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb);
        return null;
      } else {
        reqs[key] = [cb];
        return makeres(key);
      }
    }
    function makeres(key) {
      return once(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice(arguments);
        try {
          for (var i = 0; i < len; i++) {
            cbs[i].apply(null, args);
          }
        } finally {
          if (cbs.length > len) {
            cbs.splice(0, len);
            process.nextTick(function() {
              RES.apply(null, args);
            });
          } else {
            delete reqs[key];
          }
        }
      });
    }
    function slice(args) {
      var length = args.length;
      var array = [];
      for (var i = 0; i < length; i++)
        array[i] = args[i];
      return array;
    }
  }
});

// node_modules/.pnpm/glob@8.1.0/node_modules/glob/glob.js
var require_glob = __commonJS({
  "node_modules/.pnpm/glob@8.1.0/node_modules/glob/glob.js"(exports, module2) {
    module2.exports = glob2;
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var inherits = require_inherits();
    var EE = require("events").EventEmitter;
    var path = require("path");
    var assert = require("assert");
    var isAbsolute = require("path").isAbsolute;
    var globSync = require_sync();
    var common = require_common();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight();
    var util2 = require("util");
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = require_once();
    function glob2(pattern, options, cb) {
      if (typeof options === "function")
        cb = options, options = {};
      if (!options)
        options = {};
      if (options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options);
      }
      return new Glob(pattern, options, cb);
    }
    glob2.sync = globSync;
    var GlobSync = glob2.GlobSync = globSync.GlobSync;
    glob2.glob = glob2;
    function extend(origin, add) {
      if (add === null || typeof add !== "object") {
        return origin;
      }
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
    glob2.hasMagic = function(pattern, options_) {
      var options = extend({}, options_);
      options.noprocess = true;
      var g = new Glob(pattern, options);
      var set = g.minimatch.set;
      if (!pattern)
        return false;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob2.Glob = Glob;
    inherits(Glob, EE);
    function Glob(pattern, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      if (options && options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb);
      setopts(this, pattern, options);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches) {
          cb(null, matches);
        });
      }
      var self2 = this;
      this._processing = 0;
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      var sync2 = true;
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      sync2 = false;
      function done() {
        --self2._processing;
        if (self2._processing <= 0) {
          if (sync2) {
            process.nextTick(function() {
              self2._finish();
            });
          } else {
            self2._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self2 = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);
      function next() {
        if (--n === 0)
          self2._finish();
      }
    };
    Glob.prototype._realpathSet = function(index4, cb) {
      var matchset = this.matches[index4];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self2 = this;
      var n = found.length;
      if (n === 0)
        return cb();
      var set = this.matches[index4] = /* @__PURE__ */ Object.create(null);
      found.forEach(function(p, i) {
        p = self2._makeAbs(p);
        rp.realpath(p, self2.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self2.emit("error", er);
          if (--n === 0) {
            self2.matches[index4] = set;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq.length; i++) {
            var e = eq[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index4, inGlobStar, cb) {
      assert(this instanceof Glob);
      assert(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index4, inGlobStar, cb]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index4, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === "string" ? p : "[*]";
      }).join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return cb();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index4, inGlobStar, cb);
      else
        this._processReaddir(prefix, read, abs, remain, index4, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read, abs, remain, index4, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        return self2._processReaddir2(prefix, read, abs, remain, index4, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index4, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index4])
          this.matches[index4] = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index4, e);
        }
        return cb();
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index4, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index4, e) {
      if (this.aborted)
        return;
      if (isIgnored(this, e))
        return;
      if (this.paused) {
        this._emitQueue.push([index4, e]);
        return;
      }
      var abs = isAbsolute(e) ? e : this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute)
        e = abs;
      if (this.matches[index4][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index4][e] = true;
      var st = this.statCache[abs];
      if (st)
        this.emit("stat", e, st);
      this.emit("match", e);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb);
      var lstatkey = "lstat\0" + abs;
      var self2 = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        self2.fs.lstat(abs, lstatcb);
      function lstatcb_(er, lstat) {
        if (er && er.code === "ENOENT")
          return cb();
        var isSym = lstat && lstat.isSymbolicLink();
        self2.symlinks[abs] = isSym;
        if (!isSym && lstat && !lstat.isDirectory()) {
          self2.cache[abs] = "FILE";
          cb();
        } else
          self2._readdir(abs, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return cb();
        if (Array.isArray(c))
          return cb(null, c);
      }
      var self2 = this;
      self2.fs.readdir(abs, readdirCb(this, abs, cb));
    };
    function readdirCb(self2, abs, cb) {
      return function(er, entries) {
        if (er)
          self2._readdirError(abs, er, cb);
        else
          self2._readdirEntries(abs, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f, er, cb) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            this.emit("error", error);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index4, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        self2._processGlobStar2(prefix, read, abs, remain, index4, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index4, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index4, false, cb);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index4, true, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index4, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index4, cb) {
      var self2 = this;
      this._stat(prefix, function(er, exists) {
        self2._processSimple2(prefix, index4, er, exists, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index4, er, exists, cb) {
      if (!this.matches[index4])
        this.matches[index4] = /* @__PURE__ */ Object.create(null);
      if (!exists)
        return cb();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index4, prefix);
      cb();
    };
    Glob.prototype._stat = function(f, cb) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb(null, c);
        if (needDir && c === "FILE")
          return cb();
      }
      var exists;
      var stat = this.statCache[abs];
      if (stat !== void 0) {
        if (stat === false)
          return cb(null, stat);
        else {
          var type = stat.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat);
        }
      }
      var self2 = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        self2.fs.lstat(abs, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return self2.fs.stat(abs, function(er2, stat2) {
            if (er2)
              self2._stat2(f, abs, null, lstat, cb);
            else
              self2._stat2(f, abs, er2, stat2, cb);
          });
        } else {
          self2._stat2(f, abs, er, lstat, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
      if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
        this.statCache[abs] = false;
        return cb();
      }
      var needDir = f.slice(-1) === "/";
      this.statCache[abs] = stat;
      if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
        return cb(null, false, stat);
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return cb();
      return cb(null, c, stat);
    };
  }
});

// src/serializer/index.ts
var glob;
var init_serializer = __esm({
  "src/serializer/index.ts"() {
    glob = __toESM(require_glob());
    init_source();
  }
});

// src/utils.ts
var utils_exports = {};
__export(utils_exports, {
  assertV1OutFolder: () => assertV1OutFolder,
  columnRenameKey: () => columnRenameKey,
  dryJournal: () => dryJournal,
  kloudMeta: () => kloudMeta,
  mapValues: () => mapValues,
  prepareMigrationFolder: () => prepareMigrationFolder,
  prepareMigrationMeta: () => prepareMigrationMeta,
  prepareOutFolder: () => prepareOutFolder2,
  schemaRenameKey: () => schemaRenameKey,
  snapshotsPriorV4: () => snapshotsPriorV4,
  statementsForDiffs: () => statementsForDiffs,
  tableRenameKey: () => tableRenameKey,
  validateWithReport: () => validateWithReport
});
module.exports = __toCommonJS(utils_exports);
var import_fs = require("fs");
init_views();

// src/global.ts
var originUUID = "00000000-0000-0000-0000-000000000000";
var snapshotVersion = "5";

// src/serializer/mysqlSchema.ts
init_lib();
var index = objectType({
  name: stringType(),
  columns: stringType().array(),
  isUnique: booleanType(),
  using: enumType(["btree", "hash"]).optional(),
  algorithm: enumType(["default", "inplace", "copy"]).optional(),
  lock: enumType(["default", "none", "shared", "exclusive"]).optional()
}).strict();
var fk = objectType({
  name: stringType(),
  tableFrom: stringType(),
  columnsFrom: stringType().array(),
  tableTo: stringType(),
  columnsTo: stringType().array(),
  onUpdate: stringType().optional(),
  onDelete: stringType().optional()
}).strict();
var column = objectType({
  name: stringType(),
  type: stringType(),
  primaryKey: booleanType(),
  notNull: booleanType(),
  autoincrement: booleanType().optional(),
  default: anyType().optional(),
  onUpdate: anyType().optional()
}).strict();
var tableV3 = objectType({
  name: stringType(),
  columns: recordType(stringType(), column),
  indexes: recordType(stringType(), index),
  foreignKeys: recordType(stringType(), fk)
}).strict();
var compositePK = objectType({
  name: stringType(),
  columns: stringType().array()
}).strict();
var uniqueConstraint = objectType({
  name: stringType(),
  columns: stringType().array()
}).strict();
var tableV4 = objectType({
  name: stringType(),
  schema: stringType().optional(),
  columns: recordType(stringType(), column),
  indexes: recordType(stringType(), index),
  foreignKeys: recordType(stringType(), fk)
}).strict();
var table = objectType({
  name: stringType(),
  schema: stringType().optional(),
  columns: recordType(stringType(), column),
  indexes: recordType(stringType(), index),
  foreignKeys: recordType(stringType(), fk),
  compositePrimaryKeys: recordType(stringType(), compositePK),
  uniqueConstraints: recordType(stringType(), uniqueConstraint).default({})
}).strict();
var dialect = literalType("mysql");
var schemaHash = objectType({
  id: stringType(),
  prevId: stringType()
});
var schemaInternalV3 = objectType({
  version: literalType("3"),
  dialect,
  tables: recordType(stringType(), tableV3)
}).strict();
var schemaInternalV4 = objectType({
  version: literalType("4"),
  dialect,
  tables: recordType(stringType(), tableV4),
  schemas: recordType(stringType(), stringType())
}).strict();
var kitInternals = objectType({
  tables: recordType(
    stringType(),
    objectType({
      columns: recordType(
        stringType(),
        objectType({ isDefaultAnExpression: booleanType().optional() }).optional()
      )
    }).optional()
  )
}).optional();
var schemaInternal = objectType({
  version: literalType("5"),
  dialect,
  tables: recordType(stringType(), table),
  schemas: recordType(stringType(), stringType()),
  _meta: objectType({
    schemas: recordType(stringType(), stringType()),
    tables: recordType(stringType(), stringType()),
    columns: recordType(stringType(), stringType())
  }),
  internal: kitInternals
}).strict();
var schemaV3 = schemaInternalV3.merge(schemaHash);
var schemaV4 = schemaInternalV4.merge(schemaHash);
var schema = schemaInternal.merge(schemaHash);
var tableSquashedV4 = objectType({
  name: stringType(),
  schema: stringType().optional(),
  columns: recordType(stringType(), column),
  indexes: recordType(stringType(), stringType()),
  foreignKeys: recordType(stringType(), stringType())
}).strict();
var tableSquashed = objectType({
  name: stringType(),
  schema: stringType().optional(),
  columns: recordType(stringType(), column),
  indexes: recordType(stringType(), stringType()),
  foreignKeys: recordType(stringType(), stringType()),
  compositePrimaryKeys: recordType(stringType(), stringType()),
  uniqueConstraints: recordType(stringType(), stringType()).default({})
}).strict();
var schemaSquashed = objectType({
  version: literalType("5"),
  dialect,
  tables: recordType(stringType(), tableSquashed),
  schemas: recordType(stringType(), stringType())
}).strict();
var schemaSquashedV4 = objectType({
  version: literalType("4"),
  dialect,
  tables: recordType(stringType(), tableSquashedV4),
  schemas: recordType(stringType(), stringType())
}).strict();
var MySqlSquasher = {
  squashIdx: (idx) => {
    index.parse(idx);
    return `${idx.name};${idx.columns.join(",")};${idx.isUnique};${idx.using ?? ""};${idx.algorithm ?? ""};${idx.lock ?? ""}`;
  },
  unsquashIdx: (input) => {
    const [name, columnsString, isUnique, using, algorithm, lock] = input.split(";");
    const destructed = {
      name,
      columns: columnsString.split(","),
      isUnique: isUnique === "true",
      using: using ? using : void 0,
      algorithm: algorithm ? algorithm : void 0,
      lock: lock ? lock : void 0
    };
    return index.parse(destructed);
  },
  squashPK: (pk) => {
    return `${pk.name};${pk.columns.join(",")}`;
  },
  unsquashPK: (pk) => {
    const splitted = pk.split(";");
    return { name: splitted[0], columns: splitted[1].split(",") };
  },
  squashUnique: (unq) => {
    return `${unq.name};${unq.columns.join(",")}`;
  },
  unsquashUnique: (unq) => {
    const [name, columns] = unq.split(";");
    return { name, columns: columns.split(",") };
  },
  squashFK: (fk4) => {
    return `${fk4.name};${fk4.tableFrom};${fk4.columnsFrom.join(",")};${fk4.tableTo};${fk4.columnsTo.join(",")};${fk4.onUpdate ?? ""};${fk4.onDelete ?? ""}`;
  },
  unsquashFK: (input) => {
    const [
      name,
      tableFrom,
      columnsFromStr,
      tableTo,
      columnsToStr,
      onUpdate,
      onDelete
    ] = input.split(";");
    const result = fk.parse({
      name,
      tableFrom,
      columnsFrom: columnsFromStr.split(","),
      tableTo,
      columnsTo: columnsToStr.split(","),
      onUpdate,
      onDelete
    });
    return result;
  }
};
var mysqlSchema = schema;
var backwardCompatibleMysqlSchema = unionType([
  schemaV3,
  schemaV4,
  schema
]);
var dryMySql = mysqlSchema.parse({
  version: snapshotVersion,
  dialect: "mysql",
  id: originUUID,
  prevId: "",
  tables: {},
  schemas: {},
  _meta: {
    schemas: {},
    tables: {},
    columns: {}
  }
});

// src/serializer/pgSchema.ts
init_lib();
var indexV2 = objectType({
  name: stringType(),
  columns: recordType(
    stringType(),
    objectType({
      name: stringType()
    })
  ),
  isUnique: booleanType()
}).strict();
var columnV2 = objectType({
  name: stringType(),
  type: stringType(),
  primaryKey: booleanType(),
  notNull: booleanType(),
  default: anyType().optional(),
  references: stringType().optional()
}).strict();
var tableV2 = objectType({
  name: stringType(),
  columns: recordType(stringType(), columnV2),
  indexes: recordType(stringType(), indexV2)
}).strict();
var enumSchema = objectType({
  name: stringType(),
  values: recordType(stringType(), stringType())
}).strict();
var pgSchemaV2 = objectType({
  version: literalType("2"),
  tables: recordType(stringType(), tableV2),
  enums: recordType(stringType(), enumSchema)
}).strict();
var references = objectType({
  foreignKeyName: stringType(),
  table: stringType(),
  column: stringType(),
  onDelete: stringType().optional(),
  onUpdate: stringType().optional()
}).strict();
var columnV1 = objectType({
  name: stringType(),
  type: stringType(),
  primaryKey: booleanType(),
  notNull: booleanType(),
  default: anyType().optional(),
  references: references.optional()
}).strict();
var tableV1 = objectType({
  name: stringType(),
  columns: recordType(stringType(), columnV1),
  indexes: recordType(stringType(), indexV2)
}).strict();
var pgSchemaV1 = objectType({
  version: literalType("1"),
  tables: recordType(stringType(), tableV1),
  enums: recordType(stringType(), enumSchema)
}).strict();
var index2 = objectType({
  name: stringType(),
  columns: stringType().array(),
  isUnique: booleanType()
}).strict();
var fk2 = objectType({
  name: stringType(),
  tableFrom: stringType(),
  columnsFrom: stringType().array(),
  tableTo: stringType(),
  columnsTo: stringType().array(),
  onUpdate: stringType().optional(),
  onDelete: stringType().optional()
}).strict();
var column2 = objectType({
  name: stringType(),
  type: stringType(),
  primaryKey: booleanType(),
  notNull: booleanType(),
  default: anyType().optional(),
  isUnique: anyType().optional(),
  uniqueName: stringType().optional(),
  nullsNotDistinct: booleanType().optional()
}).strict();
var tableV32 = objectType({
  name: stringType(),
  columns: recordType(stringType(), column2),
  indexes: recordType(stringType(), index2),
  foreignKeys: recordType(stringType(), fk2)
}).strict();
var compositePK2 = objectType({
  name: stringType(),
  columns: stringType().array()
}).strict();
var uniqueConstraint2 = objectType({
  name: stringType(),
  columns: stringType().array(),
  nullsNotDistinct: booleanType()
}).strict();
var tableV42 = objectType({
  name: stringType(),
  schema: stringType(),
  columns: recordType(stringType(), column2),
  indexes: recordType(stringType(), index2),
  foreignKeys: recordType(stringType(), fk2)
}).strict();
var table2 = objectType({
  name: stringType(),
  schema: stringType(),
  columns: recordType(stringType(), column2),
  indexes: recordType(stringType(), index2),
  foreignKeys: recordType(stringType(), fk2),
  compositePrimaryKeys: recordType(stringType(), compositePK2),
  uniqueConstraints: recordType(stringType(), uniqueConstraint2).default({})
}).strict();
var schemaHash2 = objectType({
  id: stringType(),
  prevId: stringType()
});
var pgSchemaInternalV3 = objectType({
  version: literalType("3"),
  dialect: literalType("pg"),
  tables: recordType(stringType(), tableV32),
  enums: recordType(stringType(), enumSchema)
}).strict();
var pgSchemaInternalV4 = objectType({
  version: literalType("4"),
  dialect: literalType("pg"),
  tables: recordType(stringType(), tableV42),
  enums: recordType(stringType(), enumSchema),
  schemas: recordType(stringType(), stringType())
}).strict();
var pgSchemaExternal = objectType({
  version: literalType("5"),
  dialect: literalType("pg"),
  tables: arrayType(table2),
  enums: arrayType(enumSchema),
  schemas: arrayType(objectType({ name: stringType() })),
  _meta: objectType({
    schemas: recordType(stringType(), stringType()),
    tables: recordType(stringType(), stringType()),
    columns: recordType(stringType(), stringType())
  })
}).strict();
var pgSchemaInternal = objectType({
  version: literalType("5"),
  dialect: literalType("pg"),
  tables: recordType(stringType(), table2),
  enums: recordType(stringType(), enumSchema),
  schemas: recordType(stringType(), stringType()),
  _meta: objectType({
    schemas: recordType(stringType(), stringType()),
    tables: recordType(stringType(), stringType()),
    columns: recordType(stringType(), stringType())
  })
}).strict();
var tableSquashed2 = objectType({
  name: stringType(),
  schema: stringType(),
  columns: recordType(stringType(), column2),
  indexes: recordType(stringType(), stringType()),
  foreignKeys: recordType(stringType(), stringType()),
  compositePrimaryKeys: recordType(stringType(), stringType()),
  uniqueConstraints: recordType(stringType(), stringType())
}).strict();
var tableSquashedV42 = objectType({
  name: stringType(),
  schema: stringType(),
  columns: recordType(stringType(), column2),
  indexes: recordType(stringType(), stringType()),
  foreignKeys: recordType(stringType(), stringType())
}).strict();
var pgSchemaSquashedV4 = objectType({
  version: literalType("4"),
  dialect: enumType(["pg"]),
  tables: recordType(stringType(), tableSquashedV42),
  enums: recordType(stringType(), enumSchema),
  schemas: recordType(stringType(), stringType())
}).strict();
var pgSchemaSquashed = objectType({
  version: literalType("5"),
  dialect: enumType(["pg"]),
  tables: recordType(stringType(), tableSquashed2),
  enums: recordType(stringType(), enumSchema),
  schemas: recordType(stringType(), stringType())
}).strict();
var pgSchemaV3 = pgSchemaInternalV3.merge(schemaHash2);
var pgSchemaV4 = pgSchemaInternalV4.merge(schemaHash2);
var pgSchema = pgSchemaInternal.merge(schemaHash2);
var backwardCompatiblePgSchema = unionType([
  pgSchemaV1,
  pgSchemaV2,
  pgSchemaV3,
  pgSchemaV4,
  pgSchema
]);
var PgSquasher = {
  squashIdx: (idx) => {
    index2.parse(idx);
    return `${idx.name};${idx.columns.join(",")};${idx.isUnique}`;
  },
  unsquashIdx: (input) => {
    const [name, columnsString, isUnique] = input.split(";");
    const result = index2.parse({
      name,
      columns: columnsString.split(","),
      isUnique: isUnique === "true"
    });
    return result;
  },
  squashFK: (fk4) => {
    return `${fk4.name};${fk4.tableFrom};${fk4.columnsFrom.join(",")};${fk4.tableTo};${fk4.columnsTo.join(",")};${fk4.onUpdate ?? ""};${fk4.onDelete ?? ""}`;
  },
  squashPK: (pk) => {
    return `${pk.columns.join(",")}`;
  },
  unsquashPK: (pk) => {
    return { name: "", columns: pk.split(",") };
  },
  squashUnique: (unq) => {
    return `${unq.name};${unq.columns.join(",")};${unq.nullsNotDistinct}`;
  },
  unsquashUnique: (unq) => {
    const [
      name,
      columns,
      nullsNotDistinct
    ] = unq.split(";");
    return { name, columns: columns.split(","), nullsNotDistinct: nullsNotDistinct === "true" };
  },
  unsquashFK: (input) => {
    const [
      name,
      tableFrom,
      columnsFromStr,
      tableTo,
      columnsToStr,
      onUpdate,
      onDelete
    ] = input.split(";");
    const result = fk2.parse({
      name,
      tableFrom,
      columnsFrom: columnsFromStr.split(","),
      tableTo,
      columnsTo: columnsToStr.split(","),
      onUpdate,
      onDelete
    });
    return result;
  }
};
var squashPgScheme = (json) => {
  const mappedTables = Object.fromEntries(
    Object.entries(json.tables).map((it) => {
      const squashedIndexes = mapValues(it[1].indexes, (index4) => {
        return PgSquasher.squashIdx(index4);
      });
      const squashedFKs = mapValues(it[1].foreignKeys, (fk4) => {
        return PgSquasher.squashFK(fk4);
      });
      const squashedPKs = mapValues(it[1].compositePrimaryKeys, (pk) => {
        return PgSquasher.squashPK(pk);
      });
      const squashedUniqueConstraints = mapValues(it[1].uniqueConstraints, (unq) => {
        return PgSquasher.squashUnique(unq);
      });
      return [
        it[0],
        {
          name: it[1].name,
          schema: it[1].schema,
          columns: it[1].columns,
          indexes: squashedIndexes,
          foreignKeys: squashedFKs,
          compositePrimaryKeys: squashedPKs,
          uniqueConstraints: squashedUniqueConstraints
        }
      ];
    })
  );
  return {
    version: "5",
    dialect: json.dialect,
    tables: mappedTables,
    enums: json.enums,
    schemas: json.schemas
  };
};
var dryPg = pgSchema.parse({
  version: snapshotVersion,
  dialect: "pg",
  id: originUUID,
  prevId: "",
  tables: {},
  enums: {},
  schemas: {},
  _meta: {
    schemas: {},
    tables: {},
    columns: {}
  }
});

// src/serializer/sqliteSchema.ts
init_lib();
var index3 = objectType({
  name: stringType(),
  columns: stringType().array(),
  where: stringType().optional(),
  isUnique: booleanType()
}).strict();
var fk3 = objectType({
  name: stringType(),
  tableFrom: stringType(),
  columnsFrom: stringType().array(),
  tableTo: stringType(),
  columnsTo: stringType().array(),
  onUpdate: stringType().optional(),
  onDelete: stringType().optional()
}).strict();
var compositePK3 = objectType({
  columns: stringType().array()
}).strict();
var column3 = objectType({
  name: stringType(),
  type: stringType(),
  primaryKey: booleanType(),
  notNull: booleanType(),
  autoincrement: booleanType().optional(),
  default: anyType().optional()
}).strict();
var tableV33 = objectType({
  name: stringType(),
  columns: recordType(stringType(), column3),
  indexes: recordType(stringType(), index3),
  foreignKeys: recordType(stringType(), fk3)
}).strict();
var uniqueConstraint3 = objectType({
  name: stringType(),
  columns: stringType().array()
}).strict();
var table3 = objectType({
  name: stringType(),
  columns: recordType(stringType(), column3),
  indexes: recordType(stringType(), index3),
  foreignKeys: recordType(stringType(), fk3),
  compositePrimaryKeys: recordType(stringType(), compositePK3),
  uniqueConstraints: recordType(stringType(), uniqueConstraint3).default({})
}).strict();
var dialect2 = enumType(["sqlite"]);
var schemaHash3 = objectType({
  id: stringType(),
  prevId: stringType()
}).strict();
var schemaInternalV32 = objectType({
  version: literalType("3"),
  dialect: dialect2,
  tables: recordType(stringType(), tableV33),
  enums: objectType({})
}).strict();
var schemaInternalV42 = objectType({
  version: literalType("4"),
  dialect: dialect2,
  tables: recordType(stringType(), table3),
  enums: objectType({})
}).strict();
var latestVersion = literalType("5");
var schemaInternal2 = objectType({
  version: latestVersion,
  dialect: dialect2,
  tables: recordType(stringType(), table3),
  enums: objectType({}),
  _meta: objectType({
    tables: recordType(stringType(), stringType()),
    columns: recordType(stringType(), stringType())
  })
}).strict();
var schemaV32 = schemaInternalV32.merge(schemaHash3).strict();
var schemaV42 = schemaInternalV42.merge(schemaHash3).strict();
var schema2 = schemaInternal2.merge(schemaHash3).strict();
var tableSquashed3 = objectType({
  name: stringType(),
  columns: recordType(stringType(), column3),
  indexes: recordType(stringType(), stringType()),
  foreignKeys: recordType(stringType(), stringType()),
  compositePrimaryKeys: recordType(stringType(), stringType()),
  uniqueConstraints: recordType(stringType(), stringType()).default({})
}).strict();
var schemaSquashed2 = objectType({
  version: latestVersion,
  dialect: dialect2,
  tables: recordType(stringType(), tableSquashed3),
  enums: anyType()
}).strict();
var SQLiteSquasher = {
  squashIdx: (idx) => {
    index3.parse(idx);
    return `${idx.name};${idx.columns.join(",")};${idx.isUnique};${idx.where ?? ""}`;
  },
  unsquashIdx: (input) => {
    const [name, columnsString, isUnique, where] = input.split(";");
    const result = index3.parse({
      name,
      columns: columnsString.split(","),
      isUnique: isUnique === "true",
      where: where ?? void 0
    });
    return result;
  },
  squashUnique: (unq) => {
    return `${unq.name};${unq.columns.join(",")}`;
  },
  unsquashUnique: (unq) => {
    const [name, columns] = unq.split(";");
    return { name, columns: columns.split(",") };
  },
  squashFK: (fk4) => {
    return `${fk4.name};${fk4.tableFrom};${fk4.columnsFrom.join(",")};${fk4.tableTo};${fk4.columnsTo.join(",")};${fk4.onUpdate ?? ""};${fk4.onDelete ?? ""}`;
  },
  unsquashFK: (input) => {
    const [
      name,
      tableFrom,
      columnsFromStr,
      tableTo,
      columnsToStr,
      onUpdate,
      onDelete
    ] = input.split(";");
    const result = fk3.parse({
      name,
      tableFrom,
      columnsFrom: columnsFromStr.split(","),
      tableTo,
      columnsTo: columnsToStr.split(","),
      onUpdate,
      onDelete
    });
    return result;
  },
  squashPK: (pk) => {
    return pk.columns.join(",");
  },
  unsquashPK: (pk) => {
    return pk.split(",");
  }
};
var drySQLite = schema2.parse({
  version: snapshotVersion,
  dialect: "sqlite",
  id: originUUID,
  prevId: "",
  tables: {},
  enums: {},
  _meta: {
    tables: {},
    columns: {}
  }
});
var backwardCompatibleSqliteSchema = unionType([schemaV32, schemaV42, schema2]);

// src/utils.ts
init_source();
var import_path = require("path");

// src/jsonDiffer.js
var import_json_diff = __toESM(require_lib());
function diffForRenamedTables(pairs) {
  const renamed = pairs.map((it) => {
    const from = it.from;
    const to = it.to;
    const newFrom = { ...from, name: to.name };
    return [newFrom, to];
  });
  const altered = renamed.map((pair) => {
    return diffForRenamedTable(pair[0], pair[1]);
  });
  return altered;
}
function diffForRenamedTable(t1, t2) {
  t1.name = t2.name;
  const diffed = (0, import_json_diff.diff)(t1, t2) || {};
  diffed.name = t2.name;
  return findAlternationsInTable(diffed, t2.schema);
}
function diffForRenamedColumn(t1, t2) {
  const renamed = { ...t1, name: t2.name };
  const diffed = (0, import_json_diff.diff)(renamed, t2) || {};
  diffed.name = t2.name;
  return alternationsInColumn(diffed);
}
function applyJsonDiff(json1, json2) {
  json1 = JSON.parse(JSON.stringify(json1));
  json2 = JSON.parse(JSON.stringify(json2));
  const rawDiff = (0, import_json_diff.diff)(json1, json2);
  const difference = rawDiff;
  const tableToSchema = Object.entries(json2.tables).reduce((res, it) => {
    res[it[0]] = it[1].schema;
    return res;
  }, {});
  if (!difference)
    return {};
  difference.tables = difference.tables ?? {};
  difference.enums = difference.enums ?? {};
  difference.schemas = difference.schemas ?? {};
  const tableEntries = Object.entries(difference.tables);
  const addedTables = tableEntries.filter((it) => it[0].includes("__added")).map((it) => it[1]);
  const deletedTables = tableEntries.filter((it) => it[0].includes("__deleted")).map((it) => it[1]);
  const enumsEntries = Object.entries(difference.enums);
  const addedEnums = enumsEntries.filter((it) => it[0].includes("__added")).map((it) => it[1]).map((it) => {
    const values = Object.entries(it.values).map((ve) => ve[1]);
    return { name: it.name, values };
  });
  const deletedEnums = enumsEntries.filter((it) => it[0].includes("__deleted")).map((it) => it[1]).map((it) => {
    const values = Object.entries(it.values).map((ve) => ve[1]);
    return { name: it.name, values };
  });
  const alteredEnums = enumsEntries.filter((it) => !(it[0].includes("__added") || it[0].includes("__deleted"))).map((it) => {
    const vals = it[1].values;
    const addedValues = Object.entries(vals).filter((val) => val[0].includes("__added")).map((val) => val[1]);
    const deletedValues = Object.entries(vals).filter((val) => val[0].includes("__deleted")).map((val) => val[1]);
    return { name: it[0], addedValues, deletedValues };
  });
  const alteredTables = Object.keys(difference.tables).filter((it) => !(it.includes("__added") || it.includes("__deleted"))).map((it) => {
    return { name: it, ...difference.tables[it] };
  });
  const schemasEntries = Object.entries(difference.schemas);
  const addedSchemas = schemasEntries.filter((it) => it[0].endsWith("__added")).map((it) => it[1]);
  const deletedSchemas = schemasEntries.filter((it) => it[0].endsWith("__deleted")).map((it) => it[1]);
  const alteredTablesWithColumns = alteredTables.map((table4) => findAlternationsInTable(table4, tableToSchema[table4.name]));
  return {
    addedTables,
    deletedTables,
    alteredTablesWithColumns,
    addedEnums,
    deletedEnums,
    alteredEnums,
    addedSchemas,
    deletedSchemas
  };
}
var findAlternationsInTable = (table4, tableSchema) => {
  const columns = table4.columns ?? {};
  let schema4 = {
    type: "none",
    value: tableSchema
  };
  if ("schema" in table4) {
    if (table4.schema.__new) {
      schema4 = { type: "changed", old: table4.schema.__old, new: table4.schema.__new };
    } else {
      schema4 = { type: "deleted", value: table4.schema.__old };
    }
  }
  if ("schema__added" in table4) {
    schema4 = { type: "added", value: table4.schema__added };
  }
  if ("schema__deleted" in table4) {
    schema4 = { type: "deleted", value: table4.schema__deleted };
  }
  const added = Object.keys(columns).filter((it) => it.includes("__added")).map((it) => {
    return { ...columns[it] };
  });
  const deleted = Object.keys(columns).filter((it) => it.includes("__deleted")).map((it) => {
    return { ...columns[it] };
  });
  const altered = Object.keys(columns).filter((it) => !(it.includes("__deleted") || it.includes("__added"))).map((it) => {
    return { name: it, ...columns[it] };
  });
  const deletedIndexes = Object.fromEntries(
    Object.entries(table4.indexes__deleted || {}).concat(Object.entries(table4.indexes || {}).filter((it) => it[0].includes("__deleted"))).map((entry) => [entry[0].replace("__deleted", ""), entry[1]])
  );
  const addedIndexes = Object.fromEntries(
    Object.entries(table4.indexes__added || {}).concat(Object.entries(table4.indexes || {}).filter((it) => it[0].includes("__added"))).map((entry) => [entry[0].replace("__added", ""), entry[1]])
  );
  const alteredIndexes = Object.fromEntries(Object.entries(table4.indexes || {}).filter((it) => {
    return !it[0].endsWith("__deleted") && !it[0].endsWith("__added");
  }));
  const deletedForeignKeys = Object.fromEntries(
    Object.entries(table4.foreignKeys__deleted || {}).concat(Object.entries(table4.foreignKeys || {}).filter((it) => it[0].includes("__deleted"))).map((entry) => [entry[0].replace("__deleted", ""), entry[1]])
  );
  const addedForeignKeys = Object.fromEntries(
    Object.entries(table4.foreignKeys__added || {}).concat(Object.entries(table4.foreignKeys || {}).filter((it) => it[0].includes("__added"))).map((entry) => [entry[0].replace("__added", ""), entry[1]])
  );
  const alteredForeignKeys = Object.fromEntries(Object.entries(table4.foreignKeys || {}).filter((it) => !it[0].endsWith("__added") && !it[0].endsWith("__deleted")).map((entry) => [entry[0], entry[1]]));
  const addedCompositePKs = Object.fromEntries(Object.entries(table4.compositePrimaryKeys || {}).filter((it) => {
    return it[0].endsWith("__added");
  }));
  const deletedCompositePKs = Object.fromEntries(Object.entries(table4.compositePrimaryKeys || {}).filter((it) => {
    return it[0].endsWith("__deleted");
  }));
  const alteredCompositePKs = Object.fromEntries(Object.entries(table4.compositePrimaryKeys || {}).filter((it) => {
    return !it[0].endsWith("__deleted") && !it[0].endsWith("__added");
  }));
  const addedUniqueConstraints = Object.fromEntries(Object.entries(table4.uniqueConstraints || {}).filter((it) => {
    return it[0].endsWith("__added");
  }));
  const deletedUniqueConstraints = Object.fromEntries(Object.entries(table4.uniqueConstraints || {}).filter((it) => {
    return it[0].endsWith("__deleted");
  }));
  const alteredUniqueConstraints = Object.fromEntries(Object.entries(table4.uniqueConstraints || {}).filter((it) => {
    return !it[0].endsWith("__deleted") && !it[0].endsWith("__added");
  }));
  const mappedAltered = altered.map((it) => alternationsInColumn(it));
  return {
    name: table4.name,
    schema: schema4,
    deleted,
    added,
    altered: mappedAltered,
    addedIndexes,
    deletedIndexes,
    alteredIndexes,
    addedForeignKeys,
    deletedForeignKeys,
    alteredForeignKeys,
    addedCompositePKs,
    deletedCompositePKs,
    alteredCompositePKs,
    addedUniqueConstraints,
    deletedUniqueConstraints,
    alteredUniqueConstraints
  };
};
var alternationsInColumn = (column4) => {
  const altered = [column4];
  const result = altered.map((it) => {
    if (typeof it.name !== "string" && "__old" in it.name) {
      return { ...it, name: { type: "changed", old: it.name.__old, new: it.name.__new } };
    }
    return it;
  }).map((it) => {
    if ("type" in it) {
      return { ...it, type: { type: "changed", old: it.type.__old, new: it.type.__new } };
    }
    return it;
  }).map((it) => {
    if ("default" in it) {
      return { ...it, default: { type: "changed", old: it.default.__old, new: it.default.__new } };
    }
    if ("default__added" in it) {
      const { default__added, ...others } = it;
      return { ...others, default: { type: "added", value: it.default__added } };
    }
    if ("default__deleted" in it) {
      const { default__deleted, ...others } = it;
      return { ...others, default: { type: "deleted", value: it.default__deleted } };
    }
    return it;
  }).map((it) => {
    if ("notNull" in it) {
      return { ...it, notNull: { type: "changed", old: it.notNull.__old, new: it.notNull.__new } };
    }
    if ("notNull__added" in it) {
      const { notNull__added, ...others } = it;
      return { ...others, notNull: { type: "added", value: it.notNull__added } };
    }
    if ("notNull__deleted" in it) {
      const { notNull__deleted, ...others } = it;
      return { ...others, notNull: { type: "deleted", value: it.notNull__deleted } };
    }
    return it;
  }).map((it) => {
    if ("primaryKey" in it) {
      return { ...it, primaryKey: { type: "changed", old: it.primaryKey.__old, new: it.primaryKey.__new } };
    }
    if ("primaryKey__added" in it) {
      const { notNull__added, ...others } = it;
      return { ...others, primaryKey: { type: "added", value: it.primaryKey__added } };
    }
    if ("primaryKey__deleted" in it) {
      const { notNull__deleted, ...others } = it;
      return { ...others, primaryKey: { type: "deleted", value: it.primaryKey__deleted } };
    }
    return it;
  }).map((it) => {
    if ("onUpdate" in it) {
      return { ...it, onUpdate: { type: "changed", old: it.onUpdate.__old, new: it.onUpdate.__new } };
    }
    if ("onUpdate__added" in it) {
      const { onUpdate__added, ...others } = it;
      return { ...others, onUpdate: { type: "added", value: it.onUpdate__added } };
    }
    if ("onUpdate__deleted" in it) {
      const { onUpdate__deleted, ...others } = it;
      return { ...others, onUpdate: { type: "deleted", value: it.onUpdate__deleted } };
    }
    return it;
  }).map((it) => {
    if ("autoincrement" in it) {
      return { ...it, autoincrement: { type: "changed", old: it.autoincrement.__old, new: it.autoincrement.__new } };
    }
    if ("autoincrement__added" in it) {
      const { autoincrement__added, ...others } = it;
      return { ...others, autoincrement: { type: "added", value: it.autoincrement__added } };
    }
    if ("autoincrement__deleted" in it) {
      const { autoincrement__deleted, ...others } = it;
      return { ...others, autoincrement: { type: "deleted", value: it.autoincrement__deleted } };
    }
    return it;
  });
  return result[0];
};

// src/migrationPreparator.ts
init_serializer();

// src/cli/commands/migrate.ts
var import_hanji2 = __toESM(require_hanji());
init_views();
init_source();
var BREAKPOINT = "--> statement-breakpoint\n";

// src/sqlgenerator.ts
var pgNativeTypes = /* @__PURE__ */ new Set([
  "uuid",
  "smallint",
  "integer",
  "bigint",
  "boolean",
  "text",
  "varchar",
  "serial",
  "bigserial",
  "decimal",
  "numeric",
  "real",
  "json",
  "jsonb",
  "time",
  "time with time zone",
  "time without time zone",
  "time",
  "timestamp",
  "timestamp with time zone",
  "timestamp without time zone",
  "date",
  "interval",
  "bigint",
  "bigserial",
  "double precision",
  "interval year",
  "interval month",
  "interval day",
  "interval hour",
  "interval minute",
  "interval second",
  "interval year to month",
  "interval day to hour",
  "interval day to minute",
  "interval day to second",
  "interval hour to minute",
  "interval hour to second",
  "interval minute to second"
]);
var isPgNativeType = (it) => {
  if (pgNativeTypes.has(it))
    return true;
  const toCheck = it.replace(/ /g, "");
  return toCheck.startsWith("varchar(") || toCheck.startsWith("char(") || toCheck.startsWith("numeric(") || toCheck.startsWith("timestamp(") || toCheck.startsWith("intervalyear(") || toCheck.startsWith("intervalmonth(") || toCheck.startsWith("intervalday(") || toCheck.startsWith("intervalhour(") || toCheck.startsWith("intervalminute(") || toCheck.startsWith("intervalsecond(") || toCheck.startsWith("intervalyeartomonth(") || toCheck.startsWith("intervaldaytohour(") || toCheck.startsWith("intervaldaytominute(") || toCheck.startsWith("intervaldaytosecond(") || toCheck.startsWith("intervalhourtominute(") || toCheck.startsWith("intervalhourtosecond(") || toCheck.startsWith("intervalminutetosecond(") || /^(\w+)(\[\d*])+$/.test(it);
};
var Convertor = class {
};
var PgCreateTableConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "create_table" && dialect3 === "pg";
  }
  convert(st) {
    const { tableName, schema: schema4, columns, compositePKs, uniqueConstraints } = st;
    let statement = "";
    const name = schema4 ? `"${schema4}"."${tableName}"` : `"${tableName}"`;
    statement += `CREATE TABLE IF NOT EXISTS ${name} (
`;
    for (let i = 0; i < columns.length; i++) {
      const column4 = columns[i];
      const primaryKeyStatement = column4.primaryKey ? " PRIMARY KEY" : "";
      const notNullStatement = column4.notNull ? " NOT NULL" : "";
      const defaultStatement = column4.default !== void 0 ? ` DEFAULT ${column4.default}` : "";
      const uniqueConstraint4 = column4.isUnique ? ` CONSTRAINT "${column4.uniqueName}" UNIQUE${column4.nullsNotDistinct ? " NULLS NOT DISTINCT" : ""}` : "";
      const type = isPgNativeType(column4.type) ? column4.type : `"${column4.type}"`;
      statement += `	"${column4.name}" ${type}${primaryKeyStatement}${defaultStatement}${notNullStatement}${uniqueConstraint4}`;
      statement += i === columns.length - 1 ? "" : ",\n";
    }
    if (typeof compositePKs !== "undefined" && compositePKs.length > 0) {
      statement += ",\n";
      const compositePK4 = PgSquasher.unsquashPK(compositePKs[0]);
      statement += `	CONSTRAINT ${st.compositePkName} PRIMARY KEY("${compositePK4.columns.join(`","`)}")`;
    }
    if (typeof uniqueConstraints !== "undefined" && uniqueConstraints.length > 0) {
      for (const uniqueConstraint4 of uniqueConstraints) {
        statement += ",\n";
        const unsquashedUnique = PgSquasher.unsquashUnique(uniqueConstraint4);
        statement += `	CONSTRAINT "${unsquashedUnique.name}" UNIQUE${unsquashedUnique.nullsNotDistinct ? " NULLS NOT DISTINCT" : ""}("${unsquashedUnique.columns.join(`","`)}")`;
      }
    }
    statement += `
);`;
    statement += `
`;
    return statement;
  }
};
var MySqlCreateTableConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "create_table" && dialect3 === "mysql";
  }
  convert(st) {
    const { tableName, columns, schema: schema4, compositePKs, uniqueConstraints } = st;
    let statement = "";
    const tName = schema4 ? `\`${schema4}\`.\`${tableName}\`` : `\`${tableName}\``;
    statement += `CREATE TABLE ${tName} (
`;
    for (let i = 0; i < columns.length; i++) {
      const column4 = columns[i];
      const primaryKeyStatement = column4.primaryKey ? " PRIMARY KEY" : "";
      const notNullStatement = column4.notNull ? " NOT NULL" : "";
      const defaultStatement = column4.default !== void 0 ? ` DEFAULT ${column4.default}` : "";
      const onUpdateStatement = column4.onUpdate ? ` ON UPDATE CURRENT_TIMESTAMP` : "";
      const autoincrementStatement = column4.autoincrement ? " AUTO_INCREMENT" : "";
      statement += `	\`${column4.name}\` ${column4.type}${autoincrementStatement}${primaryKeyStatement}${notNullStatement}${defaultStatement}${onUpdateStatement}`;
      statement += i === columns.length - 1 ? "" : ",\n";
    }
    if (typeof compositePKs !== "undefined" && compositePKs.length > 0) {
      statement += ",\n";
      const compositePK4 = MySqlSquasher.unsquashPK(compositePKs[0]);
      statement += `	CONSTRAINT \`${st.compositePkName}\` PRIMARY KEY(\`${compositePK4.columns.join(`\`,\``)}\`)`;
    }
    if (typeof uniqueConstraints !== "undefined" && uniqueConstraints.length > 0) {
      for (const uniqueConstraint4 of uniqueConstraints) {
        statement += ",\n";
        const unsquashedUnique = MySqlSquasher.unsquashUnique(uniqueConstraint4);
        statement += `	CONSTRAINT \`${unsquashedUnique.name}\` UNIQUE(\`${unsquashedUnique.columns.join(`\`,\``)}\`)`;
      }
    }
    statement += `
);`;
    statement += `
`;
    return statement;
  }
};
var SQLiteCreateTableConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "sqlite_create_table" && dialect3 === "sqlite";
  }
  convert(st) {
    const {
      tableName,
      columns,
      referenceData,
      compositePKs,
      uniqueConstraints
    } = st;
    let statement = "";
    statement += `CREATE TABLE \`${tableName}\` (
`;
    for (let i = 0; i < columns.length; i++) {
      const column4 = columns[i];
      const primaryKeyStatement = column4.primaryKey ? " PRIMARY KEY" : "";
      const notNullStatement = column4.notNull ? " NOT NULL" : "";
      const defaultStatement = column4.default !== void 0 ? ` DEFAULT ${column4.default}` : "";
      const autoincrementStatement = column4.autoincrement ? " AUTOINCREMENT" : "";
      statement += "	";
      statement += `\`${column4.name}\` ${column4.type}${primaryKeyStatement}${autoincrementStatement}${defaultStatement}${notNullStatement}`;
      statement += i === columns.length - 1 ? "" : ",\n";
    }
    compositePKs.forEach((it) => {
      statement += ",\n	";
      statement += `PRIMARY KEY(${it.map((it2) => `\`${it2}\``).join(", ")})`;
    });
    for (let i = 0; i < referenceData.length; i++) {
      const referenceAsString = referenceData[i];
      const {
        name,
        tableFrom,
        tableTo,
        columnsFrom,
        columnsTo,
        onDelete,
        onUpdate
      } = SQLiteSquasher.unsquashFK(referenceAsString);
      const onDeleteStatement = onDelete ? ` ON DELETE ${onDelete}` : "";
      const onUpdateStatement = onUpdate ? ` ON UPDATE ${onUpdate}` : "";
      const fromColumnsString = columnsFrom.map((it) => `\`${it}\``).join(",");
      const toColumnsString = columnsTo.map((it) => `\`${it}\``).join(",");
      statement += ",";
      statement += "\n	";
      statement += `FOREIGN KEY (${fromColumnsString}) REFERENCES \`${tableTo}\`(${toColumnsString})${onUpdateStatement}${onDeleteStatement}`;
    }
    if (typeof uniqueConstraints !== "undefined" && uniqueConstraints.length > 0) {
      for (const uniqueConstraint4 of uniqueConstraints) {
        statement += ",\n";
        const unsquashedUnique = MySqlSquasher.unsquashUnique(uniqueConstraint4);
        statement += `	CONSTRAINT ${unsquashedUnique.name} UNIQUE(\`${unsquashedUnique.columns.join(`\`,\``)}\`)`;
      }
    }
    statement += `
`;
    statement += `);`;
    statement += `
`;
    return statement;
  }
};
var PgAlterTableAddUniqueConstraintConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "create_unique_constraint" && dialect3 === "pg";
  }
  convert(statement) {
    const unsquashed = PgSquasher.unsquashUnique(statement.data);
    const tableNameWithSchema = statement.schema ? `"${statement.schema}"."${statement.tableName}"` : `"${statement.tableName}"`;
    return `ALTER TABLE ${tableNameWithSchema} ADD CONSTRAINT "${unsquashed.name}" UNIQUE${unsquashed.nullsNotDistinct ? " NULLS NOT DISTINCT" : ""}("${unsquashed.columns.join('","')}");`;
  }
};
var PgAlterTableDropUniqueConstraintConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "delete_unique_constraint" && dialect3 === "pg";
  }
  convert(statement) {
    const unsquashed = PgSquasher.unsquashUnique(statement.data);
    const tableNameWithSchema = statement.schema ? `"${statement.schema}"."${statement.tableName}"` : `"${statement.tableName}"`;
    return `ALTER TABLE ${tableNameWithSchema} DROP CONSTRAINT "${unsquashed.name}";`;
  }
};
var MySQLAlterTableAddUniqueConstraintConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "create_unique_constraint" && dialect3 === "mysql";
  }
  convert(statement) {
    const unsquashed = MySqlSquasher.unsquashUnique(statement.data);
    const tableNameWithSchema = statement.schema ? `\`${statement.schema}\`.\`${statement.tableName}\`` : `\`${statement.tableName}\``;
    return `ALTER TABLE ${tableNameWithSchema} ADD CONSTRAINT \`${unsquashed.name}\` UNIQUE(\`${unsquashed.columns.join("`,`")}\`);`;
  }
};
var MySQLAlterTableDropUniqueConstraintConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "delete_unique_constraint" && dialect3 === "mysql";
  }
  convert(statement) {
    const unsquashed = MySqlSquasher.unsquashUnique(statement.data);
    const tableNameWithSchema = statement.schema ? `\`${statement.schema}\`.\`${statement.tableName}\`` : `\`${statement.tableName}\``;
    return `ALTER TABLE ${tableNameWithSchema} DROP CONSTRAINT \`${unsquashed.name}\`;`;
  }
};
var SQLiteAlterTableAddUniqueConstraintConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "create_unique_constraint" && dialect3 === "sqlite";
  }
  convert(statement) {
    return `/*
 SQLite does not support "Adding unique constraint to an existing table" out of the box, we do not generate automatic migration for that, so it has to be done manually
 Please refer to: https://www.techonthenet.com/sqlite/unique.php

 Due to that we don't generate migration automatically and it has to be done manually
*/`;
  }
};
var SQLiteAlterTableDropUniqueConstraintConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "delete_unique_constraint" && dialect3 === "sqlite";
  }
  convert(statement) {
    return `/*
 SQLite does not support "Dropping unique constraint from an existing table" out of the box, we do not generate automatic migration for that, so it has to be done manually
 Please refer to: https://www.techonthenet.com/sqlite/unique.php

 Due to that we don't generate migration automatically and it has to be done manually
*/`;
  }
};
var CreateTypeEnumConvertor = class extends Convertor {
  can(statement) {
    return statement.type === "create_type_enum";
  }
  convert(st) {
    const { name, values } = st;
    let valuesStatement = "(";
    valuesStatement += values.map((it) => `'${it}'`).join(", ");
    valuesStatement += ")";
    let statement = "DO $$ BEGIN";
    statement += "\n";
    statement += ` CREATE TYPE "${name}" AS ENUM${valuesStatement};`;
    statement += "\n";
    statement += "EXCEPTION";
    statement += "\n";
    statement += " WHEN duplicate_object THEN null;";
    statement += "\n";
    statement += "END $$;";
    statement += "\n";
    return statement;
  }
};
var AlterTypeAddValueConvertor = class extends Convertor {
  can(statement) {
    return statement.type === "alter_type_add_value";
  }
  convert(st) {
    const { name, value } = st;
    return `ALTER TYPE "${name}" ADD VALUE '${value}';`;
  }
};
var PgDropTableConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "drop_table" && dialect3 === "pg";
  }
  convert(statement) {
    const { tableName, schema: schema4 } = statement;
    const tableNameWithSchema = schema4 ? `"${schema4}"."${tableName}"` : `"${tableName}"`;
    return `DROP TABLE ${tableNameWithSchema};`;
  }
};
var MySQLDropTableConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "drop_table" && dialect3 === "mysql";
  }
  convert(statement) {
    const { tableName } = statement;
    return `DROP TABLE \`${tableName}\`;`;
  }
};
var SQLiteDropTableConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "drop_table" && dialect3 === "sqlite";
  }
  convert(statement) {
    const { tableName } = statement;
    return `DROP TABLE \`${tableName}\`;`;
  }
};
var PgRenameTableConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "rename_table" && dialect3 === "pg";
  }
  convert(statement) {
    const { tableNameFrom, tableNameTo, toSchema, fromSchema } = statement;
    const from = fromSchema ? `"${fromSchema}"."${tableNameFrom}"` : `"${tableNameFrom}"`;
    const to = `"${tableNameTo}"`;
    return `ALTER TABLE ${from} RENAME TO ${to};`;
  }
};
var SqliteRenameTableConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "rename_table" && dialect3 === "sqlite";
  }
  convert(statement) {
    const { tableNameFrom, tableNameTo } = statement;
    return `ALTER TABLE \`${tableNameFrom}\` RENAME TO \`${tableNameTo}\`;`;
  }
};
var MySqlRenameTableConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "rename_table" && dialect3 === "mysql";
  }
  convert(statement) {
    const { tableNameFrom, tableNameTo, fromSchema, toSchema } = statement;
    const from = fromSchema ? `\`${fromSchema}\`.\`${tableNameFrom}\`` : `\`${tableNameFrom}\``;
    const to = fromSchema ? `\`${fromSchema}\`.\`${tableNameTo}\`` : `\`${tableNameTo}\``;
    return `RENAME TABLE ${from} TO ${to};`;
  }
};
var PgAlterTableRenameColumnConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_rename_column" && dialect3 === "pg";
  }
  convert(statement) {
    const { tableName, oldColumnName, newColumnName, schema: schema4 } = statement;
    const tableNameWithSchema = schema4 ? `"${schema4}"."${tableName}"` : `"${tableName}"`;
    return `ALTER TABLE ${tableNameWithSchema} RENAME COLUMN "${oldColumnName}" TO "${newColumnName}";`;
  }
};
var MySqlAlterTableRenameColumnConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_rename_column" && dialect3 === "mysql";
  }
  convert(statement) {
    const { tableName, oldColumnName, newColumnName } = statement;
    return `ALTER TABLE \`${tableName}\` RENAME COLUMN \`${oldColumnName}\` TO \`${newColumnName}\`;`;
  }
};
var SQLiteAlterTableRenameColumnConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_rename_column" && dialect3 === "sqlite";
  }
  convert(statement) {
    const { tableName, oldColumnName, newColumnName } = statement;
    return `ALTER TABLE \`${tableName}\` RENAME COLUMN \`${oldColumnName}\` TO \`${newColumnName}\`;`;
  }
};
var PgAlterTableDropColumnConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_drop_column" && dialect3 === "pg";
  }
  convert(statement) {
    const { tableName, columnName, schema: schema4 } = statement;
    const tableNameWithSchema = schema4 ? `"${schema4}"."${tableName}"` : `"${tableName}"`;
    return `ALTER TABLE ${tableNameWithSchema} DROP COLUMN IF EXISTS "${columnName}";`;
  }
};
var MySqlAlterTableDropColumnConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_drop_column" && dialect3 === "mysql";
  }
  convert(statement) {
    const { tableName, columnName } = statement;
    return `ALTER TABLE \`${tableName}\` DROP COLUMN \`${columnName}\`;`;
  }
};
var SQLiteAlterTableDropColumnConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_drop_column" && dialect3 === "sqlite";
  }
  convert(statement) {
    const { tableName, columnName } = statement;
    return `ALTER TABLE \`${tableName}\` DROP COLUMN \`${columnName}\`;`;
  }
};
var PgAlterTableAddColumnConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_add_column" && dialect3 === "pg";
  }
  convert(statement) {
    const { tableName, column: column4, schema: schema4 } = statement;
    const { name, type, notNull } = column4;
    const tableNameWithSchema = schema4 ? `"${schema4}"."${tableName}"` : `"${tableName}"`;
    const defaultStatement = `${column4.default !== void 0 ? ` DEFAULT ${column4.default}` : ""}`;
    const fixedType = isPgNativeType(column4.type) ? column4.type : `"${column4.type}"`;
    const notNullStatement = `${notNull ? " NOT NULL" : ""}`;
    return `ALTER TABLE ${tableNameWithSchema} ADD COLUMN "${name}" ${fixedType}${defaultStatement}${notNullStatement};`;
  }
};
var MySqlAlterTableAddColumnConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_add_column" && dialect3 === "mysql";
  }
  convert(statement) {
    const { tableName, column: column4 } = statement;
    const { name, type, notNull, primaryKey, autoincrement, onUpdate } = column4;
    const defaultStatement = `${column4.default !== void 0 ? ` DEFAULT ${column4.default}` : ""}`;
    const notNullStatement = `${notNull ? " NOT NULL" : ""}`;
    const primaryKeyStatement = `${primaryKey ? " PRIMARY KEY" : ""}`;
    const autoincrementStatement = `${autoincrement ? " AUTO_INCREMENT" : ""}`;
    const onUpdateStatement = `${onUpdate ? " ON UPDATE CURRENT_TIMESTAMP" : ""}`;
    return `ALTER TABLE \`${tableName}\` ADD \`${name}\` ${type}${primaryKeyStatement}${autoincrementStatement}${defaultStatement}${notNullStatement}${onUpdateStatement};`;
  }
};
var SQLiteAlterTableAddColumnConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "sqlite_alter_table_add_column" && dialect3 === "sqlite";
  }
  convert(statement) {
    const { tableName, column: column4, referenceData } = statement;
    const { name, type, notNull, primaryKey } = column4;
    const defaultStatement = `${column4.default !== void 0 ? ` DEFAULT ${column4.default}` : ""}`;
    const notNullStatement = `${notNull ? " NOT NULL" : ""}`;
    const primaryKeyStatement = `${primaryKey ? " PRIMARY KEY" : ""}`;
    const referenceAsObject = referenceData ? SQLiteSquasher.unsquashFK(referenceData) : void 0;
    const referenceStatement = `${referenceAsObject ? ` REFERENCES ${referenceAsObject.tableTo}(${referenceAsObject.columnsTo})` : ""}`;
    return `ALTER TABLE ${tableName} ADD \`${name}\` ${type}${primaryKeyStatement}${defaultStatement}${notNullStatement}${referenceStatement};`;
  }
};
var PgAlterTableAlterColumnSetTypeConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_alter_column_set_type" && dialect3 === "pg";
  }
  convert(statement) {
    const { tableName, columnName, newDataType, schema: schema4 } = statement;
    const tableNameWithSchema = schema4 ? `"${schema4}"."${tableName}"` : `"${tableName}"`;
    return `ALTER TABLE ${tableNameWithSchema} ALTER COLUMN "${columnName}" SET DATA TYPE ${newDataType};`;
  }
};
var SQLiteAlterTableAlterColumnSetTypeConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_alter_column_set_type" && dialect3 === "sqlite";
  }
  convert(statement) {
    return `/*
 SQLite does not support "Changing existing column type" out of the box, we do not generate automatic migration for that, so it has to be done manually
 Please refer to: https://www.techonthenet.com/sqlite/tables/alter_table.php
                  https://www.sqlite.org/lang_altertable.html
                  https://stackoverflow.com/questions/2083543/modify-a-columns-type-in-sqlite3

 Due to that we don't generate migration automatically and it has to be done manually
*/`;
  }
};
var PgAlterTableAlterColumnSetDefaultConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_alter_column_set_default" && dialect3 === "pg";
  }
  convert(statement) {
    const { tableName, columnName, schema: schema4 } = statement;
    const tableNameWithSchema = schema4 ? `"${schema4}"."${tableName}"` : `"${tableName}"`;
    return `ALTER TABLE ${tableNameWithSchema} ALTER COLUMN "${columnName}" SET DEFAULT ${statement.newDefaultValue};`;
  }
};
var SqliteAlterTableAlterColumnSetDefaultConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_alter_column_set_default" && dialect3 === "sqlite";
  }
  convert(statement) {
    return `/*
 SQLite does not support "Set default to column" out of the box, we do not generate automatic migration for that, so it has to be done manually
 Please refer to: https://www.techonthenet.com/sqlite/tables/alter_table.php
                  https://www.sqlite.org/lang_altertable.html
                  https://stackoverflow.com/questions/2083543/modify-a-columns-type-in-sqlite3

 Due to that we don't generate migration automatically and it has to be done manually
*/`;
  }
};
var PgAlterTableAlterColumnDropDefaultConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_alter_column_drop_default" && dialect3 === "pg";
  }
  convert(statement) {
    const { tableName, columnName, schema: schema4 } = statement;
    const tableNameWithSchema = schema4 ? `"${schema4}"."${tableName}"` : `"${tableName}"`;
    return `ALTER TABLE ${tableNameWithSchema} ALTER COLUMN "${columnName}" DROP DEFAULT;`;
  }
};
var MySqlAlterTableAddPk = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_alter_column_set_pk" && dialect3 === "mysql";
  }
  convert(statement) {
    return `ALTER TABLE \`${statement.tableName}\` ADD PRIMARY KEY (\`${statement.columnName}\`);`;
  }
};
var MySqlAlterTableDropPk = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_alter_column_drop_pk" && dialect3 === "mysql";
  }
  convert(statement) {
    return `ALTER TABLE \`${statement.tableName}\` DROP PRIMARY KEY`;
  }
};
var MySqlModifyColumn = class extends Convertor {
  can(statement, dialect3) {
    return (statement.type === "alter_table_alter_column_set_type" || statement.type === "alter_table_alter_column_set_notnull" || statement.type === "alter_table_alter_column_drop_notnull" || statement.type === "alter_table_alter_column_drop_on_update" || statement.type === "alter_table_alter_column_set_on_update" || statement.type === "alter_table_alter_column_set_autoincrement" || statement.type === "alter_table_alter_column_drop_autoincrement" || statement.type === "alter_table_alter_column_set_default" || statement.type === "alter_table_alter_column_drop_default") && dialect3 === "mysql";
  }
  convert(statement) {
    const { tableName, columnName } = statement;
    let columnType = ``;
    let columnDefault = "";
    let columnNotNull = "";
    let columnOnUpdate = "";
    let columnAutoincrement = "";
    let primaryKey = statement.columnPk ? " PRIMARY KEY" : "";
    if (statement.type === "alter_table_alter_column_drop_notnull") {
      columnType = ` ${statement.newDataType}`;
      columnDefault = statement.columnDefault ? ` DEFAULT ${statement.columnDefault}` : "";
      columnNotNull = statement.columnNotNull ? ` NOT NULL` : "";
      columnOnUpdate = statement.columnOnUpdate ? ` ON UPDATE CURRENT_TIMESTAMP` : "";
      columnAutoincrement = statement.columnAutoIncrement ? " AUTO_INCREMENT" : "";
    } else if (statement.type === "alter_table_alter_column_set_notnull") {
      columnNotNull = ` NOT NULL`;
      columnType = ` ${statement.newDataType}`;
      columnDefault = statement.columnDefault ? ` DEFAULT ${statement.columnDefault}` : "";
      columnOnUpdate = statement.columnOnUpdate ? ` ON UPDATE CURRENT_TIMESTAMP` : "";
      columnAutoincrement = statement.columnAutoIncrement ? " AUTO_INCREMENT" : "";
    } else if (statement.type === "alter_table_alter_column_drop_on_update") {
      columnNotNull = statement.columnNotNull ? ` NOT NULL` : "";
      columnType = ` ${statement.newDataType}`;
      columnDefault = statement.columnDefault ? ` DEFAULT ${statement.columnDefault}` : "";
      columnOnUpdate = "";
      columnAutoincrement = statement.columnAutoIncrement ? " AUTO_INCREMENT" : "";
    } else if (statement.type === "alter_table_alter_column_set_on_update") {
      columnNotNull = statement.columnNotNull ? ` NOT NULL` : "";
      columnOnUpdate = ` ON UPDATE CURRENT_TIMESTAMP`;
      columnType = ` ${statement.newDataType}`;
      columnDefault = statement.columnDefault ? ` DEFAULT ${statement.columnDefault}` : "";
      columnAutoincrement = statement.columnAutoIncrement ? " AUTO_INCREMENT" : "";
    } else if (statement.type === "alter_table_alter_column_set_autoincrement") {
      columnNotNull = statement.columnNotNull ? ` NOT NULL` : "";
      columnOnUpdate = columnOnUpdate = statement.columnOnUpdate ? ` ON UPDATE CURRENT_TIMESTAMP` : "";
      columnType = ` ${statement.newDataType}`;
      columnDefault = statement.columnDefault ? ` DEFAULT ${statement.columnDefault}` : "";
      columnAutoincrement = " AUTO_INCREMENT";
    } else if (statement.type === "alter_table_alter_column_drop_autoincrement") {
      columnNotNull = statement.columnNotNull ? ` NOT NULL` : "";
      columnOnUpdate = columnOnUpdate = statement.columnOnUpdate ? ` ON UPDATE CURRENT_TIMESTAMP` : "";
      columnType = ` ${statement.newDataType}`;
      columnDefault = statement.columnDefault ? ` DEFAULT ${statement.columnDefault}` : "";
      columnAutoincrement = "";
    } else if (statement.type === "alter_table_alter_column_set_default") {
      columnNotNull = statement.columnNotNull ? ` NOT NULL` : "";
      columnOnUpdate = columnOnUpdate = statement.columnOnUpdate ? ` ON UPDATE CURRENT_TIMESTAMP` : "";
      columnType = ` ${statement.newDataType}`;
      columnDefault = ` DEFAULT ${statement.newDefaultValue}`;
      columnAutoincrement = statement.columnAutoIncrement ? " AUTO_INCREMENT" : "";
    } else if (statement.type === "alter_table_alter_column_drop_default") {
      columnNotNull = statement.columnNotNull ? ` NOT NULL` : "";
      columnOnUpdate = columnOnUpdate = statement.columnOnUpdate ? ` ON UPDATE CURRENT_TIMESTAMP` : "";
      columnType = ` ${statement.newDataType}`;
      columnDefault = "";
      columnAutoincrement = statement.columnAutoIncrement ? " AUTO_INCREMENT" : "";
    } else {
      columnType = ` ${statement.newDataType}`;
      columnNotNull = statement.columnNotNull ? ` NOT NULL` : "";
      columnOnUpdate = columnOnUpdate = statement.columnOnUpdate ? ` ON UPDATE CURRENT_TIMESTAMP` : "";
      columnDefault = statement.columnDefault ? ` DEFAULT ${statement.columnDefault}` : "";
      columnAutoincrement = statement.columnAutoIncrement ? " AUTO_INCREMENT" : "";
    }
    columnDefault = columnDefault instanceof Date ? columnDefault.toISOString() : columnDefault;
    return `ALTER TABLE \`${tableName}\` MODIFY COLUMN \`${columnName}\`${columnType}${columnAutoincrement}${columnNotNull}${columnDefault}${columnOnUpdate};`;
  }
};
var SqliteAlterTableAlterColumnDropDefaultConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_alter_column_drop_default" && dialect3 === "sqlite";
  }
  convert(statement) {
    return `/*
 SQLite does not support "Drop default from column" out of the box, we do not generate automatic migration for that, so it has to be done manually
 Please refer to: https://www.techonthenet.com/sqlite/tables/alter_table.php
                  https://www.sqlite.org/lang_altertable.html
                  https://stackoverflow.com/questions/2083543/modify-a-columns-type-in-sqlite3

 Due to that we don't generate migration automatically and it has to be done manually
*/`;
  }
};
var PgAlterTableCreateCompositePrimaryKeyConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "create_composite_pk" && dialect3 === "pg";
  }
  convert(statement) {
    const { name, columns } = PgSquasher.unsquashPK(statement.data);
    const tableNameWithSchema = statement.schema ? `"${statement.schema}"."${statement.tableName}"` : `"${statement.tableName}"`;
    return `ALTER TABLE ${tableNameWithSchema} ADD CONSTRAINT "${statement.constraintName}" PRIMARY KEY("${columns.join('","')}");`;
  }
};
var PgAlterTableDeleteCompositePrimaryKeyConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "delete_composite_pk" && dialect3 === "pg";
  }
  convert(statement) {
    const { name, columns } = PgSquasher.unsquashPK(statement.data);
    const tableNameWithSchema = statement.schema ? `"${statement.schema}"."${statement.tableName}"` : `"${statement.tableName}"`;
    return `ALTER TABLE ${tableNameWithSchema} DROP CONSTRAINT "${statement.constraintName}";`;
  }
};
var PgAlterTableAlterCompositePrimaryKeyConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_composite_pk" && dialect3 === "pg";
  }
  convert(statement) {
    const { name, columns } = PgSquasher.unsquashPK(statement.old);
    const { name: newName, columns: newColumns } = PgSquasher.unsquashPK(
      statement.new
    );
    const tableNameWithSchema = statement.schema ? `"${statement.schema}"."${statement.tableName}"` : `"${statement.tableName}"`;
    return `ALTER TABLE ${tableNameWithSchema} DROP CONSTRAINT ${statement.oldConstraintName};
${BREAKPOINT}ALTER TABLE ${tableNameWithSchema} ADD CONSTRAINT ${statement.newConstraintName} PRIMARY KEY(${newColumns.join(",")});`;
  }
};
var MySqlAlterTableCreateCompositePrimaryKeyConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "create_composite_pk" && dialect3 === "mysql";
  }
  convert(statement) {
    const { name, columns } = MySqlSquasher.unsquashPK(statement.data);
    return `ALTER TABLE \`${statement.tableName}\` ADD PRIMARY KEY(\`${columns.join("`,`")}\`);`;
  }
};
var MySqlAlterTableDeleteCompositePrimaryKeyConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "delete_composite_pk" && dialect3 === "mysql";
  }
  convert(statement) {
    const { name, columns } = MySqlSquasher.unsquashPK(statement.data);
    return `ALTER TABLE \`${statement.tableName}\` DROP PRIMARY KEY;`;
  }
};
var MySqlAlterTableAlterCompositePrimaryKeyConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_composite_pk" && dialect3 === "mysql";
  }
  convert(statement) {
    const { name, columns } = MySqlSquasher.unsquashPK(statement.old);
    const { name: newName, columns: newColumns } = MySqlSquasher.unsquashPK(
      statement.new
    );
    return `ALTER TABLE \`${statement.tableName}\` DROP PRIMARY KEY, ADD PRIMARY KEY(\`${newColumns.join("`,`")}\`);`;
  }
};
var SqliteAlterTableCreateCompositePrimaryKeyConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "create_composite_pk" && dialect3 === "sqlite";
  }
  convert(statement) {
    let msg = "/*\n";
    msg += `You're trying to add PRIMARY KEY(${statement.data}) to '${statement.tableName}' table
`;
    msg += "SQLite does not support adding primary key to an already created table\n";
    msg += "You can do it in 3 steps with drizzle orm:\n";
    msg += " - create new mirror table with needed pk, rename current table to old_table, generate SQL\n";
    msg += " - migrate old data from one table to another\n";
    msg += " - delete old_table in schema, generate sql\n\n";
    msg += "or create manual migration like below:\n\n";
    msg += "ALTER TABLE table_name RENAME TO old_table;\n";
    msg += "CREATE TABLE table_name (\n";
    msg += "	column1 datatype [ NULL | NOT NULL ],\n";
    msg += "	column2 datatype [ NULL | NOT NULL ],\n";
    msg += "	...\n";
    msg += "	PRIMARY KEY (pk_col1, pk_col2, ... pk_col_n)\n";
    msg += " );\n";
    msg += "INSERT INTO table_name SELECT * FROM old_table;\n\n";
    msg += "Due to that we don't generate migration automatically and it has to be done manually\n";
    msg += "*/\n";
    return msg;
  }
};
var SqliteAlterTableDeleteCompositePrimaryKeyConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "delete_composite_pk" && dialect3 === "sqlite";
  }
  convert(statement) {
    let msg = "/*\n";
    msg += `You're trying to delete PRIMARY KEY(${statement.data}) from '${statement.tableName}' table
`;
    msg += "SQLite does not supportprimary key deletion from existing table\n";
    msg += "You can do it in 3 steps with drizzle orm:\n";
    msg += " - create new mirror table table without pk, rename current table to old_table, generate SQL\n";
    msg += " - migrate old data from one table to another\n";
    msg += " - delete old_table in schema, generate sql\n\n";
    msg += "or create manual migration like below:\n\n";
    msg += "ALTER TABLE table_name RENAME TO old_table;\n";
    msg += "CREATE TABLE table_name (\n";
    msg += "	column1 datatype [ NULL | NOT NULL ],\n";
    msg += "	column2 datatype [ NULL | NOT NULL ],\n";
    msg += "	...\n";
    msg += "	PRIMARY KEY (pk_col1, pk_col2, ... pk_col_n)\n";
    msg += " );\n";
    msg += "INSERT INTO table_name SELECT * FROM old_table;\n\n";
    msg += "Due to that we don't generate migration automatically and it has to be done manually\n";
    msg += "*/\n";
    return msg;
  }
};
var SqliteAlterTableAlterCompositePrimaryKeyConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_composite_pk" && dialect3 === "sqlite";
  }
  convert(statement) {
    let msg = "/*\n";
    msg += "SQLite does not support altering primary key\n";
    msg += "You can do it in 3 steps with drizzle orm:\n";
    msg += " - create new mirror table with needed pk, rename current table to old_table, generate SQL\n";
    msg += " - migrate old data from one table to another\n";
    msg += " - delete old_table in schema, generate sql\n\n";
    msg += "or create manual migration like below:\n\n";
    msg += "ALTER TABLE table_name RENAME TO old_table;\n";
    msg += "CREATE TABLE table_name (\n";
    msg += "	column1 datatype [ NULL | NOT NULL ],\n";
    msg += "	column2 datatype [ NULL | NOT NULL ],\n";
    msg += "	...\n";
    msg += "	PRIMARY KEY (pk_col1, pk_col2, ... pk_col_n)\n";
    msg += " );\n";
    msg += "INSERT INTO table_name SELECT * FROM old_table;\n\n";
    msg += "Due to that we don't generate migration automatically and it has to be done manually\n";
    msg += "*/\n";
    return msg;
  }
};
var PgAlterTableAlterColumnSetPrimaryKeyConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_alter_column_set_pk" && dialect3 === "pg";
  }
  convert(statement) {
    const { tableName, columnName } = statement;
    const tableNameWithSchema = statement.schema ? `"${statement.schema}"."${statement.tableName}"` : `"${statement.tableName}"`;
    return `ALTER TABLE ${tableNameWithSchema} ADD PRIMARY KEY ("${columnName}");`;
  }
};
var PgAlterTableAlterColumnDropPrimaryKeyConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_alter_column_drop_pk" && dialect3 === "pg";
  }
  convert(statement) {
    const { tableName, columnName, schema: schema4 } = statement;
    return `/* 
    Unfortunately in current drizzle-kit version we can't automatically get name for primary key.
    We are working on making it available!

    Meanwhile you can:
        1. Check pk name in your database, by running
            SELECT constraint_name FROM information_schema.table_constraints
            WHERE table_schema = '${typeof schema4 === "undefined" || schema4 === "" ? "public" : schema4}'
                AND table_name = '${tableName}'
                AND constraint_type = 'PRIMARY KEY';
        2. Uncomment code below and paste pk name manually
        
    Hope to release this update as soon as possible
*/

-- ALTER TABLE "${tableName}" DROP CONSTRAINT "<constraint_name>";`;
  }
};
var PgAlterTableAlterColumnSetNotNullConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_alter_column_set_notnull" && dialect3 === "pg";
  }
  convert(statement) {
    const { tableName, columnName } = statement;
    const tableNameWithSchema = statement.schema ? `"${statement.schema}"."${statement.tableName}"` : `"${statement.tableName}"`;
    return `ALTER TABLE ${tableNameWithSchema} ALTER COLUMN "${columnName}" SET NOT NULL;`;
  }
};
var SqliteAlterTableAlterColumnSetNotNullConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_alter_column_set_notnull" && dialect3 === "sqlite";
  }
  convert(statement) {
    return `/*
 SQLite does not support "Set not null to column" out of the box, we do not generate automatic migration for that, so it has to be done manually
 Please refer to: https://www.techonthenet.com/sqlite/tables/alter_table.php
                  https://www.sqlite.org/lang_altertable.html
                  https://stackoverflow.com/questions/2083543/modify-a-columns-type-in-sqlite3

 Due to that we don't generate migration automatically and it has to be done manually
*/`;
  }
};
var SqliteAlterTableAlterColumnSetAutoincrementConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_alter_column_set_autoincrement" && dialect3 === "sqlite";
  }
  convert(statement) {
    return `/*
 SQLite does not support "Set autoincrement to a column" out of the box, we do not generate automatic migration for that, so it has to be done manually
 Please refer to: https://www.techonthenet.com/sqlite/tables/alter_table.php
                  https://www.sqlite.org/lang_altertable.html
                  https://stackoverflow.com/questions/2083543/modify-a-columns-type-in-sqlite3

 Due to that we don't generate migration automatically and it has to be done manually
*/`;
  }
};
var SqliteAlterTableAlterColumnDropAutoincrementConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_alter_column_drop_autoincrement" && dialect3 === "sqlite";
  }
  convert(statement) {
    return `/*
 SQLite does not support "Drop autoincrement from a column" out of the box, we do not generate automatic migration for that, so it has to be done manually
 Please refer to: https://www.techonthenet.com/sqlite/tables/alter_table.php
                  https://www.sqlite.org/lang_altertable.html
                  https://stackoverflow.com/questions/2083543/modify-a-columns-type-in-sqlite3

 Due to that we don't generate migration automatically and it has to be done manually
*/`;
  }
};
var PgAlterTableAlterColumnDropNotNullConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_alter_column_drop_notnull" && dialect3 === "pg";
  }
  convert(statement) {
    const { tableName, columnName } = statement;
    const tableNameWithSchema = statement.schema ? `"${statement.schema}"."${statement.tableName}"` : `"${statement.tableName}"`;
    return `ALTER TABLE ${tableNameWithSchema} ALTER COLUMN "${columnName}" DROP NOT NULL;`;
  }
};
var SqliteAlterTableAlterColumnDropNotNullConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_alter_column_drop_notnull" && dialect3 === "sqlite";
  }
  convert(statement) {
    return `/*
 SQLite does not support "Drop not null from column" out of the box, we do not generate automatic migration for that, so it has to be done manually
 Please refer to: https://www.techonthenet.com/sqlite/tables/alter_table.php
                  https://www.sqlite.org/lang_altertable.html
                  https://stackoverflow.com/questions/2083543/modify-a-columns-type-in-sqlite3

 Due to that we don't generate migration automatically and it has to be done manually
*/`;
  }
};
var PgCreateForeignKeyConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "create_reference" && dialect3 === "pg";
  }
  convert(statement) {
    const {
      name,
      tableFrom,
      tableTo,
      columnsFrom,
      columnsTo,
      onDelete,
      onUpdate
    } = PgSquasher.unsquashFK(statement.data);
    const onDeleteStatement = onDelete ? ` ON DELETE ${onDelete}` : "";
    const onUpdateStatement = onUpdate ? ` ON UPDATE ${onUpdate}` : "";
    const fromColumnsString = columnsFrom.map((it) => `"${it}"`).join(",");
    const toColumnsString = columnsTo.map((it) => `"${it}"`).join(",");
    const tableNameWithSchema = statement.schema ? `"${statement.schema}"."${tableFrom}"` : `"${tableFrom}"`;
    const tableToNameWithSchema = statement.schema ? `"${statement.schema}"."${tableTo}"` : `"${tableTo}"`;
    const alterStatement = `ALTER TABLE ${tableNameWithSchema} ADD CONSTRAINT "${name}" FOREIGN KEY (${fromColumnsString}) REFERENCES ${tableToNameWithSchema}(${toColumnsString})${onDeleteStatement}${onUpdateStatement}`;
    let sql = "DO $$ BEGIN\n";
    sql += " " + alterStatement + ";\n";
    sql += "EXCEPTION\n";
    sql += " WHEN duplicate_object THEN null;\n";
    sql += "END $$;\n";
    return sql;
  }
};
var SqliteCreateForeignKeyConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "create_reference" && dialect3 === "sqlite";
  }
  convert(statement) {
    return `/*
 SQLite does not support "Creating foreign key on existing column" out of the box, we do not generate automatic migration for that, so it has to be done manually
 Please refer to: https://www.techonthenet.com/sqlite/tables/alter_table.php
                  https://www.sqlite.org/lang_altertable.html

 Due to that we don't generate migration automatically and it has to be done manually
*/`;
  }
};
var MySqlCreateForeignKeyConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "create_reference" && dialect3 === "mysql";
  }
  convert(statement) {
    const {
      name,
      tableFrom,
      tableTo,
      columnsFrom,
      columnsTo,
      onDelete,
      onUpdate
    } = MySqlSquasher.unsquashFK(statement.data);
    const onDeleteStatement = onDelete ? ` ON DELETE ${onDelete}` : "";
    const onUpdateStatement = onUpdate ? ` ON UPDATE ${onUpdate}` : "";
    const fromColumnsString = columnsFrom.map((it) => `\`${it}\``).join(",");
    const toColumnsString = columnsTo.map((it) => `\`${it}\``).join(",");
    return `ALTER TABLE \`${tableFrom}\` ADD CONSTRAINT \`${name}\` FOREIGN KEY (${fromColumnsString}) REFERENCES \`${tableTo}\`(${toColumnsString})${onDeleteStatement}${onUpdateStatement};`;
  }
};
var PgAlterForeignKeyConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_reference" && dialect3 === "pg";
  }
  convert(statement) {
    const newFk = PgSquasher.unsquashFK(statement.data);
    const oldFk = PgSquasher.unsquashFK(statement.oldFkey);
    const tableNameWithSchema = statement.schema ? `"${statement.schema}"."${oldFk.tableFrom}"` : `"${oldFk.tableFrom}"`;
    let sql = `ALTER TABLE ${tableNameWithSchema} DROP CONSTRAINT "${oldFk.name}";
`;
    const onDeleteStatement = newFk.onDelete ? ` ON DELETE ${newFk.onDelete}` : "";
    const onUpdateStatement = newFk.onUpdate ? ` ON UPDATE ${newFk.onUpdate}` : "";
    const fromColumnsString = newFk.columnsFrom.map((it) => `"${it}"`).join(",");
    const toColumnsString = newFk.columnsTo.map((it) => `"${it}"`).join(",");
    const tableFromNameWithSchema = statement.schema ? `"${statement.schema}"."${newFk.tableFrom}"` : `"${newFk.tableFrom}"`;
    const alterStatement = `ALTER TABLE ${tableFromNameWithSchema} ADD CONSTRAINT "${newFk.name}" FOREIGN KEY (${fromColumnsString}) REFERENCES "${newFk.tableTo}"(${toColumnsString})${onDeleteStatement}${onUpdateStatement}`;
    sql += "DO $$ BEGIN\n";
    sql += " " + alterStatement + ";\n";
    sql += "EXCEPTION\n";
    sql += " WHEN duplicate_object THEN null;\n";
    sql += "END $$;\n";
    return sql;
  }
};
var SqliteAlterForeignKeyConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_reference" && dialect3 === "sqlite";
  }
  convert(statement) {
    return `/*
 SQLite does not support "Changing existing foreign key" out of the box, we do not generate automatic migration for that, so it has to be done manually
 Please refer to: https://www.techonthenet.com/sqlite/tables/alter_table.php
                  https://www.sqlite.org/lang_altertable.html

 Due to that we don't generate migration automatically and it has to be done manually
*/`;
  }
};
var PgDeleteForeignKeyConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "delete_reference" && dialect3 === "pg";
  }
  convert(statement) {
    const tableFrom = statement.tableName;
    const { name } = PgSquasher.unsquashFK(statement.data);
    const tableNameWithSchema = statement.schema ? `"${statement.schema}"."${tableFrom}"` : `"${tableFrom}"`;
    return `ALTER TABLE ${tableNameWithSchema} DROP CONSTRAINT "${name}";
`;
  }
};
var SqliteDeleteForeignKeyConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "delete_reference" && dialect3 === "sqlite";
  }
  convert(statement) {
    return `/*
 SQLite does not support "Dropping foreign key" out of the box, we do not generate automatic migration for that, so it has to be done manually
 Please refer to: https://www.techonthenet.com/sqlite/tables/alter_table.php
                  https://www.sqlite.org/lang_altertable.html

 Due to that we don't generate migration automatically and it has to be done manually
*/`;
  }
};
var MySqlDeleteForeignKeyConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "delete_reference" && dialect3 === "mysql";
  }
  convert(statement) {
    const tableFrom = statement.tableName;
    const { name } = MySqlSquasher.unsquashFK(statement.data);
    return `ALTER TABLE \`${tableFrom}\` DROP FOREIGN KEY \`${name}\`;
`;
  }
};
var CreatePgIndexConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "create_index" && dialect3 === "pg";
  }
  convert(statement) {
    const { name, columns, isUnique } = PgSquasher.unsquashIdx(statement.data);
    const indexPart = isUnique ? "UNIQUE INDEX" : "INDEX";
    const value = columns.map((it) => `"${it}"`).join(",");
    const tableNameWithSchema = statement.schema ? `"${statement.schema}"."${statement.tableName}"` : `"${statement.tableName}"`;
    return `CREATE ${indexPart} IF NOT EXISTS "${name}" ON ${tableNameWithSchema} (${value});`;
  }
};
var CreateMySqlIndexConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "create_index" && dialect3 === "mysql";
  }
  convert(statement) {
    const { name, columns, isUnique } = MySqlSquasher.unsquashIdx(
      statement.data
    );
    const indexPart = isUnique ? "UNIQUE INDEX" : "INDEX";
    const value = columns.map((it) => `\`${it}\``).join(",");
    return `CREATE ${indexPart} \`${name}\` ON \`${statement.tableName}\` (${value});`;
  }
};
var CreateSqliteIndexConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "create_index" && dialect3 === "sqlite";
  }
  convert(statement) {
    const { name, columns, isUnique, where } = SQLiteSquasher.unsquashIdx(
      statement.data
    );
    const indexPart = isUnique ? "UNIQUE INDEX" : "INDEX";
    const whereStatement = where ? ` WHERE ${where}` : "";
    const value = columns.map((it) => `\`${it}\``).join(",");
    return `CREATE ${indexPart} \`${name}\` ON \`${statement.tableName}\` (${value})${whereStatement};`;
  }
};
var PgDropIndexConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "drop_index" && dialect3 === "pg";
  }
  convert(statement) {
    const { name } = PgSquasher.unsquashIdx(statement.data);
    return `DROP INDEX IF EXISTS "${name}";`;
  }
};
var PgCreateSchemaConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "create_schema" && dialect3 === "pg";
  }
  convert(statement) {
    const { name } = statement;
    return `CREATE SCHEMA "${name}";
`;
  }
};
var PgRenameSchemaConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "rename_schema" && dialect3 === "pg";
  }
  convert(statement) {
    const { from, to } = statement;
    return `ALTER SCHEMA "${from}" RENAME TO "${to}";
`;
  }
};
var PgDropSchemaConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "drop_schema" && dialect3 === "pg";
  }
  convert(statement) {
    const { name } = statement;
    return `DROP SCHEMA "${name}";
`;
  }
};
var PgAlterTableSetSchemaConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_set_schema" && dialect3 === "pg";
  }
  convert(statement) {
    const { tableName, schema: schema4 } = statement;
    return `ALTER TABLE "${tableName}" SET SCHEMA "${schema4}";
`;
  }
};
var PgAlterTableSetNewSchemaConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_set_new_schema" && dialect3 === "pg";
  }
  convert(statement) {
    const { tableName, to, from } = statement;
    const tableNameWithSchema = from ? `"${from}"."${tableName}"` : `"${tableName}"`;
    return `ALTER TABLE ${tableNameWithSchema} SET SCHEMA "${to}";
`;
  }
};
var PgAlterTableRemoveFromSchemaConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_remove_from_schema" && dialect3 === "pg";
  }
  convert(statement) {
    const { tableName, schema: schema4 } = statement;
    const tableNameWithSchema = schema4 ? `"${schema4}"."${tableName}"` : `"${tableName}"`;
    return `ALTER TABLE ${tableNameWithSchema} SET SCHEMA public;
`;
  }
};
var SqliteDropIndexConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "drop_index" && dialect3 === "sqlite";
  }
  convert(statement) {
    const { name } = PgSquasher.unsquashIdx(statement.data);
    return `DROP INDEX IF EXISTS \`${name}\`;`;
  }
};
var MysqlCreateSchemaConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "create_schema" && dialect3 === "mysql";
  }
  convert(statement) {
    const { name } = statement;
    return `CREATE DATABASE \`${name}\`;
`;
  }
};
var MysqlDropSchemaConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "drop_schema" && dialect3 === "mysql";
  }
  convert(statement) {
    const { name } = statement;
    return `DROP DATABASE \`${name}\`;
`;
  }
};
var MysqlAlterTableSetSchemaConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_set_schema" && dialect3 === "mysql";
  }
  convert(statement) {
    const { tableName, schema: schema4 } = statement;
    const nameFrom = `\`${tableName}\``;
    const nameTo = `\`${schema4}\`.\`${tableName}\``;
    return `RENAME TABLE ${nameFrom} TO ${nameTo};
`;
  }
};
var MysqlAlterTableSetNewSchemaConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_set_new_schema" && dialect3 === "mysql";
  }
  convert(statement) {
    const { tableName, to, from } = statement;
    const nameFrom = from ? `\`${from}\`.\`${tableName}\`` : `\`${tableName}\``;
    const nameTo = to ? `\`${to}\`.\`${tableName}\`` : `\`${tableName}\``;
    return `RENAME TABLE ${nameFrom} TO ${nameTo};
`;
  }
};
var MysqlAlterTableRemoveFromSchemaConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "alter_table_remove_from_schema" && dialect3 === "mysql";
  }
  convert(statement) {
    const { tableName, schema: schema4 } = statement;
    const nameFrom = `\`${schema4}\`.\`${tableName}\``;
    const nameTo = `\`${tableName}\``;
    return `RENAME TABLE ${nameFrom} TO ${nameTo};
`;
  }
};
var MySqlDropIndexConvertor = class extends Convertor {
  can(statement, dialect3) {
    return statement.type === "drop_index" && dialect3 === "mysql";
  }
  convert(statement) {
    const tableName = typeof statement.schema === "undefined" ? `\`${statement.tableName}\`` : `\`${statement.schema}\`.\`${statement.tableName}\``;
    const { name } = MySqlSquasher.unsquashIdx(statement.data);
    return `DROP INDEX \`${name}\` ON ${tableName};`;
  }
};
var convertors = [];
convertors.push(new PgCreateTableConvertor());
convertors.push(new MySqlCreateTableConvertor());
convertors.push(new SQLiteCreateTableConvertor());
convertors.push(new CreateTypeEnumConvertor());
convertors.push(new PgDropTableConvertor());
convertors.push(new MySQLDropTableConvertor());
convertors.push(new SQLiteDropTableConvertor());
convertors.push(new PgRenameTableConvertor());
convertors.push(new MySqlRenameTableConvertor());
convertors.push(new SqliteRenameTableConvertor());
convertors.push(new PgAlterTableRenameColumnConvertor());
convertors.push(new MySqlAlterTableRenameColumnConvertor());
convertors.push(new SQLiteAlterTableRenameColumnConvertor());
convertors.push(new PgAlterTableDropColumnConvertor());
convertors.push(new MySqlAlterTableDropColumnConvertor());
convertors.push(new SQLiteAlterTableDropColumnConvertor());
convertors.push(new PgAlterTableAddColumnConvertor());
convertors.push(new MySqlAlterTableAddColumnConvertor());
convertors.push(new SQLiteAlterTableAddColumnConvertor());
convertors.push(new PgAlterTableAlterColumnSetTypeConvertor());
convertors.push(new PgAlterTableAddUniqueConstraintConvertor());
convertors.push(new PgAlterTableDropUniqueConstraintConvertor());
convertors.push(new MySQLAlterTableAddUniqueConstraintConvertor());
convertors.push(new MySQLAlterTableDropUniqueConstraintConvertor());
convertors.push(new CreatePgIndexConvertor());
convertors.push(new CreateMySqlIndexConvertor());
convertors.push(new CreateSqliteIndexConvertor());
convertors.push(new PgDropIndexConvertor());
convertors.push(new SqliteDropIndexConvertor());
convertors.push(new MySqlDropIndexConvertor());
convertors.push(new AlterTypeAddValueConvertor());
convertors.push(new PgAlterTableAlterColumnSetPrimaryKeyConvertor());
convertors.push(new PgAlterTableAlterColumnDropPrimaryKeyConvertor());
convertors.push(new PgAlterTableAlterColumnSetNotNullConvertor());
convertors.push(new PgAlterTableAlterColumnDropNotNullConvertor());
convertors.push(new PgAlterTableAlterColumnSetDefaultConvertor());
convertors.push(new PgAlterTableAlterColumnDropDefaultConvertor());
convertors.push(new MySqlModifyColumn());
convertors.push(new PgCreateForeignKeyConvertor());
convertors.push(new MySqlCreateForeignKeyConvertor());
convertors.push(new PgAlterForeignKeyConvertor());
convertors.push(new PgDeleteForeignKeyConvertor());
convertors.push(new MySqlDeleteForeignKeyConvertor());
convertors.push(new PgCreateSchemaConvertor());
convertors.push(new PgRenameSchemaConvertor());
convertors.push(new PgDropSchemaConvertor());
convertors.push(new PgAlterTableSetSchemaConvertor());
convertors.push(new PgAlterTableSetNewSchemaConvertor());
convertors.push(new PgAlterTableRemoveFromSchemaConvertor());
convertors.push(new MysqlCreateSchemaConvertor());
convertors.push(new MysqlDropSchemaConvertor());
convertors.push(new MysqlAlterTableSetSchemaConvertor());
convertors.push(new MysqlAlterTableSetNewSchemaConvertor());
convertors.push(new MysqlAlterTableRemoveFromSchemaConvertor());
convertors.push(new SQLiteAlterTableAlterColumnSetTypeConvertor());
convertors.push(new SqliteAlterForeignKeyConvertor());
convertors.push(new SqliteDeleteForeignKeyConvertor());
convertors.push(new SqliteCreateForeignKeyConvertor());
convertors.push(new SQLiteAlterTableAddUniqueConstraintConvertor());
convertors.push(new SQLiteAlterTableDropUniqueConstraintConvertor());
convertors.push(new SqliteAlterTableAlterColumnSetNotNullConvertor());
convertors.push(new SqliteAlterTableAlterColumnDropNotNullConvertor());
convertors.push(new SqliteAlterTableAlterColumnSetDefaultConvertor());
convertors.push(new SqliteAlterTableAlterColumnDropDefaultConvertor());
convertors.push(new SqliteAlterTableAlterColumnSetAutoincrementConvertor());
convertors.push(new SqliteAlterTableAlterColumnDropAutoincrementConvertor());
convertors.push(new SqliteAlterTableCreateCompositePrimaryKeyConvertor());
convertors.push(new SqliteAlterTableDeleteCompositePrimaryKeyConvertor());
convertors.push(new SqliteAlterTableAlterCompositePrimaryKeyConvertor());
convertors.push(new PgAlterTableCreateCompositePrimaryKeyConvertor());
convertors.push(new PgAlterTableDeleteCompositePrimaryKeyConvertor());
convertors.push(new PgAlterTableAlterCompositePrimaryKeyConvertor());
convertors.push(new MySqlAlterTableDeleteCompositePrimaryKeyConvertor());
convertors.push(new MySqlAlterTableDropPk());
convertors.push(new MySqlAlterTableCreateCompositePrimaryKeyConvertor());
convertors.push(new MySqlAlterTableAddPk());
convertors.push(new MySqlAlterTableAlterCompositePrimaryKeyConvertor());
var fromJson = (statements, dialect3) => {
  const result = statements.map((statement) => {
    const filtered = convertors.filter((it) => {
      return it.can(statement, dialect3);
    });
    const convertor = filtered.length === 1 ? filtered[0] : void 0;
    if (!convertor) {
      return "";
    }
    return convertor.convert(statement);
  }).filter((it) => it !== "");
  return result;
};
https:
  `
create table users (
	id int,
    name character varying(128)
);

create type venum as enum('one', 'two', 'three');
alter table users add column typed venum;

insert into users(id, name, typed) values (1, 'name1', 'one');
insert into users(id, name, typed) values (2, 'name2', 'two');
insert into users(id, name, typed) values (3, 'name3', 'three');

alter type venum rename to __venum;
create type venum as enum ('one', 'two', 'three', 'four', 'five');

ALTER TABLE users ALTER COLUMN typed TYPE venum USING typed::text::venum;

insert into users(id, name, typed) values (4, 'name4', 'four');
insert into users(id, name, typed) values (5, 'name5', 'five');

drop type __venum;
`;

// src/snapshotsDiffer.ts
init_lib();

// src/jsonStatements.ts
var preparePgCreateTableJson = (table4, json2) => {
  const { name, schema: schema4, columns, compositePrimaryKeys, uniqueConstraints } = table4;
  return {
    type: "create_table",
    tableName: name,
    schema: schema4,
    columns: Object.values(columns),
    compositePKs: Object.values(compositePrimaryKeys),
    compositePkName: Object.values(compositePrimaryKeys).length > 0 ? json2.tables[name].compositePrimaryKeys[`${name}_${PgSquasher.unsquashPK(
      Object.values(compositePrimaryKeys)[0]
    ).columns.join("_")}`].name : "",
    uniqueConstraints: Object.values(uniqueConstraints)
  };
};
var prepareMySqlCreateTableJson = (table4, json2) => {
  const { name, schema: schema4, columns, compositePrimaryKeys, uniqueConstraints } = table4;
  return {
    type: "create_table",
    tableName: name,
    schema: schema4,
    columns: Object.values(columns),
    compositePKs: Object.values(compositePrimaryKeys),
    compositePkName: Object.values(compositePrimaryKeys).length > 0 ? json2.tables[name].compositePrimaryKeys[`${name}_${MySqlSquasher.unsquashPK(
      Object.values(compositePrimaryKeys)[0]
    ).columns.join("_")}`].name : "",
    uniqueConstraints: Object.values(uniqueConstraints)
  };
};
var prepareSQLiteCreateTable = (table4) => {
  const { name, columns, uniqueConstraints } = table4;
  const references2 = Object.values(table4.foreignKeys);
  const composites = Object.values(table4.compositePrimaryKeys).map(
    (it) => SQLiteSquasher.unsquashPK(it)
  );
  return {
    type: "sqlite_create_table",
    tableName: name,
    columns: Object.values(columns),
    referenceData: references2,
    compositePKs: composites,
    uniqueConstraints: Object.values(uniqueConstraints)
  };
};
var prepareDropTableJson = (table4) => {
  return {
    type: "drop_table",
    tableName: table4.name,
    schema: table4.schema
  };
};
var prepareRenameTableJson = (tableFrom, tableTo) => {
  return {
    type: "rename_table",
    fromSchema: tableFrom.schema,
    toSchema: tableTo.schema,
    tableNameFrom: tableFrom.name,
    tableNameTo: tableTo.name
  };
};
var prepareCreateEnumJson = (name, values) => {
  return {
    type: "create_type_enum",
    name,
    values
  };
};
var prepareAddValuesToEnumJson = (name, values) => {
  return values.map((it) => {
    return {
      type: "alter_type_add_value",
      name,
      value: it
    };
  });
};
var prepareCreateSchemasJson = (values) => {
  return values.map((it) => {
    return {
      type: "create_schema",
      name: it
    };
  });
};
var prepareRenameSchemasJson = (values) => {
  return values.map((it) => {
    return {
      type: "rename_schema",
      from: it.from,
      to: it.to
    };
  });
};
var prepareDeleteSchemasJson = (values) => {
  return values.map((it) => {
    return {
      type: "drop_schema",
      name: it
    };
  });
};
var prepareRenameColumns = (tableName, schema4, pairs) => {
  return pairs.map((it) => {
    return {
      type: "alter_table_rename_column",
      tableName,
      oldColumnName: it.from.name,
      newColumnName: it.to.name,
      schema: schema4
    };
  });
};
var prepareAlterTableColumnsJson = (tableName, schema4, deleted, added, altered, addedFk, json2, dialect3) => {
  const addColumns = [];
  const dropColumns = _prepareDropColumns(tableName, schema4, deleted);
  const alterColumns = _prepareAlterColumns(tableName, schema4, altered, json2);
  if (dialect3 === "sqlite") {
    let jsonCreateFKStatements = Object.values(addedFk);
    const sqliteAddColumns = _prepareSQLiteAddColumns(
      tableName,
      added,
      jsonCreateFKStatements
    );
    addColumns.push(...sqliteAddColumns);
  } else {
    addColumns.push(..._prepareAddColumns(tableName, schema4, added));
  }
  return { addColumns, dropColumns, alterColumns };
};
var _prepareDropColumns = (taleName, schema4, columns) => {
  return columns.map((it) => {
    return {
      type: "alter_table_drop_column",
      tableName: taleName,
      columnName: it.name,
      schema: schema4
    };
  });
};
var _prepareAddColumns = (tableName, schema4, columns) => {
  return columns.map((it) => {
    return {
      type: "alter_table_add_column",
      tableName,
      column: it,
      schema: schema4
    };
  });
};
var _prepareSQLiteAddColumns = (tableName, columns, referenceData) => {
  const unsquashed = referenceData.map(
    (addedFkValue) => SQLiteSquasher.unsquashFK(addedFkValue)
  );
  return columns.map((it) => {
    const columnsWithReference = unsquashed.find(
      (t) => t.columnsFrom.includes(it.name)
    );
    return {
      type: "sqlite_alter_table_add_column",
      tableName,
      column: it,
      referenceData: columnsWithReference ? SQLiteSquasher.squashFK(columnsWithReference) : void 0
    };
  });
};
var _prepareAlterColumns = (tableName, schema4, columns, json2) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
  let statements = [];
  let dropPkStatements = [];
  let setPkStatements = [];
  for (const column4 of columns) {
    const columnName = typeof column4.name !== "string" ? column4.name.new : column4.name;
    const columnType = json2.tables[tableName].columns[columnName].type;
    const columnDefault = json2.tables[tableName].columns[columnName].default;
    const columnOnUpdate = json2.tables[tableName].columns[columnName].onUpdate;
    const columnNotNull = json2.tables[tableName].columns[columnName].notNull;
    const columnAutoIncrement = json2.tables[tableName].columns[columnName].autoincrement;
    const columnPk = json2.tables[tableName].columns[columnName].primaryKey;
    if (((_a = column4.autoincrement) == null ? void 0 : _a.type) === "added") {
      statements.push({
        type: "alter_table_alter_column_set_autoincrement",
        tableName,
        columnName,
        schema: schema4,
        newDataType: columnType,
        columnDefault,
        columnOnUpdate,
        columnNotNull,
        columnAutoIncrement,
        columnPk
      });
    }
    if (((_b = column4.autoincrement) == null ? void 0 : _b.type) === "changed") {
      const type = column4.autoincrement.new ? "alter_table_alter_column_set_autoincrement" : "alter_table_alter_column_drop_autoincrement";
      statements.push({
        type,
        tableName,
        columnName,
        schema: schema4,
        newDataType: columnType,
        columnDefault,
        columnOnUpdate,
        columnNotNull,
        columnAutoIncrement,
        columnPk
      });
    }
    if (((_c = column4.autoincrement) == null ? void 0 : _c.type) === "deleted") {
      statements.push({
        type: "alter_table_alter_column_drop_autoincrement",
        tableName,
        columnName,
        schema: schema4,
        newDataType: columnType,
        columnDefault,
        columnOnUpdate,
        columnNotNull,
        columnAutoIncrement,
        columnPk
      });
    }
  }
  for (const column4 of columns) {
    const columnName = typeof column4.name !== "string" ? column4.name.new : column4.name;
    const columnType = json2.tables[tableName].columns[columnName].type;
    const columnDefault = json2.tables[tableName].columns[columnName].default;
    const columnOnUpdate = json2.tables[tableName].columns[columnName].onUpdate;
    const columnNotNull = json2.tables[tableName].columns[columnName].notNull;
    const columnAutoIncrement = json2.tables[tableName].columns[columnName].autoincrement;
    const columnPk = json2.tables[tableName].columns[columnName].primaryKey;
    const compositePk = json2.tables[tableName].compositePrimaryKeys[`${tableName}_${columnName}`];
    if (typeof column4.name !== "string") {
      statements.push({
        type: "alter_table_rename_column",
        tableName,
        oldColumnName: column4.name.old,
        newColumnName: column4.name.new,
        schema: schema4
      });
    }
    if (((_d = column4.type) == null ? void 0 : _d.type) === "changed") {
      statements.push({
        type: "alter_table_alter_column_set_type",
        tableName,
        columnName,
        newDataType: column4.type.new,
        oldDataType: column4.type.old,
        schema: schema4,
        columnDefault,
        columnOnUpdate,
        columnNotNull,
        columnAutoIncrement,
        columnPk
      });
    }
    if (((_e = column4.primaryKey) == null ? void 0 : _e.type) === "deleted" || ((_f = column4.primaryKey) == null ? void 0 : _f.type) === "changed" && !column4.primaryKey.new && typeof compositePk === "undefined") {
      dropPkStatements.push({
        ////
        type: "alter_table_alter_column_drop_pk",
        tableName,
        columnName,
        schema: schema4
      });
    }
    if (((_g = column4.default) == null ? void 0 : _g.type) === "added") {
      statements.push({
        type: "alter_table_alter_column_set_default",
        tableName,
        columnName,
        newDefaultValue: column4.default.value,
        schema: schema4,
        columnOnUpdate,
        columnNotNull,
        columnAutoIncrement,
        newDataType: columnType,
        columnPk
      });
    }
    if (((_h = column4.default) == null ? void 0 : _h.type) === "changed") {
      statements.push({
        type: "alter_table_alter_column_set_default",
        tableName,
        columnName,
        newDefaultValue: column4.default.new,
        oldDefaultValue: column4.default.old,
        schema: schema4,
        columnOnUpdate,
        columnNotNull,
        columnAutoIncrement,
        newDataType: columnType,
        columnPk
      });
    }
    if (((_i = column4.default) == null ? void 0 : _i.type) === "deleted") {
      statements.push({
        type: "alter_table_alter_column_drop_default",
        tableName,
        columnName,
        schema: schema4,
        columnDefault,
        columnOnUpdate,
        columnNotNull,
        columnAutoIncrement,
        newDataType: columnType,
        columnPk
      });
    }
    if (((_j = column4.notNull) == null ? void 0 : _j.type) === "added") {
      statements.push({
        type: "alter_table_alter_column_set_notnull",
        tableName,
        columnName,
        schema: schema4,
        newDataType: columnType,
        columnDefault,
        columnOnUpdate,
        columnNotNull,
        columnAutoIncrement,
        columnPk
      });
    }
    if (((_k = column4.notNull) == null ? void 0 : _k.type) === "changed") {
      const type = column4.notNull.new ? "alter_table_alter_column_set_notnull" : "alter_table_alter_column_drop_notnull";
      statements.push({
        type,
        tableName,
        columnName,
        schema: schema4,
        newDataType: columnType,
        columnDefault,
        columnOnUpdate,
        columnNotNull,
        columnAutoIncrement,
        columnPk
      });
    }
    if (((_l = column4.notNull) == null ? void 0 : _l.type) === "deleted") {
      statements.push({
        type: "alter_table_alter_column_drop_notnull",
        tableName,
        columnName,
        schema: schema4,
        newDataType: columnType,
        columnDefault,
        columnOnUpdate,
        columnNotNull,
        columnAutoIncrement,
        columnPk
      });
    }
    if (((_m = column4.primaryKey) == null ? void 0 : _m.type) === "added" || ((_n = column4.primaryKey) == null ? void 0 : _n.type) === "changed" && column4.primaryKey.new) {
      const wasAutoincrement = statements.filter(
        (it) => it.type === "alter_table_alter_column_set_autoincrement"
      );
      if (wasAutoincrement.length === 0) {
        setPkStatements.push({
          type: "alter_table_alter_column_set_pk",
          tableName,
          schema: schema4,
          columnName
        });
      }
    }
    if (((_o = column4.onUpdate) == null ? void 0 : _o.type) === "added") {
      statements.push({
        type: "alter_table_alter_column_set_on_update",
        tableName,
        columnName,
        schema: schema4,
        newDataType: columnType,
        columnDefault,
        columnOnUpdate,
        columnNotNull,
        columnAutoIncrement,
        columnPk
      });
    }
    if (((_p = column4.onUpdate) == null ? void 0 : _p.type) === "deleted") {
      statements.push({
        type: "alter_table_alter_column_drop_on_update",
        tableName,
        columnName,
        schema: schema4,
        newDataType: columnType,
        columnDefault,
        columnOnUpdate,
        columnNotNull,
        columnAutoIncrement,
        columnPk
      });
    }
  }
  return [...dropPkStatements, ...setPkStatements, ...statements];
};
var prepareCreateIndexesJson = (tableName, schema4, indexes) => {
  return Object.values(indexes).map((indexData) => {
    return {
      type: "create_index",
      tableName,
      data: indexData,
      schema: schema4
    };
  });
};
var prepareCreateReferencesJson = (tableName, schema4, foreignKeys) => {
  return Object.values(foreignKeys).map((fkData) => {
    return {
      type: "create_reference",
      tableName,
      data: fkData,
      schema: schema4
    };
  });
};
var prepareDropReferencesJson = (tableName, schema4, foreignKeys) => {
  return Object.values(foreignKeys).map((fkData) => {
    return {
      type: "delete_reference",
      tableName,
      data: fkData,
      schema: schema4
    };
  });
};
var prepareAlterReferencesJson = (tableName, schema4, foreignKeys) => {
  const keys = Object.keys(foreignKeys);
  const stmts = [];
  if (keys.length > 0) {
    stmts.push(
      ...prepareDropReferencesJson(tableName, schema4, {
        [keys[0]]: foreignKeys[keys[0]].__old
      })
    );
    stmts.push(
      ...prepareCreateReferencesJson(tableName, schema4, {
        [keys[0]]: foreignKeys[keys[0]].__new
      })
    );
  }
  return stmts;
};
var prepareDropIndexesJson = (tableName, schema4, indexes) => {
  return Object.values(indexes).map((indexData) => {
    return {
      type: "drop_index",
      tableName,
      data: indexData,
      schema: schema4
    };
  });
};
var prepareAddCompositePrimaryKeySqlite = (tableName, pks) => {
  return Object.values(pks).map((it) => {
    return {
      type: "create_composite_pk",
      tableName,
      data: it
    };
  });
};
var prepareDeleteCompositePrimaryKeySqlite = (tableName, pks) => {
  return Object.values(pks).map((it) => {
    return {
      type: "delete_composite_pk",
      tableName,
      data: it
    };
  });
};
var prepareAlterCompositePrimaryKeySqlite = (tableName, pks) => {
  return Object.values(pks).map((it) => {
    return {
      type: "alter_composite_pk",
      tableName,
      old: it.__old,
      new: it.__new
    };
  });
};
var prepareAddCompositePrimaryKeyPg = (tableName, schema4, pks, json2) => {
  return Object.values(pks).map((it) => {
    return {
      type: "create_composite_pk",
      tableName,
      data: it,
      schema: schema4,
      constraintName: json2.tables[tableName].compositePrimaryKeys[`${tableName}_${PgSquasher.unsquashPK(it).columns.join("_")}`].name
    };
  });
};
var prepareDeleteCompositePrimaryKeyPg = (tableName, schema4, pks, json1) => {
  return Object.values(pks).map((it) => {
    return {
      type: "delete_composite_pk",
      tableName,
      data: it,
      schema: schema4,
      constraintName: json1.tables[tableName].compositePrimaryKeys[`${tableName}_${PgSquasher.unsquashPK(it).columns.join("_")}`].name
    };
  });
};
var prepareAlterCompositePrimaryKeyPg = (tableName, schema4, pks, json1, json2) => {
  return Object.values(pks).map((it) => {
    return {
      type: "alter_composite_pk",
      tableName,
      old: it.__old,
      new: it.__new,
      schema: schema4,
      oldConstraintName: json1.tables[tableName].compositePrimaryKeys[`${tableName}_${PgSquasher.unsquashPK(it.__old).columns.join("_")}`].name,
      newConstraintName: json2.tables[tableName].compositePrimaryKeys[`${tableName}_${PgSquasher.unsquashPK(it.__new).columns.join("_")}`].name
    };
  });
};
var prepareAddUniqueConstraintPg = (tableName, schema4, unqs) => {
  return Object.values(unqs).map((it) => {
    return {
      type: "create_unique_constraint",
      tableName,
      data: it,
      schema: schema4
    };
  });
};
var prepareDeleteUniqueConstraintPg = (tableName, schema4, unqs) => {
  return Object.values(unqs).map((it) => {
    return {
      type: "delete_unique_constraint",
      tableName,
      data: it,
      schema: schema4
    };
  });
};
var prepareAddCompositePrimaryKeyMySql = (tableName, pks, json1, json2) => {
  var _a, _b;
  const res = [];
  for (const it of Object.values(pks)) {
    const unsquashed = MySqlSquasher.unsquashPK(it);
    if (unsquashed.columns.length === 1 && ((_b = (_a = json1.tables[tableName]) == null ? void 0 : _a.columns[unsquashed.columns[0]]) == null ? void 0 : _b.primaryKey)) {
      continue;
    }
    res.push({
      type: "create_composite_pk",
      tableName,
      data: it,
      constraintName: json2.tables[tableName].compositePrimaryKeys[`${tableName}_${unsquashed.columns.join("_")}`].name
    });
  }
  return res;
};
var prepareDeleteCompositePrimaryKeyMySql = (tableName, pks, json1) => {
  return Object.values(pks).map((it) => {
    return {
      type: "delete_composite_pk",
      tableName,
      data: it,
      constraintName: json1.tables[tableName].compositePrimaryKeys[`${tableName}_${MySqlSquasher.unsquashPK(it).columns.join("_")}`].name
    };
  });
};
var prepareAlterCompositePrimaryKeyMySql = (tableName, pks, json1, json2) => {
  return Object.values(pks).map((it) => {
    return {
      type: "alter_composite_pk",
      tableName,
      old: it.__old,
      new: it.__new,
      oldConstraintName: json1.tables[tableName].compositePrimaryKeys[`${tableName}_${MySqlSquasher.unsquashPK(it.__old).columns.join("_")}`].name,
      newConstraintName: json2.tables[tableName].compositePrimaryKeys[`${tableName}_${MySqlSquasher.unsquashPK(it.__new).columns.join("_")}`].name
    };
  });
};

// src/snapshotsDiffer.ts
var makeChanged = (schema4) => {
  return objectType({
    type: enumType(["changed"]),
    old: schema4,
    new: schema4
  });
};
var makeSelfOrChanged = (schema4) => {
  return unionType([
    schema4,
    objectType({
      type: enumType(["changed"]),
      old: schema4,
      new: schema4
    })
  ]);
};
var makePatched = (schema4) => {
  return unionType([
    objectType({
      type: literalType("added"),
      value: schema4
    }),
    objectType({
      type: literalType("deleted"),
      value: schema4
    }),
    objectType({
      type: literalType("changed"),
      old: schema4,
      new: schema4
    })
  ]);
};
var makeSelfOrPatched = (schema4) => {
  return unionType([
    objectType({
      type: literalType("none"),
      value: schema4.optional()
    }),
    objectType({
      type: literalType("added"),
      value: schema4
    }),
    objectType({
      type: literalType("deleted"),
      value: schema4
    }),
    objectType({
      type: literalType("changed"),
      old: schema4,
      new: schema4
    })
  ]);
};
var valueFromSelfOrPatchedNew = (it) => {
  switch (it.type) {
    case "none":
      return it.value;
    case "added":
      return it.value;
    case "deleted":
      return it.value;
    case "changed":
      return it.new;
  }
};
var columnSchema = objectType({
  name: stringType(),
  type: stringType(),
  primaryKey: booleanType().optional(),
  default: anyType().optional(),
  notNull: booleanType().optional(),
  // should it be optional? should if be here?
  autoincrement: booleanType().optional(),
  onUpdate: booleanType().optional(),
  isUnique: anyType().optional(),
  uniqueName: stringType().optional(),
  nullsNotDistinct: booleanType().optional()
}).strict();
var alteredColumnSchema = objectType({
  name: makeSelfOrChanged(stringType()),
  type: makeChanged(stringType()).optional(),
  default: makePatched(anyType()).optional(),
  primaryKey: makePatched(booleanType()).optional(),
  notNull: makePatched(booleanType()).optional(),
  onUpdate: makePatched(booleanType()).optional(),
  autoincrement: makePatched(booleanType()).optional()
}).strict();
var enumSchema2 = objectType({
  name: stringType(),
  values: arrayType(stringType())
}).strict();
var changedEnumSchema = objectType({
  name: stringType(),
  addedValues: arrayType(stringType()),
  deletedValues: arrayType(stringType())
}).strict();
var tableScheme = objectType({
  name: stringType(),
  schema: stringType().default(""),
  columns: recordType(stringType(), columnSchema),
  indexes: recordType(stringType(), stringType()),
  foreignKeys: recordType(stringType(), stringType()),
  compositePrimaryKeys: recordType(stringType(), stringType()).default({}),
  uniqueConstraints: recordType(stringType(), stringType()).default({})
}).strict();
var alteredTableScheme = objectType({
  name: stringType(),
  schema: makeSelfOrPatched(stringType()),
  deleted: columnSchema.array(),
  added: columnSchema.array(),
  altered: alteredColumnSchema.array(),
  addedIndexes: recordType(stringType(), stringType()),
  deletedIndexes: recordType(stringType(), stringType()),
  alteredIndexes: recordType(
    stringType(),
    objectType({
      __new: stringType(),
      __old: stringType()
    }).strict()
  ),
  addedForeignKeys: recordType(stringType(), stringType()),
  deletedForeignKeys: recordType(stringType(), stringType()),
  alteredForeignKeys: recordType(
    stringType(),
    objectType({
      __new: stringType(),
      __old: stringType()
    }).strict()
  ),
  addedCompositePKs: recordType(stringType(), stringType()),
  deletedCompositePKs: recordType(stringType(), stringType()),
  alteredCompositePKs: recordType(
    stringType(),
    objectType({
      __new: stringType(),
      __old: stringType()
    })
  ),
  addedUniqueConstraints: recordType(stringType(), stringType()),
  deletedUniqueConstraints: recordType(stringType(), stringType()),
  alteredUniqueConstraints: recordType(
    stringType(),
    objectType({
      __new: stringType(),
      __old: stringType()
    })
  )
}).strict();
var diffResultScheme = objectType({
  addedTables: tableScheme.array(),
  deletedTables: tableScheme.array(),
  alteredTablesWithColumns: alteredTableScheme.array(),
  addedEnums: enumSchema2.array(),
  deletedEnums: enumSchema2.array(),
  alteredEnums: changedEnumSchema.array(),
  addedSchemas: stringType().array(),
  deletedSchemas: stringType().array()
}).strict();
var applySnapshotsDiff = async (json1, json2, dialect3, schemasResolver, tablesResolver, columnsResolver, prevFull, curFull) => {
  var _a, _b;
  let diffResult;
  if (dialect3 === "mysql") {
    for (const tableName in json1.tables) {
      const table4 = json1.tables[tableName];
      for (const indexName in table4.indexes) {
        const index4 = MySqlSquasher.unsquashIdx(table4.indexes[indexName]);
        if (index4.isUnique) {
          table4.uniqueConstraints[indexName] = MySqlSquasher.squashUnique({
            name: index4.name,
            columns: index4.columns
          });
          delete json1.tables[tableName].indexes[index4.name];
        }
      }
    }
    for (const tableName in json2.tables) {
      const table4 = json2.tables[tableName];
      for (const indexName in table4.indexes) {
        const index4 = MySqlSquasher.unsquashIdx(table4.indexes[indexName]);
        if (index4.isUnique) {
          table4.uniqueConstraints[indexName] = MySqlSquasher.squashUnique({
            name: index4.name,
            columns: index4.columns
          });
          delete json2.tables[tableName].indexes[index4.name];
        }
      }
    }
    diffResult = applyJsonDiff(json1, json2);
  }
  diffResult = applyJsonDiff(json1, json2);
  if (Object.keys(diffResult).length === 0) {
    return { statements: [], sqlStatements: [], _meta: void 0 };
  }
  const typedResult = diffResultScheme.parse(diffResult);
  const {
    created: createdSchemas,
    deleted: deletedSchemas,
    renamed: renamedSchemas
  } = await schemasResolver({
    created: typedResult.addedSchemas.map((it) => ({ name: it })),
    deleted: typedResult.deletedSchemas.map((it) => ({ name: it }))
  });
  const { created, deleted, renamed } = await tablesResolver({
    created: typedResult.addedTables,
    deleted: typedResult.deletedTables
  });
  const rSchemas = renamedSchemas.map((it) => ({
    from: it.from.name,
    to: it.to.name
  }));
  const rTables = renamed.map((it) => {
    return { from: it.from, to: it.to };
  });
  const jsonStatements = [];
  const jsonSQLiteCreateTables = created.map((it) => {
    return prepareSQLiteCreateTable(it);
  });
  const jsonCreateIndexesForCreatedTables = created.map((it) => {
    return prepareCreateIndexesJson(it.name, it.schema, it.indexes);
  }).flat();
  const jsonDropTables = deleted.map((it) => {
    return prepareDropTableJson(it);
  });
  const jsonRenameTables = renamed.map((it) => {
    return prepareRenameTableJson(it.from, it.to);
  });
  const renamedWithAlternations = Object.values(
    alteredTableScheme.array().parse(diffForRenamedTables(renamed))
  ).map((it) => it);
  const allAltered = typedResult.alteredTablesWithColumns.concat(
    renamedWithAlternations
  );
  const jsonRenameColumnsStatements = [];
  const allAlteredResolved = [];
  for (const table4 of allAltered) {
    const schemaUnwrapped = valueFromSelfOrPatchedNew(table4.schema);
    const result = await columnsResolver({
      tableName: table4.name,
      schema: schemaUnwrapped,
      created: table4.added,
      deleted: table4.deleted
    });
    const schema4 = valueFromSelfOrPatchedNew(table4.schema);
    jsonRenameColumnsStatements.push(
      ...prepareRenameColumns(table4.name, schema4, result.renamed)
    );
    const renamedColumnsAltered = result.renamed.map(
      (it) => alteredColumnSchema.parse(diffForRenamedColumn(it.from, it.to))
    );
    const allAltered2 = table4.altered.concat(renamedColumnsAltered);
    const resolved = {
      name: table4.name,
      schema: table4.schema,
      deleted: result.deleted,
      added: result.created,
      altered: allAltered2,
      addedIndexes: table4.addedIndexes,
      deletedIndexes: table4.deletedIndexes,
      alteredIndexes: table4.alteredIndexes,
      addedForeignKeys: table4.addedForeignKeys,
      deletedForeignKeys: table4.deletedForeignKeys,
      alteredForeignKeys: table4.alteredForeignKeys,
      addedCompositePKs: table4.addedCompositePKs,
      deletedCompositePKs: table4.deletedCompositePKs,
      alteredCompositePKs: table4.alteredCompositePKs,
      addedUniqueConstraints: table4.addedUniqueConstraints,
      deletedUniqueConstraints: table4.deletedUniqueConstraints,
      alteredUniqueConstraints: table4.alteredUniqueConstraints
    };
    allAlteredResolved.push(resolved);
  }
  const jsonAddedCompositePKs = [];
  const jsonDeletedCompositePKs = [];
  const jsonAlteredCompositePKs = [];
  const jsonAddedUniqueConstraints = [];
  const jsonDeletedUniqueConstraints = [];
  const jsonAlteredUniqueConstraints = [];
  const jsonSetTableSchemas = [];
  const jsonRemoveTableFromSchemas = [];
  const jsonSetNewTableSchemas = [];
  allAlteredResolved.forEach((it) => {
    const schemaUnwrapped = valueFromSelfOrPatchedNew(it.schema);
    let addedColumns = [];
    for (const addedPkName of Object.keys(it.addedCompositePKs)) {
      const addedPkColumns = it.addedCompositePKs[addedPkName];
      if (dialect3 === "sqlite") {
        addedColumns = SQLiteSquasher.unsquashPK(addedPkColumns);
      } else if (dialect3 === "mysql") {
        addedColumns = MySqlSquasher.unsquashPK(addedPkColumns).columns;
      } else {
        addedColumns = SQLiteSquasher.unsquashPK(addedPkColumns);
      }
    }
    let deletedColumns = [];
    for (const deletedPkName of Object.keys(it.deletedCompositePKs)) {
      const deletedPkColumns = it.deletedCompositePKs[deletedPkName];
      if (dialect3 === "sqlite") {
        deletedColumns = SQLiteSquasher.unsquashPK(deletedPkColumns);
      } else if (dialect3 === "mysql") {
        deletedColumns = MySqlSquasher.unsquashPK(deletedPkColumns).columns;
      } else {
        deletedColumns = SQLiteSquasher.unsquashPK(deletedPkColumns);
      }
    }
    addedColumns.sort();
    deletedColumns.sort();
    const doPerformDeleteAndCreate = JSON.stringify(addedColumns) !== JSON.stringify(deletedColumns);
    let addedCompositePKs = [];
    let deletedCompositePKs = [];
    let alteredCompositePKs = [];
    if (dialect3 === "sqlite") {
      if (doPerformDeleteAndCreate) {
        addedCompositePKs = prepareAddCompositePrimaryKeySqlite(
          it.name,
          it.addedCompositePKs
        );
        deletedCompositePKs = prepareDeleteCompositePrimaryKeySqlite(
          it.name,
          it.deletedCompositePKs
        );
      }
      alteredCompositePKs = prepareAlterCompositePrimaryKeySqlite(
        it.name,
        it.alteredCompositePKs
      );
    } else if (dialect3 === "pg") {
      if (doPerformDeleteAndCreate) {
        addedCompositePKs = prepareAddCompositePrimaryKeyPg(
          it.name,
          schemaUnwrapped,
          it.addedCompositePKs,
          curFull
        );
        deletedCompositePKs = prepareDeleteCompositePrimaryKeyPg(
          it.name,
          schemaUnwrapped,
          it.deletedCompositePKs,
          prevFull
        );
      }
      alteredCompositePKs = prepareAlterCompositePrimaryKeyPg(
        it.name,
        schemaUnwrapped,
        it.alteredCompositePKs,
        prevFull,
        curFull
      );
    } else {
      if (doPerformDeleteAndCreate) {
        addedCompositePKs = prepareAddCompositePrimaryKeyMySql(
          it.name,
          it.addedCompositePKs,
          prevFull,
          curFull
        );
        deletedCompositePKs = prepareDeleteCompositePrimaryKeyMySql(
          it.name,
          it.deletedCompositePKs,
          prevFull
        );
      }
      alteredCompositePKs = prepareAlterCompositePrimaryKeyMySql(
        it.name,
        it.alteredCompositePKs,
        prevFull,
        curFull
      );
    }
    let addedUniqueConstraints = [];
    let deletedUniqueConstraints = [];
    let alteredUniqueConstraints = [];
    addedUniqueConstraints = prepareAddUniqueConstraintPg(
      it.name,
      schemaUnwrapped,
      it.addedUniqueConstraints
    );
    deletedUniqueConstraints = prepareDeleteUniqueConstraintPg(
      it.name,
      schemaUnwrapped,
      it.deletedUniqueConstraints
    );
    if (it.alteredUniqueConstraints) {
      const added = {};
      const deleted2 = {};
      for (const k of Object.keys(it.alteredUniqueConstraints)) {
        added[k] = it.alteredUniqueConstraints[k].__new;
        deleted2[k] = it.alteredUniqueConstraints[k].__old;
      }
      addedUniqueConstraints.push(
        ...prepareAddUniqueConstraintPg(it.name, schemaUnwrapped, added)
      );
      deletedUniqueConstraints.push(
        ...prepareDeleteUniqueConstraintPg(it.name, schemaUnwrapped, deleted2)
      );
    }
    if (it.schema && typeof it.schema !== "string") {
      switch (it.schema.type) {
        case "added": {
          jsonSetTableSchemas.push({
            schema: it.schema.value,
            tableName: it.name,
            type: "alter_table_set_schema"
          });
          break;
        }
        case "changed": {
          jsonSetNewTableSchemas.push({
            type: "alter_table_set_new_schema",
            tableName: it.name,
            from: it.schema.old,
            to: it.schema.new
          });
          break;
        }
        case "deleted": {
          jsonRemoveTableFromSchemas.push({
            type: "alter_table_remove_from_schema",
            tableName: it.name,
            schema: it.schema.value
          });
          break;
        }
      }
    }
    jsonAddedCompositePKs.push(...addedCompositePKs);
    jsonDeletedCompositePKs.push(...deletedCompositePKs);
    jsonAlteredCompositePKs.push(...alteredCompositePKs);
    jsonAddedUniqueConstraints.push(...addedUniqueConstraints);
    jsonDeletedUniqueConstraints.push(...deletedUniqueConstraints);
    jsonAlteredUniqueConstraints.push(...alteredUniqueConstraints);
  });
  const rColumns = jsonRenameColumnsStatements.map((it) => {
    const tableName = it.tableName;
    const schema4 = it.schema;
    return {
      from: { schema: schema4, table: tableName, column: it.oldColumnName },
      to: { schema: schema4, table: tableName, column: it.newColumnName }
    };
  });
  const jsonTableAlternations = allAlteredResolved.map((it) => {
    const schema4 = valueFromSelfOrPatchedNew(it.schema);
    return prepareAlterTableColumnsJson(
      it.name,
      schema4,
      it.deleted,
      it.added,
      it.altered,
      it.addedForeignKeys,
      json2,
      dialect3
    );
  }).flat().reduce(
    (res, it) => {
      res.createColumns.push(...it.addColumns);
      res.dropColumns.push(...it.dropColumns);
      res.alterColumns.push(...it.alterColumns);
      return res;
    },
    { createColumns: [], dropColumns: [], alterColumns: [] }
  );
  const jsonCreateIndexesForAllAlteredTables = allAltered.map((it) => {
    const schema4 = valueFromSelfOrPatchedNew(it.schema);
    return prepareCreateIndexesJson(it.name, schema4, it.addedIndexes || {});
  }).flat();
  const jsonDropIndexesForAllAlteredTables = allAltered.map((it) => {
    const schema4 = valueFromSelfOrPatchedNew(it.schema);
    return prepareDropIndexesJson(it.name, schema4, it.deletedIndexes || {});
  }).flat();
  allAltered.forEach((it) => {
    const schema4 = valueFromSelfOrPatchedNew(it.schema);
    const droppedIndexes = Object.keys(it.alteredIndexes).reduce(
      (current, item) => {
        current[item] = it.alteredIndexes[item].__old;
        return current;
      },
      {}
    );
    const createdIndexes = Object.keys(it.alteredIndexes).reduce(
      (current, item) => {
        current[item] = it.alteredIndexes[item].__new;
        return current;
      },
      {}
    );
    jsonCreateIndexesForAllAlteredTables.push(
      ...prepareCreateIndexesJson(it.name, schema4, createdIndexes || {})
    );
    jsonDropIndexesForAllAlteredTables.push(
      ...prepareDropIndexesJson(it.name, schema4, droppedIndexes || {})
    );
  });
  const jsonCreateReferencesForCreatedTables = created.map((it) => {
    return prepareCreateReferencesJson(it.name, it.schema, it.foreignKeys);
  }).flat();
  const jsonReferencesForAllAlteredTables = allAltered.map((it) => {
    const schema4 = valueFromSelfOrPatchedNew(it.schema);
    const forAdded = prepareCreateReferencesJson(
      it.name,
      schema4,
      it.addedForeignKeys
    );
    const forAltered = prepareDropReferencesJson(
      it.name,
      schema4,
      it.deletedForeignKeys
    );
    const alteredFKs = prepareAlterReferencesJson(
      it.name,
      schema4,
      it.alteredForeignKeys
    );
    return [...forAdded, ...forAltered, ...alteredFKs];
  }).flat();
  const jsonCreateReferences = jsonCreateReferencesForCreatedTables;
  const jsonCreatedReferencesForAlteredTables = jsonReferencesForAllAlteredTables.filter(
    (t) => t.type === "create_reference"
  );
  const jsonDroppedReferencesForAlteredTables = jsonReferencesForAllAlteredTables.filter(
    (t) => t.type === "delete_reference"
  );
  const createEnums = ((_a = typedResult.addedEnums) == null ? void 0 : _a.map((it) => {
    return prepareCreateEnumJson(it.name, it.values);
  })) ?? [];
  const jsonAlterEnumsWithAddedValues = ((_b = typedResult.alteredEnums) == null ? void 0 : _b.map((it) => {
    return prepareAddValuesToEnumJson(it.name, it.addedValues);
  }).flat()) ?? [];
  if (dialect3 === "mysql") {
    createdSchemas.push(...renamedSchemas.map((it) => it.to));
    deletedSchemas.push(...renamedSchemas.map((it) => it.from));
    renamedSchemas.splice(0, renamedSchemas.length);
  }
  const createSchemas = prepareCreateSchemasJson(
    createdSchemas.map((it) => it.name)
  );
  const renameSchemas = prepareRenameSchemasJson(
    renamedSchemas.map((it) => ({ from: it.from.name, to: it.to.name }))
  );
  const dropSchemas = prepareDeleteSchemasJson(
    deletedSchemas.map((it) => it.name)
  );
  const renamedSchemasSet = new Set(
    renameSchemas.map((it) => `${it.from}-${it.to}`)
  );
  const filteredJsonSetNewTableSchemas = jsonSetNewTableSchemas.filter((it) => {
    return !renamedSchemasSet.has(`${it.from}-${it.to}`);
  });
  jsonStatements.push(...createSchemas);
  jsonStatements.push(...renameSchemas);
  jsonStatements.push(...createEnums);
  jsonStatements.push(...jsonAlterEnumsWithAddedValues);
  if (dialect3 === "sqlite") {
    jsonStatements.push(...jsonSQLiteCreateTables);
  } else if (dialect3 === "pg") {
    const jsonPgCreateTables = created.map((it) => {
      return preparePgCreateTableJson(it, curFull);
    });
    jsonStatements.push(...jsonPgCreateTables);
  } else {
    const jsonMySqlCreateTables = created.map((it) => {
      return prepareMySqlCreateTableJson(it, curFull);
    });
    jsonStatements.push(...jsonMySqlCreateTables);
  }
  jsonStatements.push(...jsonDroppedReferencesForAlteredTables);
  jsonStatements.push(...jsonDropTables);
  jsonStatements.push(...jsonRenameTables);
  jsonStatements.push(...jsonRenameColumnsStatements);
  jsonStatements.push(...jsonDeletedCompositePKs);
  jsonStatements.push(...jsonDeletedUniqueConstraints);
  jsonStatements.push(...jsonDropIndexesForAllAlteredTables);
  jsonStatements.push(...jsonTableAlternations.alterColumns);
  jsonStatements.push(...jsonTableAlternations.createColumns);
  jsonStatements.push(...jsonCreateIndexesForCreatedTables);
  jsonStatements.push(...jsonCreateIndexesForAllAlteredTables);
  jsonStatements.push(...jsonCreatedReferencesForAlteredTables);
  jsonStatements.push(...jsonTableAlternations.dropColumns);
  if (dialect3 !== "sqlite")
    jsonStatements.push(...jsonCreateReferences);
  jsonStatements.push(...jsonAddedCompositePKs);
  jsonStatements.push(...jsonAlteredCompositePKs);
  jsonStatements.push(...jsonAddedUniqueConstraints);
  jsonStatements.push(...jsonAlteredUniqueConstraints);
  jsonStatements.push(...jsonSetTableSchemas);
  jsonStatements.push(...filteredJsonSetNewTableSchemas);
  jsonStatements.push(...jsonRemoveTableFromSchemas);
  jsonStatements.push(...dropSchemas);
  const sqlStatements = fromJson(jsonStatements, dialect3);
  const uniqueSqlStatements = [];
  sqlStatements.forEach((ss) => {
    if (!uniqueSqlStatements.includes(ss)) {
      uniqueSqlStatements.push(ss);
    }
  });
  const _meta = prepareMigrationMeta(rSchemas, rTables, rColumns);
  return {
    statements: jsonStatements,
    sqlStatements: uniqueSqlStatements,
    _meta
  };
};

// src/cli/commands/pgUp.ts
init_source();

// src/cli/commands/mysqlUp.ts
init_source();

// src/cli/commands/upFolders.ts
var resolveSchemas = (missingSchemas, newSchemas, predicate) => {
  try {
    if (missingSchemas.length === 0 || newSchemas.length === 0) {
      return { created: newSchemas, renamed: [], deleted: missingSchemas };
    }
    const result = {
      created: [],
      renamed: [],
      deleted: []
    };
    let index4 = 0;
    let leftMissing = [...missingSchemas];
    do {
      const created = newSchemas[index4];
      index4 += 1;
      const renamed = predicate(leftMissing, created);
      if (!renamed) {
        result.created.push(created);
      } else {
        const it = renamed;
        result.renamed.push({ from: it, to: created });
        delete leftMissing[leftMissing.indexOf(it)];
        leftMissing = leftMissing.filter(Boolean);
      }
    } while (index4 < newSchemas.length);
    result.deleted.push(...leftMissing);
    return result;
  } catch (e) {
    console.error(e);
    throw e;
  }
};
var resolveTables = (missingTables, newTables, resolver) => {
  try {
    if (missingTables.length === 0 || newTables.length === 0) {
      return { created: newTables, renamed: [], deleted: missingTables };
    }
    const result = {
      created: [],
      renamed: [],
      deleted: []
    };
    let index4 = 0;
    let leftMissing = [...missingTables];
    do {
      const created = newTables[index4];
      index4 += 1;
      const renamed = resolver(leftMissing, created);
      if (!renamed) {
        result.created.push(created);
      } else {
        const it = renamed;
        result.renamed.push({ from: it, to: created });
        delete leftMissing[leftMissing.indexOf(it)];
        leftMissing = leftMissing.filter(Boolean);
      }
    } while (index4 < newTables.length);
    result.deleted.push(...leftMissing);
    return result;
  } catch (e) {
    console.error(e);
    throw e;
  }
};
var resolveColumns = (missingColumns, newColumns, predicate) => {
  try {
    if (missingColumns.length === 0 || newColumns.length === 0) {
      return { created: newColumns, renamed: [], deleted: missingColumns };
    }
    const result = {
      created: [],
      renamed: [],
      deleted: []
    };
    let index4 = 0;
    let leftMissing = [...missingColumns];
    do {
      const created = newColumns[index4];
      index4 += 1;
      const renamed = predicate(leftMissing, created);
      if (!renamed) {
        result.created.push(created);
      } else {
        const it = renamed;
        result.renamed.push({ from: it, to: created });
        delete leftMissing[leftMissing.indexOf(it)];
        leftMissing = leftMissing.filter(Boolean);
      }
    } while (index4 < newColumns.length);
    result.deleted.push(...leftMissing);
    return result;
  } catch (e) {
    console.error(e);
    throw e;
  }
};

// src/utils.ts
var assertV1OutFolder = (out, dialect3) => {
  if (!(0, import_fs.existsSync)(out))
    return;
  const oldMigrationFolders = (0, import_fs.readdirSync)(out).filter(
    (it) => it.length === 14 && /^\d+$/.test(it)
  );
  if (oldMigrationFolders.length > 0) {
    console.log(
      `Your migrations folder format is outdated, please run ${source_default.green.bold(
        `drizzle-kit up:${dialect3}`
      )}`
    );
    process.exit(1);
  }
};
var dryJournal = (dialect3) => {
  return {
    version: snapshotVersion,
    dialect: dialect3,
    entries: []
  };
};
var snapshotsPriorV4 = (out) => {
  const oldMigrationFolders = (0, import_fs.readdirSync)(out).filter(
    (it) => it.length === 14 && /^\d+$/.test(it)
  );
  oldMigrationFolders.sort();
  return oldMigrationFolders.map((it) => {
    const pathJson = (0, import_path.join)(out, it, "snapshot.json");
    console.log(pathJson);
    return pathJson;
  });
};
var prepareOutFolder2 = (out, dialect3) => {
  const meta = (0, import_path.join)(out, "meta");
  const journalPath = (0, import_path.join)(meta, "_journal.json");
  if (!(0, import_fs.existsSync)((0, import_path.join)(out, "meta"))) {
    (0, import_fs.mkdirSync)(meta, { recursive: true });
    (0, import_fs.writeFileSync)(journalPath, JSON.stringify(dryJournal(dialect3)));
  }
  const journal = JSON.parse((0, import_fs.readFileSync)(journalPath).toString());
  const snapshots = (0, import_fs.readdirSync)(meta).filter((it) => !it.startsWith("_")).map((it) => (0, import_path.join)(meta, it));
  snapshots.sort();
  return { meta, snapshots, journal };
};
var mapValues = (obj, map) => {
  const result = Object.keys(obj).reduce(function(result2, key) {
    result2[key] = map(obj[key]);
    return result2;
  }, {});
  return result;
};
var validatorForDialect = (dialect3) => {
  switch (dialect3) {
    case "pg":
      return { validator: backwardCompatiblePgSchema, version: 5 };
    case "sqlite":
      return { validator: backwardCompatibleSqliteSchema, version: 5 };
    case "mysql":
      return { validator: backwardCompatibleMysqlSchema, version: 5 };
  }
};
var validateWithReport = (snapshots, dialect3) => {
  const { validator, version } = validatorForDialect(dialect3);
  const result = snapshots.reduce(
    (accum, it) => {
      const raw = JSON.parse((0, import_fs.readFileSync)(`./${it}`).toString());
      accum.rawMap[it] = raw;
      if (raw["version"] && Number(raw["version"]) > version) {
        console.log(
          info(
            `${it} snapshot is of unsupported version, please update drizzle-kit`
          )
        );
        process.exit(0);
      }
      const result2 = validator.safeParse(raw);
      if (!result2.success) {
        accum.malformed.push(it);
        return accum;
      }
      const snapshot = result2.data;
      if (snapshot.version !== String(version)) {
        accum.nonLatest.push(it);
        return accum;
      }
      const idEntry = accum.idsMap[snapshot["prevId"]] ?? {
        parent: it,
        snapshots: []
      };
      idEntry.snapshots.push(it);
      accum.idsMap[snapshot["prevId"]] = idEntry;
      return accum;
    },
    {
      malformed: [],
      nonLatest: [],
      idToNameMap: {},
      idsMap: {},
      rawMap: {}
    }
  );
  return result;
};
var prepareMigrationFolder = (outFolder = "drizzle", dialect3) => {
  const { snapshots, journal } = prepareOutFolder2(outFolder, dialect3);
  const report = validateWithReport(snapshots, dialect3);
  if (report.nonLatest.length > 0) {
    console.log(
      report.nonLatest.map((it) => {
        return `${it}/snapshot.json is not of the latest version`;
      }).concat(`Run ${source_default.green.bold(`drizzle-kit up:${dialect3}`)}`).join("\n")
    );
    process.exit(0);
  }
  if (report.malformed.length) {
    const message2 = report.malformed.map((it) => {
      return `${it} data is malformed`;
    }).join("\n");
    console.log(message2);
  }
  const collisionEntries = Object.entries(report.idsMap).filter(
    (it) => it[1].snapshots.length > 1
  );
  const message = collisionEntries.map((it) => {
    const data = it[1];
    return `[${data.snapshots.join(
      ", "
    )}] are pointing to a parent snapshot: ${data.parent}/snapshot.json which is a collision.`;
  }).join("\n").trim();
  if (message) {
    console.log(source_default.red.bold("Error:"), message);
  }
  const abort = report.malformed.length || collisionEntries.length > 0;
  if (abort) {
    process.exit(0);
  }
  return { snapshots, journal };
};
var prepareMigrationMeta = (schemas, tables, columns) => {
  const _meta = {
    schemas: {},
    tables: {},
    columns: {}
  };
  schemas.forEach((it) => {
    const from = schemaRenameKey(it.from);
    const to = schemaRenameKey(it.to);
    _meta.schemas[from] = to;
  });
  tables.forEach((it) => {
    const from = tableRenameKey(it.from);
    const to = tableRenameKey(it.to);
    _meta.tables[from] = to;
  });
  columns.forEach((it) => {
    const from = columnRenameKey(it.from.table, it.from.schema, it.from.column);
    const to = columnRenameKey(it.to.table, it.to.schema, it.to.column);
    _meta.columns[from] = to;
  });
  return _meta;
};
var schemaRenameKey = (it) => {
  return it;
};
var tableRenameKey = (it) => {
  const out = it.schema ? `"${it.schema}"."${it.name}"` : `"${it.name}"`;
  return out;
};
var columnRenameKey = (table4, schema4, column4) => {
  const out = schema4 ? `"${schema4}"."${table4}"."${column4}"` : `"${table4}"."${column4}"`;
  return out;
};
var kloudMeta = () => {
  return {
    pg: [5],
    mysql: [],
    sqlite: []
  };
};
var statementsForDiffs = async (in1, in2) => {
  const left = pgSchema.parse(in1 ?? dryPg);
  const right = pgSchema.parse(in2);
  const lsquashed = squashPgScheme(left);
  const rsquashed = squashPgScheme(right);
  const schemasChecker = (leftMissing, created) => {
    for (let i = 0; i < leftMissing.length; i++) {
      const it = leftMissing[i];
      if (right._meta.schemas[it.name] === created.name) {
        return it;
      }
    }
    return void 0;
  };
  const schemasResolver = async (input) => {
    const { created, deleted, renamed } = resolveSchemas(
      input.deleted,
      input.created,
      schemasChecker
    );
    return { created, deleted, renamed };
  };
  const tablesChecker = (leftMissing, created) => {
    for (let i = 0; i < leftMissing.length; i++) {
      const it = leftMissing[i];
      if (right._meta.tables[tableRenameKey(it)] === tableRenameKey(created)) {
        return it;
      }
    }
    return void 0;
  };
  const tablesResolver = async (input) => {
    const { created, deleted, renamed } = resolveTables(
      input.deleted,
      input.created,
      tablesChecker
    );
    return { created, deleted, renamed };
  };
  const columnsResolver = async (input) => {
    const tableName = input.tableName;
    const schema4 = input.schema;
    const predicate = (leftMissing, created2) => {
      for (let i = 0; i < leftMissing.length; i++) {
        const it = leftMissing[i];
        if (right._meta.columns[columnRenameKey(tableName, schema4, it.name)] === columnRenameKey(tableName, schema4, created2.name)) {
          return it;
        }
      }
      return void 0;
    };
    const { created, deleted, renamed } = resolveColumns(
      input.deleted,
      input.created,
      predicate
    );
    return { tableName, schema: schema4, created, renamed, deleted };
  };
  const result = await applySnapshotsDiff(
    lsquashed,
    rsquashed,
    "pg",
    schemasResolver,
    tablesResolver,
    columnsResolver
  );
  return { ...result, left, right };
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  assertV1OutFolder,
  columnRenameKey,
  dryJournal,
  kloudMeta,
  mapValues,
  prepareMigrationFolder,
  prepareMigrationMeta,
  prepareOutFolder,
  schemaRenameKey,
  snapshotsPriorV4,
  statementsForDiffs,
  tableRenameKey,
  validateWithReport
});
