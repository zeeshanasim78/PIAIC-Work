import { e as entityKind, aM as AnySQLiteTable, aF as KnownKeysOnly, aJ as ColumnsSelection, ah as Subquery, ai as WithSubquery, ax as DrizzleTypeError, X as SQLWrapper, Q as Query, a as SQL, aq as UpdateSet, aS as SQLiteTable, aL as SQLiteColumn, I as InferModel, G as GetColumnData, a9 as Param, S as Simplify, ad as Placeholder, b0 as IndexColumn, ay as ValueOrArray, aK as SQLiteColumnBuilder, o as BuildColumns, V as View, T as Table, b9 as SQLiteTableWithColumns, al as UpdateTableConfig, av as Assume, y as SelectedFieldsFlat$1, E as SelectedFields$1, F as SelectedFieldsOrdered$1 } from './column.d-04875079.js';
import { A as AddAliasToSelection, T as TypedQueryBuilder, f as SelectResultFields, G as GetSelectTableName, a as GetSelectTableSelection, S as SelectMode, J as JoinNullability, B as BuildSubquerySelection, b as SelectResult, c as JoinType, M as MapColumnsToTableAlias, d as AppendToResult, e as AppendToNullabilityMap } from './select.types.d-f5caa4d6.js';
import { MigrationMeta } from './migrator.js';
import { T as TablesRelationalConfig, L as TableRelationalConfig, K as DBQueryConfig, V as BuildQueryResult, Q as QueryPromise, N as ExtractTablesWithRelations, R as RelationalSchemaConfig, a as Relation, a3 as BuildRelationalQueryResult } from './query-promise.d-31db3408.js';

declare class AsyncRelationalQueryBuilder<TFullSchema extends Record<string, unknown>, TSchema extends TablesRelationalConfig, TFields extends TableRelationalConfig> {
    private fullSchema;
    private schema;
    private tableNamesMap;
    private table;
    private tableConfig;
    private dialect;
    private session;
    static readonly [entityKind]: string;
    constructor(fullSchema: Record<string, unknown>, schema: TSchema, tableNamesMap: Record<string, string>, table: AnySQLiteTable, tableConfig: TableRelationalConfig, dialect: SQLiteDialect, session: SQLiteSession<'async', unknown, TFullSchema, TSchema>);
    findMany<TConfig extends DBQueryConfig<'many', true, TSchema, TFields>>(config?: KnownKeysOnly<TConfig, DBQueryConfig<'many', true, TSchema, TFields>>): SQLiteAsyncRelationalQuery<BuildQueryResult<TSchema, TFields, TConfig>[]>;
    findFirst<TSelection extends Omit<DBQueryConfig<'many', true, TSchema, TFields>, 'limit'>>(config?: KnownKeysOnly<TSelection, Omit<DBQueryConfig<'many', true, TSchema, TFields>, 'limit'>>): SQLiteAsyncRelationalQuery<BuildQueryResult<TSchema, TFields, TSelection> | undefined>;
}
declare class SyncRelationalQueryBuilder<TFullSchema extends Record<string, unknown>, TSchema extends TablesRelationalConfig, TFields extends TableRelationalConfig> {
    private fullSchema;
    private schema;
    private tableNamesMap;
    private table;
    private tableConfig;
    private dialect;
    private session;
    static readonly [entityKind]: string;
    constructor(fullSchema: Record<string, unknown>, schema: TSchema, tableNamesMap: Record<string, string>, table: AnySQLiteTable, tableConfig: TableRelationalConfig, dialect: SQLiteDialect, session: SQLiteSession<'sync', unknown, TFullSchema, TSchema>);
    prepareFindMany<TConfig extends DBQueryConfig<'many', true, TSchema, TFields>>(config?: KnownKeysOnly<TConfig, DBQueryConfig<'many', true, TSchema, TFields>>): {
        execute: PreparedQuery<PreparedQueryConfig & {
            type: 'sync';
            all: BuildQueryResult<TSchema, TFields, TConfig>[];
        }>['all'];
    };
    findMany<TConfig extends DBQueryConfig<'many', true, TSchema, TFields>>(config?: KnownKeysOnly<TConfig, DBQueryConfig<'many', true, TSchema, TFields>>): BuildQueryResult<TSchema, TFields, TConfig>[];
    prepareFindFirst<TConfig extends DBQueryConfig<'many', true, TSchema, TFields>>(config?: KnownKeysOnly<TConfig, DBQueryConfig<'many', true, TSchema, TFields>>): {
        execute: PreparedQuery<PreparedQueryConfig & {
            type: 'sync';
            get: BuildQueryResult<TSchema, TFields, TConfig> | undefined;
        }>['get'];
    };
    findFirst<TSelection extends Omit<DBQueryConfig<'many', true, TSchema, TFields>, 'limit'>>(config?: KnownKeysOnly<TSelection, Omit<DBQueryConfig<'many', true, TSchema, TFields>, 'limit'>>): BuildQueryResult<TSchema, TFields, TSelection> | undefined;
}
declare class SQLiteRelationalQuery<TResultKind extends 'sync' | 'async', TResult> {
    private fullSchema;
    private schema;
    private tableNamesMap;
    private table;
    private tableConfig;
    private dialect;
    private session;
    private config;
    private mode;
    static readonly [entityKind]: string;
    protected $brand: 'SQLiteRelationalQuery';
    constructor(fullSchema: Record<string, unknown>, schema: TablesRelationalConfig, tableNamesMap: Record<string, string>, table: AnySQLiteTable, tableConfig: TableRelationalConfig, dialect: SQLiteDialect, session: SQLiteSession<TResultKind, unknown, Record<string, unknown>, TablesRelationalConfig>, config: DBQueryConfig<'many', true> | true, mode: 'many' | 'first');
    prepare(): PreparedQuery<PreparedQueryConfig & {
        type: TResultKind;
        all: TResult;
        get: TResult;
    }>;
    execute(): Result<TResultKind, TResult>;
}
interface SQLiteAsyncRelationalQuery<TResult> extends SQLiteRelationalQuery<'async', TResult>, QueryPromise<TResult> {
}

type SubqueryWithSelection<TSelection extends ColumnsSelection, TAlias extends string> = Subquery<TAlias, AddAliasToSelection<TSelection, TAlias, 'sqlite'>> & AddAliasToSelection<TSelection, TAlias, 'sqlite'>;
type WithSubqueryWithSelection<TSelection extends ColumnsSelection, TAlias extends string> = WithSubquery<TAlias, AddAliasToSelection<TSelection, TAlias, 'sqlite'>> & AddAliasToSelection<TSelection, TAlias, 'sqlite'>;

declare class BaseSQLiteDatabase<TResultKind extends 'sync' | 'async', TRunResult, TFullSchema extends Record<string, unknown> = Record<string, never>, TSchema extends TablesRelationalConfig = ExtractTablesWithRelations<TFullSchema>> {
    static readonly [entityKind]: string;
    readonly _: {
        readonly schema: TSchema | undefined;
        readonly tableNamesMap: Record<string, string>;
    };
    query: TFullSchema extends Record<string, never> ? DrizzleTypeError<'Seems like the schema generic is missing - did you forget to add it to your DB type?'> : {
        [K in keyof TSchema]: TResultKind extends 'async' ? AsyncRelationalQueryBuilder<TFullSchema, TSchema, TSchema[K]> : SyncRelationalQueryBuilder<TFullSchema, TSchema, TSchema[K]>;
    };
    constructor(resultKind: TResultKind, 
    /** @internal */
    dialect: {
        sync: SQLiteSyncDialect;
        async: SQLiteAsyncDialect;
    }[TResultKind], 
    /** @internal */
    session: SQLiteSession<TResultKind, TRunResult, TFullSchema, TSchema>, schema: RelationalSchemaConfig<TSchema> | undefined);
    $with<TAlias extends string>(alias: TAlias): {
        as<TSelection extends ColumnsSelection>(qb: TypedQueryBuilder<TSelection, unknown> | ((qb: QueryBuilder) => TypedQueryBuilder<TSelection, unknown>)): WithSubqueryWithSelection<TSelection, TAlias>;
    };
    with(...queries: WithSubquery[]): {
        select: {
            (): SQLiteSelectBuilder<undefined, TResultKind, TRunResult>;
            <TSelection extends SelectedFields>(fields: TSelection): SQLiteSelectBuilder<TSelection, TResultKind, TRunResult, "db">;
        };
        selectDistinct: {
            (): SQLiteSelectBuilder<undefined, TResultKind, TRunResult>;
            <TSelection_1 extends SelectedFields>(fields: TSelection_1): SQLiteSelectBuilder<TSelection_1, TResultKind, TRunResult, "db">;
        };
    };
    select(): SQLiteSelectBuilder<undefined, TResultKind, TRunResult>;
    select<TSelection extends SelectedFields>(fields: TSelection): SQLiteSelectBuilder<TSelection, TResultKind, TRunResult>;
    selectDistinct(): SQLiteSelectBuilder<undefined, TResultKind, TRunResult>;
    selectDistinct<TSelection extends SelectedFields>(fields: TSelection): SQLiteSelectBuilder<TSelection, TResultKind, TRunResult>;
    update<TTable extends AnySQLiteTable>(table: TTable): SQLiteUpdateBuilder<TTable, TResultKind, TRunResult>;
    insert<TTable extends AnySQLiteTable>(into: TTable): SQLiteInsertBuilder<TTable, TResultKind, TRunResult>;
    delete<TTable extends AnySQLiteTable>(from: TTable): SQLiteDelete<TTable, TResultKind, TRunResult>;
    run(query: SQLWrapper): Result<TResultKind, TRunResult>;
    all<T = unknown>(query: SQLWrapper): Result<TResultKind, T[]>;
    get<T = unknown>(query: SQLWrapper): Result<TResultKind, T>;
    values<T extends unknown[] = unknown[]>(query: SQLWrapper): Result<TResultKind, T[]>;
    transaction<T>(transaction: (tx: SQLiteTransaction<TResultKind, TRunResult, TFullSchema, TSchema>) => Result<TResultKind, T>, config?: SQLiteTransactionConfig): Result<TResultKind, T>;
}

interface PreparedQueryConfig {
    type: 'sync' | 'async';
    run: unknown;
    all: unknown[];
    get: unknown;
    values: unknown[][];
}
declare abstract class PreparedQuery<T extends PreparedQueryConfig> {
    static readonly [entityKind]: string;
    abstract run(placeholderValues?: Record<string, unknown>): Result<T['type'], T['run']>;
    abstract all(placeholderValues?: Record<string, unknown>): Result<T['type'], T['all']>;
    abstract get(placeholderValues?: Record<string, unknown>): Result<T['type'], T['get']>;
    abstract values(placeholderValues?: Record<string, unknown>): Result<T['type'], T['values']>;
}
interface SQLiteTransactionConfig {
    behavior?: 'deferred' | 'immediate' | 'exclusive';
}
declare abstract class SQLiteSession<TResultKind extends 'sync' | 'async', TRunResult, TFullSchema extends Record<string, unknown>, TSchema extends TablesRelationalConfig> {
    static readonly [entityKind]: string;
    constructor(
    /** @internal */
    dialect: {
        sync: SQLiteSyncDialect;
        async: SQLiteAsyncDialect;
    }[TResultKind]);
    abstract prepareQuery(query: Query, fields: SelectedFieldsOrdered | undefined, customResultMapper?: (rows: unknown[][], mapColumnValue?: (value: unknown) => unknown) => unknown): PreparedQuery<PreparedQueryConfig & {
        type: TResultKind;
    }>;
    prepareOneTimeQuery(query: Query, fields: SelectedFieldsOrdered | undefined): PreparedQuery<PreparedQueryConfig & {
        type: TResultKind;
    }>;
    abstract transaction<T>(transaction: (tx: SQLiteTransaction<TResultKind, TRunResult, TFullSchema, TSchema>) => Result<TResultKind, T>, config?: SQLiteTransactionConfig): Result<TResultKind, T>;
    run(query: SQL): Result<TResultKind, TRunResult>;
    all<T = unknown>(query: SQL): Result<TResultKind, T[]>;
    get<T = unknown>(query: SQL): Result<TResultKind, T>;
    values<T extends any[] = unknown[]>(query: SQL): Result<TResultKind, T[]>;
}
interface ResultHKT {
    readonly $brand: 'SQLiteResultHKT';
    readonly config: unknown;
    readonly type: unknown;
}
interface SyncResultHKT extends ResultHKT {
    readonly type: this['config'];
}
interface AsyncResultHKT extends ResultHKT {
    readonly type: Promise<this['config']>;
}
type Result<TKind extends 'sync' | 'async', TResult> = (('sync' extends TKind ? SyncResultHKT : AsyncResultHKT) & {
    readonly config: TResult;
})['type'];
declare abstract class SQLiteTransaction<TResultType extends 'sync' | 'async', TRunResult, TFullSchema extends Record<string, unknown>, TSchema extends TablesRelationalConfig> extends BaseSQLiteDatabase<TResultType, TRunResult, TFullSchema, TSchema> {
    protected schema: {
        fullSchema: Record<string, unknown>;
        schema: TSchema;
        tableNamesMap: Record<string, string>;
    } | undefined;
    protected readonly nestedIndex: number;
    static readonly [entityKind]: string;
    constructor(resultType: TResultType, dialect: {
        sync: SQLiteSyncDialect;
        async: SQLiteAsyncDialect;
    }[TResultType], session: SQLiteSession<TResultType, TRunResult, TFullSchema, TSchema>, schema: {
        fullSchema: Record<string, unknown>;
        schema: TSchema;
        tableNamesMap: Record<string, string>;
    } | undefined, nestedIndex?: number);
    rollback(): never;
}

declare abstract class SQLiteDialect {
    static readonly [entityKind]: string;
    escapeName(name: string): string;
    escapeParam(_num: number): string;
    escapeString(str: string): string;
    buildDeleteQuery({ table, where, returning }: SQLiteDeleteConfig): SQL;
    buildUpdateSet(table: AnySQLiteTable, set: UpdateSet): SQL;
    buildUpdateQuery({ table, set, where, returning }: SQLiteUpdateConfig): SQL;
    /**
     * Builds selection SQL with provided fields/expressions
     *
     * Examples:
     *
     * `select <selection> from`
     *
     * `insert ... returning <selection>`
     *
     * If `isSingleTable` is true, then columns won't be prefixed with table name
     */
    private buildSelection;
    buildSelectQuery({ withList, fields, fieldsFlat, where, having, table, joins, orderBy, groupBy, limit, offset, distinct }: SQLiteSelectConfig): SQL;
    buildInsertQuery({ table, values, onConflict, returning }: SQLiteInsertConfig): SQL;
    sqlToQuery(sql: SQL): Query;
    buildRelationalQuery({ fullSchema, schema, tableNamesMap, table, tableConfig, queryConfig: config, tableAlias, nestedQueryRelation, joinOn, }: {
        fullSchema: Record<string, unknown>;
        schema: TablesRelationalConfig;
        tableNamesMap: Record<string, string>;
        table: AnySQLiteTable;
        tableConfig: TableRelationalConfig;
        queryConfig: true | DBQueryConfig<'many', true>;
        tableAlias: string;
        nestedQueryRelation?: Relation;
        joinOn?: SQL;
    }): BuildRelationalQueryResult<SQLiteTable, SQLiteColumn>;
}
declare class SQLiteSyncDialect extends SQLiteDialect {
    static readonly [entityKind]: string;
    migrate(migrations: MigrationMeta[], session: SQLiteSession<'sync', unknown, Record<string, unknown>, TablesRelationalConfig>): void;
}
declare class SQLiteAsyncDialect extends SQLiteDialect {
    static readonly [entityKind]: string;
    migrate(migrations: MigrationMeta[], session: SQLiteSession<'async', unknown, Record<string, unknown>, TablesRelationalConfig>): Promise<void>;
}

interface SQLiteDeleteConfig {
    where?: SQL | undefined;
    table: SQLiteTable;
    returning?: SelectedFieldsOrdered;
}
interface SQLiteDelete<TTable extends SQLiteTable, TResultType extends 'sync' | 'async', TRunResult, TReturning = undefined> extends SQLWrapper {
}
declare class SQLiteDelete<TTable extends SQLiteTable, TResultType extends 'sync' | 'async', TRunResult, TReturning = undefined> implements SQLWrapper {
    private table;
    private session;
    private dialect;
    static readonly [entityKind]: string;
    private config;
    constructor(table: TTable, session: SQLiteSession<any, any, any, any>, dialect: SQLiteDialect);
    where(where: SQL | undefined): Omit<this, 'where'>;
    returning(): Omit<SQLiteDelete<TTable, TResultType, TRunResult, InferModel<TTable>>, 'where' | 'returning'>;
    returning<TSelectedFields extends SelectedFieldsFlat>(fields: TSelectedFields): Omit<SQLiteDelete<TTable, TResultType, TRunResult, SelectResultFields<TSelectedFields>>, 'where' | 'returning'>;
    toSQL(): Omit<Query, 'typings'>;
    prepare(isOneTimeQuery?: boolean): PreparedQuery<{
        type: TResultType;
        run: TRunResult;
        all: TReturning extends undefined ? never : TReturning[];
        get: TReturning extends undefined ? never : TReturning | undefined;
        values: TReturning extends undefined ? never : any[][];
    }>;
    run: ReturnType<this['prepare']>['run'];
    all: ReturnType<this['prepare']>['all'];
    get: ReturnType<this['prepare']>['get'];
    values: ReturnType<this['prepare']>['values'];
}

interface SQLiteUpdateConfig {
    where?: SQL | undefined;
    set: UpdateSet;
    table: AnySQLiteTable;
    returning?: SelectedFieldsOrdered;
}
type SQLiteUpdateSetSource<TTable extends AnySQLiteTable> = {
    [Key in keyof TTable['_']['columns']]?: GetColumnData<TTable['_']['columns'][Key], 'query'> | SQL;
} & {};
declare class SQLiteUpdateBuilder<TTable extends AnySQLiteTable, TResultType extends 'sync' | 'async', TRunResult> {
    protected table: TTable;
    protected session: SQLiteSession<any, any, any, any>;
    protected dialect: SQLiteDialect;
    static readonly [entityKind]: string;
    readonly _: {
        readonly table: TTable;
    };
    constructor(table: TTable, session: SQLiteSession<any, any, any, any>, dialect: SQLiteDialect);
    set(values: SQLiteUpdateSetSource<TTable>): SQLiteUpdate<TTable, TResultType, TRunResult>;
}
interface SQLiteUpdate<TTable extends AnySQLiteTable, TResultType extends 'sync' | 'async', TRunResult, TReturning = undefined> extends SQLWrapper {
}
declare class SQLiteUpdate<TTable extends AnySQLiteTable, TResultType extends 'sync' | 'async', TRunResult, TReturning = undefined> implements SQLWrapper {
    private session;
    private dialect;
    static readonly [entityKind]: string;
    readonly _: {
        readonly table: TTable;
    };
    private config;
    constructor(table: TTable, set: UpdateSet, session: SQLiteSession<any, any, any, any>, dialect: SQLiteDialect);
    where(where: SQL | undefined): Omit<this, 'where'>;
    returning(): Omit<SQLiteUpdate<TTable, TResultType, TRunResult, InferModel<TTable>>, 'where' | 'returning'>;
    returning<TSelectedFields extends SelectedFields>(fields: TSelectedFields): Omit<SQLiteUpdate<TTable, TResultType, TRunResult, SelectResultFields<TSelectedFields>>, 'where' | 'returning'>;
    toSQL(): {
        sql: Query['sql'];
        params: Query['params'];
    };
    prepare(isOneTimeQuery?: boolean): PreparedQuery<{
        type: TResultType;
        run: TRunResult;
        all: TReturning extends undefined ? never : TReturning[];
        get: TReturning extends undefined ? never : TReturning;
        values: TReturning extends undefined ? never : any[][];
    }>;
    run: ReturnType<this['prepare']>['run'];
    all: ReturnType<this['prepare']>['all'];
    get: ReturnType<this['prepare']>['get'];
    values: ReturnType<this['prepare']>['values'];
}

interface SQLiteInsertConfig<TTable extends AnySQLiteTable = AnySQLiteTable> {
    table: TTable;
    values: Record<string, Param | SQL>[];
    onConflict?: SQL;
    returning?: SelectedFieldsOrdered;
}
type SQLiteInsertValue<TTable extends AnySQLiteTable> = Simplify<{
    [Key in keyof InferModel<TTable, 'insert'>]: InferModel<TTable, 'insert'>[Key] | SQL | Placeholder;
}>;
declare class SQLiteInsertBuilder<TTable extends AnySQLiteTable, TResultType extends 'sync' | 'async', TRunResult> {
    protected table: TTable;
    protected session: SQLiteSession<any, any, any, any>;
    protected dialect: SQLiteDialect;
    static readonly [entityKind]: string;
    constructor(table: TTable, session: SQLiteSession<any, any, any, any>, dialect: SQLiteDialect);
    values(value: SQLiteInsertValue<TTable>): SQLiteInsert<TTable, TResultType, TRunResult>;
    values(values: SQLiteInsertValue<TTable>[]): SQLiteInsert<TTable, TResultType, TRunResult>;
}
interface SQLiteInsert<TTable extends AnySQLiteTable, TResultType extends 'sync' | 'async', TRunResult, TReturning = undefined> extends SQLWrapper {
}
declare class SQLiteInsert<TTable extends AnySQLiteTable, TResultType extends 'sync' | 'async', TRunResult, TReturning = undefined> implements SQLWrapper {
    private session;
    private dialect;
    static readonly [entityKind]: string;
    readonly _: {
        readonly table: TTable;
        readonly resultType: TResultType;
        readonly runResult: TRunResult;
        readonly returning: TReturning;
    };
    private config;
    constructor(table: TTable, values: SQLiteInsertConfig['values'], session: SQLiteSession<any, any, any, any>, dialect: SQLiteDialect);
    returning(): Omit<SQLiteInsert<TTable, TResultType, TRunResult, InferModel<TTable>>, 'returning' | `onConflict${string}`>;
    returning<TSelectedFields extends SelectedFieldsFlat>(fields: TSelectedFields): Omit<SQLiteInsert<TTable, TResultType, TRunResult, SelectResultFields<TSelectedFields>>, 'returning' | `onConflict${string}`>;
    onConflictDoNothing(config?: {
        target?: IndexColumn | IndexColumn[];
        where?: SQL;
    }): this;
    onConflictDoUpdate(config: {
        target: IndexColumn | IndexColumn[];
        where?: SQL;
        set: SQLiteUpdateSetSource<TTable>;
    }): this;
    toSQL(): Simplify<{
        sql: Query['sql'];
        params: Query['params'];
    }>;
    prepare(isOneTimeQuery?: boolean): PreparedQuery<{
        type: TResultType;
        run: TRunResult;
        all: TReturning extends undefined ? never : TReturning[];
        get: TReturning extends undefined ? never : TReturning;
        values: TReturning extends undefined ? never : any[][];
    }>;
    run: ReturnType<this['prepare']>['run'];
    all: ReturnType<this['prepare']>['all'];
    get: ReturnType<this['prepare']>['get'];
    values: ReturnType<this['prepare']>['values'];
}

type CreateSQLiteSelectFromBuilderMode<TBuilderMode extends 'db' | 'qb', TTableName extends string | undefined, TResultType extends 'sync' | 'async', TRunResult, TSelection extends ColumnsSelection, TSelectMode extends SelectMode> = TBuilderMode extends 'db' ? SQLiteSelect<TTableName, TResultType, TRunResult, TSelection, TSelectMode> : SQLiteSelectQueryBuilder<SQLiteSelectQueryBuilderHKT, TTableName, TResultType, TRunResult, TSelection, TSelectMode>;
declare class SQLiteSelectBuilder<TSelection extends SelectedFields | undefined, TResultType extends 'sync' | 'async', TRunResult, TBuilderMode extends 'db' | 'qb' = 'db'> {
    static readonly [entityKind]: string;
    private fields;
    private session;
    private dialect;
    private withList;
    private distinct;
    constructor(config: {
        fields: TSelection;
        session: SQLiteSession<any, any, any, any> | undefined;
        dialect: SQLiteDialect;
        withList?: Subquery[];
        distinct?: boolean;
    });
    from<TFrom extends AnySQLiteTable | Subquery | SQLiteViewBase | SQL>(source: TFrom): CreateSQLiteSelectFromBuilderMode<TBuilderMode, GetSelectTableName<TFrom>, TResultType, TRunResult, TSelection extends undefined ? GetSelectTableSelection<TFrom> : TSelection, TSelection extends undefined ? 'single' : 'partial'>;
}
declare abstract class SQLiteSelectQueryBuilder<THKT extends SQLiteSelectHKTBase, TTableName extends string | undefined, TResultType extends 'sync' | 'async', TRunResult, TSelection extends ColumnsSelection, TSelectMode extends SelectMode, TNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'> : {}> extends TypedQueryBuilder<BuildSubquerySelection<TSelection, TNullabilityMap>, SelectResult<TSelection, TSelectMode, TNullabilityMap>[]> {
    static readonly [entityKind]: string;
    readonly _: {
        readonly selectMode: TSelectMode;
        readonly selection: TSelection;
        readonly result: SelectResult<TSelection, TSelectMode, TNullabilityMap>[];
        readonly selectedFields: BuildSubquerySelection<TSelection, TNullabilityMap>;
    };
    protected config: SQLiteSelectConfig;
    protected joinsNotNullableMap: Record<string, boolean>;
    private tableName;
    private isPartialSelect;
    protected session: SQLiteSession<any, any, any, any> | undefined;
    protected dialect: SQLiteDialect;
    constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }: {
        table: SQLiteSelectConfig['table'];
        fields: SQLiteSelectConfig['fields'];
        isPartialSelect: boolean;
        session: SQLiteSession<any, any, any, any> | undefined;
        dialect: SQLiteDialect;
        withList: Subquery[] | undefined;
        distinct: boolean | undefined;
    });
    private createJoin;
    leftJoin: JoinFn<THKT, TTableName, TResultType, TRunResult, TSelectMode, "left", TSelection, TNullabilityMap>;
    rightJoin: JoinFn<THKT, TTableName, TResultType, TRunResult, TSelectMode, "right", TSelection, TNullabilityMap>;
    innerJoin: JoinFn<THKT, TTableName, TResultType, TRunResult, TSelectMode, "inner", TSelection, TNullabilityMap>;
    fullJoin: JoinFn<THKT, TTableName, TResultType, TRunResult, TSelectMode, "full", TSelection, TNullabilityMap>;
    where(where: ((aliases: TSelection) => SQL | undefined) | SQL | undefined): this;
    having(having: ((aliases: TSelection) => SQL | undefined) | SQL | undefined): this;
    groupBy(builder: (aliases: TSelection) => ValueOrArray<SQLiteColumn | SQL | SQL.Aliased>): this;
    groupBy(...columns: (SQLiteColumn | SQL)[]): this;
    orderBy(builder: (aliases: TSelection) => ValueOrArray<SQLiteColumn | SQL | SQL.Aliased>): this;
    orderBy(...columns: (SQLiteColumn | SQL)[]): this;
    limit(limit: number | Placeholder): this;
    offset(offset: number | Placeholder): this;
    toSQL(): {
        sql: Query['sql'];
        params: Query['params'];
    };
    as<TAlias extends string>(alias: TAlias): SubqueryWithSelection<BuildSubquerySelection<TSelection, TNullabilityMap>, TAlias>;
    getSelectedFields(): BuildSubquerySelection<TSelection, TNullabilityMap>;
}
interface SQLiteSelect<TTableName extends string | undefined, TResultType extends 'sync' | 'async', TRunResult, TSelection extends ColumnsSelection, TSelectMode extends SelectMode = 'single', TNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'> : {}> extends SQLiteSelectQueryBuilder<SQLiteSelectHKT, TTableName | undefined, TResultType, TRunResult, TSelection, TSelectMode, TNullabilityMap> {
}
declare class SQLiteSelect<TTableName extends string | undefined, TResultType extends 'sync' | 'async', TRunResult, TSelection, TSelectMode extends SelectMode = 'single', TNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'> : {}> extends SQLiteSelectQueryBuilder<SQLiteSelectHKT, TTableName, TResultType, TRunResult, TSelection, TSelectMode, TNullabilityMap> {
    static readonly [entityKind]: string;
    prepare(isOneTimeQuery?: boolean): PreparedQuery<{
        type: TResultType;
        run: TRunResult;
        all: SelectResult<TSelection, TSelectMode, TNullabilityMap>[];
        get: SelectResult<TSelection, TSelectMode, TNullabilityMap> | undefined;
        values: any[][];
    }>;
    run: ReturnType<this['prepare']>['run'];
    all: ReturnType<this['prepare']>['all'];
    get: ReturnType<this['prepare']>['get'];
    values: ReturnType<this['prepare']>['values'];
}

declare class QueryBuilder {
    static readonly [entityKind]: string;
    private dialect;
    $with<TAlias extends string>(alias: TAlias): {
        as<TSelection extends ColumnsSelection>(qb: TypedQueryBuilder<TSelection, unknown> | ((qb: QueryBuilder) => TypedQueryBuilder<TSelection, unknown>)): WithSubqueryWithSelection<TSelection, TAlias>;
    };
    with(...queries: WithSubquery[]): {
        select: {
            (): SQLiteSelectBuilder<undefined, 'sync', void, 'qb'>;
            <TSelection extends SelectedFields>(fields: TSelection): SQLiteSelectBuilder<TSelection, "sync", void, "qb">;
        };
        selectDistinct: {
            (): SQLiteSelectBuilder<undefined, 'sync', void, 'qb'>;
            <TSelection_1 extends SelectedFields>(fields: TSelection_1): SQLiteSelectBuilder<TSelection_1, "sync", void, "qb">;
        };
    };
    select(): SQLiteSelectBuilder<undefined, 'sync', void, 'qb'>;
    select<TSelection extends SelectedFields>(fields: TSelection): SQLiteSelectBuilder<TSelection, 'sync', void, 'qb'>;
    selectDistinct(): SQLiteSelectBuilder<undefined, 'sync', void, 'qb'>;
    selectDistinct<TSelection extends SelectedFields>(fields: TSelection): SQLiteSelectBuilder<TSelection, 'sync', void, 'qb'>;
    private getDialect;
}

interface ViewBuilderConfig {
    algorithm?: 'undefined' | 'merge' | 'temptable';
    definer?: string;
    sqlSecurity?: 'definer' | 'invoker';
    withCheckOption?: 'cascaded' | 'local';
}
declare class ViewBuilderCore<TConfig extends {
    name: string;
    columns?: unknown;
}> {
    protected name: TConfig['name'];
    static readonly [entityKind]: string;
    readonly _: {
        readonly name: TConfig['name'];
        readonly columns: TConfig['columns'];
    };
    constructor(name: TConfig['name']);
    protected config: ViewBuilderConfig;
}
declare class ViewBuilder<TName extends string = string> extends ViewBuilderCore<{
    name: TName;
}> {
    static readonly [entityKind]: string;
    as<TSelection extends SelectedFields>(qb: TypedQueryBuilder<TSelection> | ((qb: QueryBuilder) => TypedQueryBuilder<TSelection>)): SQLiteViewWithSelection<TName, false, AddAliasToSelection<TSelection, TName, 'sqlite'>>;
}
declare class ManualViewBuilder<TName extends string = string, TColumns extends Record<string, SQLiteColumnBuilder> = Record<string, SQLiteColumnBuilder>> extends ViewBuilderCore<{
    name: TName;
    columns: TColumns;
}> {
    static readonly [entityKind]: string;
    private columns;
    constructor(name: TName, columns: TColumns);
    existing(): SQLiteViewWithSelection<TName, true, BuildColumns<TName, TColumns, 'sqlite'>>;
    as(query: SQL): SQLiteViewWithSelection<TName, false, BuildColumns<TName, TColumns, 'sqlite'>>;
}
declare abstract class SQLiteViewBase<TName extends string = string, TExisting extends boolean = boolean, TSelection extends ColumnsSelection = ColumnsSelection> extends View<TName, TExisting, TSelection> {
    static readonly [entityKind]: string;
    _: View<TName, TExisting, TSelection>['_'] & {
        viewBrand: 'SQLiteView';
    };
}
declare const SQLiteViewConfig: unique symbol;
declare class SQLiteView<TName extends string = string, TExisting extends boolean = boolean, TSelection extends ColumnsSelection = ColumnsSelection> extends SQLiteViewBase<TName, TExisting, TSelection> {
    static readonly [entityKind]: string;
    constructor({ sqliteConfig, config }: {
        sqliteConfig: ViewBuilderConfig | undefined;
        config: {
            name: TName;
            schema: string | undefined;
            selectedFields: SelectedFields;
            query: SQL | undefined;
        };
    });
}
type SQLiteViewWithSelection<TName extends string, TExisting extends boolean, TSelection extends ColumnsSelection> = SQLiteView<TName, TExisting, TSelection> & TSelection;
declare function sqliteView<TName extends string>(name: TName): ViewBuilder<TName>;
declare function sqliteView<TName extends string, TColumns extends Record<string, SQLiteColumnBuilder>>(name: TName, columns: TColumns): ManualViewBuilder<TName, TColumns>;
declare const view: typeof sqliteView;

interface Join {
    on: SQL | undefined;
    table: SQLiteTable | Subquery | SQLiteViewBase | SQL;
    alias: string | undefined;
    joinType: JoinType;
}
type AnySQLiteSelect = SQLiteSelect<any, any, any, any, any, any>;
type BuildAliasTable<TTable extends SQLiteTable | View, TAlias extends string> = TTable extends Table ? SQLiteTableWithColumns<UpdateTableConfig<TTable['_']['config'], {
    name: TAlias;
    columns: MapColumnsToTableAlias<TTable['_']['columns'], TAlias, 'sqlite'>;
}>> : TTable extends View ? SQLiteViewWithSelection<TAlias, TTable['_']['existing'], MapColumnsToTableAlias<TTable['_']['selectedFields'], TAlias, 'sqlite'>> : never;
interface SQLiteSelectConfig {
    withList?: Subquery[];
    fields: Record<string, unknown>;
    fieldsFlat?: SelectedFieldsOrdered;
    where?: SQL;
    having?: SQL;
    table: SQLiteTable | Subquery | SQLiteViewBase | SQL;
    limit?: number | Placeholder;
    offset?: number | Placeholder;
    joins?: Join[];
    orderBy?: (SQLiteColumn | SQL | SQL.Aliased)[];
    groupBy?: (SQLiteColumn | SQL | SQL.Aliased)[];
    distinct?: boolean;
}
type JoinFn<THKT extends SQLiteSelectHKTBase, TTableName extends string | undefined, TResultType extends 'sync' | 'async', TRunResult, TSelectMode extends SelectMode, TJoinType extends JoinType, TSelection, TNullabilityMap extends Record<string, JoinNullability>> = <TJoinedTable extends SQLiteTable | Subquery | SQLiteViewBase | SQL, TJoinedName extends GetSelectTableName<TJoinedTable> = GetSelectTableName<TJoinedTable>>(table: TJoinedTable, on: ((aliases: TSelection) => SQL | undefined) | SQL | undefined) => SQLiteSelectKind<THKT, TTableName, TResultType, TRunResult, AppendToResult<TTableName, TSelection, TJoinedName, TJoinedTable extends SQLiteTable ? TJoinedTable['_']['columns'] : TJoinedTable extends Subquery | View ? Assume<TJoinedTable['_']['selectedFields'], SelectedFields> : never, TSelectMode>, TSelectMode extends 'partial' ? TSelectMode : 'multiple', AppendToNullabilityMap<TNullabilityMap, TJoinedName, TJoinType>>;
type SelectedFieldsFlat = SelectedFieldsFlat$1<SQLiteColumn>;
type SelectedFields = SelectedFields$1<SQLiteColumn, SQLiteTable>;
type SelectedFieldsOrdered = SelectedFieldsOrdered$1<SQLiteColumn>;
interface SQLiteSelectHKTBase {
    tableName: string | undefined;
    resultType: 'sync' | 'async';
    runResult: unknown;
    selection: unknown;
    selectMode: SelectMode;
    nullabilityMap: unknown;
    _type: unknown;
}
type SQLiteSelectKind<T extends SQLiteSelectHKTBase, TTableName extends string | undefined, TResultType extends 'sync' | 'async', TRunResult, TSelection, TSelectMode extends SelectMode, TNullabilityMap extends Record<string, JoinNullability>> = (T & {
    tableName: TTableName;
    resultType: TResultType;
    runResult: TRunResult;
    selection: TSelection;
    selectMode: TSelectMode;
    nullabilityMap: TNullabilityMap;
})['_type'];
interface SQLiteSelectQueryBuilderHKT extends SQLiteSelectHKTBase {
    _type: SQLiteSelectQueryBuilder<this, this['tableName'], this['resultType'], this['runResult'], Assume<this['selection'], ColumnsSelection>, this['selectMode'], Assume<this['nullabilityMap'], Record<string, JoinNullability>>>;
}
interface SQLiteSelectHKT extends SQLiteSelectHKTBase {
    _type: SQLiteSelect<this['tableName'], this['resultType'], this['runResult'], Assume<this['selection'], ColumnsSelection>, this['selectMode'], Assume<this['nullabilityMap'], Record<string, JoinNullability>>>;
}

export { AnySQLiteSelect as A, BaseSQLiteDatabase as B, SQLiteSelectHKT as C, SQLiteUpdateConfig as D, SQLiteUpdateSetSource as E, SQLiteUpdateBuilder as F, SQLiteUpdate as G, SubqueryWithSelection as H, ViewBuilderCore as I, Join as J, ViewBuilder as K, SQLiteViewConfig as L, ManualViewBuilder as M, SQLiteViewWithSelection as N, sqliteView as O, PreparedQuery as P, QueryBuilder as Q, Result as R, SQLiteSession as S, view as T, ViewBuilderConfig as V, WithSubqueryWithSelection as W, SQLiteSyncDialect as a, SelectedFieldsOrdered as b, SQLiteTransactionConfig as c, SQLiteTransaction as d, PreparedQueryConfig as e, SQLiteAsyncDialect as f, SQLiteView as g, SQLiteViewBase as h, BuildAliasTable as i, SQLiteDialect as j, SQLiteDeleteConfig as k, SQLiteDelete as l, SQLiteInsertConfig as m, SQLiteInsertValue as n, SQLiteInsertBuilder as o, SQLiteInsert as p, SQLiteSelectBuilder as q, SQLiteSelectQueryBuilder as r, SQLiteSelect as s, SQLiteSelectConfig as t, JoinFn as u, SelectedFieldsFlat as v, SelectedFields as w, SQLiteSelectHKTBase as x, SQLiteSelectKind as y, SQLiteSelectQueryBuilderHKT as z };
