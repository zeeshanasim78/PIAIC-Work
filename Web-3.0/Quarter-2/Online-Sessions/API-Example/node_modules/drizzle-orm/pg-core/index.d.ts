import { P as PgViewBase, B as BuildAliasTable, p as pgView, a as pgMaterializedView, b as PgView, V as ViewWithConfig, c as PgMaterializedView, d as PgMaterializedViewWithConfig } from '../select.types.d-3ce070d1.js';
export { A as AnyPgSelect, T as DefaultViewBuilderCore, J as Join, s as JoinFn, v as LockConfig, L as LockStrength, _ as ManualMaterializedViewBuilder, X as ManualViewBuilder, Z as MaterializedViewBuilder, Y as MaterializedViewBuilderCore, e as PgDatabase, h as PgDelete, g as PgDeleteConfig, f as PgDialect, l as PgInsert, k as PgInsertBuilder, i as PgInsertConfig, j as PgInsertValue, a1 as PgMaterializedViewConfig, a2 as PgMaterializedViewWithSelection, m as PgRefreshMaterializedView, q as PgSelect, n as PgSelectBuilder, r as PgSelectConfig, z as PgSelectHKT, w as PgSelectHKTBase, x as PgSelectKind, o as PgSelectQueryBuilder, y as PgSelectQueryBuilderHKT, K as PgSession, M as PgTransaction, I as PgTransactionConfig, F as PgUpdate, E as PgUpdateBuilder, C as PgUpdateConfig, D as PgUpdateSetSource, $ as PgViewConfig, a0 as PgViewWithSelection, H as PreparedQuery, G as PreparedQueryConfig, Q as QueryBuilder, N as QueryResultHKT, O as QueryResultKind, t as SelectedFields, S as SelectedFieldsFlat, u as SelectedFieldsOrdered, R as SubqueryWithSelection, U as ViewBuilder, W as WithSubqueryWithSelection } from '../select.types.d-3ce070d1.js';
import { i as ColumnBuilderBaseConfig, bq as PgColumnBuilder, e as entityKind, b as ColumnBaseConfig, bo as PgColumn, N as NotNull, H as HasDefault, aC as Writable, bm as AnyPgTable, aw as Equal, a as SQL, g as ColumnDataType, c3 as PgTableFn, c4 as Index, c5 as ForeignKey, c6 as Check, c7 as PrimaryKey, c8 as UniqueConstraint, E as SelectedFields, A as AnyColumn, T as Table, ak as TableConfig, C as Column, bn as AnyPgColumn } from '../column.d-04875079.js';
export { ch as AnyForeignKeyBuilder, ck as AnyIndexBuilder, br as AnyPgColumnBuilder, c9 as CheckBuilder, cg as ForeignKeyBuilder, cm as GetColumnsTableName, cl as IndexBuilder, cj as IndexBuilderOn, bp as IndexColumn, cc as PgArray, cb as PgArrayBuilder, bs as PgTable, cv as PgTableExtraConfig, bt as PgTableWithColumns, cq as PrimaryKeyBuilder, cf as Reference, cd as ReferenceConfig, cw as TableConfig, ct as UniqueConstraintBuilder, cu as UniqueOnConstraintBuilder, ce as UpdateDeleteAction, ca as check, ci as foreignKey, cn as index, cx as pgTable, cy as pgTableCreator, cp as primaryKey, cr as unique, co as uniqueIndex, cs as uniqueKeyName } from '../column.d-04875079.js';
import '../select.types.d-f5caa4d6.js';
import '../query-promise.d-31db3408.js';
import '../migrator.js';

type PgBigInt53BuilderInitial<TName extends string> = PgBigInt53Builder<{
    name: TName;
    dataType: 'number';
    columnType: 'PgBigInt53';
    data: number;
    driverParam: number | string;
    enumValues: undefined;
}>;
declare class PgBigInt53Builder<T extends ColumnBuilderBaseConfig<'number', 'PgBigInt53'>> extends PgColumnBuilder<T> {
    static readonly [entityKind]: string;
    constructor(name: T['name']);
}
declare class PgBigInt53<T extends ColumnBaseConfig<'number', 'PgBigInt53'>> extends PgColumn<T> {
    static readonly [entityKind]: string;
    getSQLType(): string;
    mapFromDriverValue(value: number | string): number;
}
type PgBigInt64BuilderInitial<TName extends string> = PgBigInt64Builder<{
    name: TName;
    dataType: 'bigint';
    columnType: 'PgBigInt64';
    data: bigint;
    driverParam: string;
    enumValues: undefined;
}>;
declare class PgBigInt64Builder<T extends ColumnBuilderBaseConfig<'bigint', 'PgBigInt64'>> extends PgColumnBuilder<T> {
    static readonly [entityKind]: string;
    constructor(name: T['name']);
}
declare class PgBigInt64<T extends ColumnBaseConfig<'bigint', 'PgBigInt64'>> extends PgColumn<T> {
    static readonly [entityKind]: string;
    getSQLType(): string;
    mapFromDriverValue(value: string): bigint;
}
interface PgBigIntConfig<T extends 'number' | 'bigint' = 'number' | 'bigint'> {
    mode: T;
}
declare function bigint<TName extends string, TMode extends PgBigIntConfig['mode']>(name: TName, config: PgBigIntConfig<TMode>): TMode extends 'number' ? PgBigInt53BuilderInitial<TName> : PgBigInt64BuilderInitial<TName>;

type PgBigSerial53BuilderInitial<TName extends string> = NotNull<HasDefault<PgBigSerial53Builder<{
    name: TName;
    dataType: 'number';
    columnType: 'PgBigSerial53';
    data: number;
    driverParam: number;
    enumValues: undefined;
}>>>;
declare class PgBigSerial53Builder<T extends ColumnBuilderBaseConfig<'number', 'PgBigSerial53'>> extends PgColumnBuilder<T> {
    static readonly [entityKind]: string;
    constructor(name: string);
}
declare class PgBigSerial53<T extends ColumnBaseConfig<'number', 'PgBigSerial53'>> extends PgColumn<T> {
    static readonly [entityKind]: string;
    getSQLType(): string;
    mapFromDriverValue(value: number): number;
}
type PgBigSerial64BuilderInitial<TName extends string> = NotNull<HasDefault<PgBigSerial64Builder<{
    name: TName;
    dataType: 'bigint';
    columnType: 'PgBigSerial64';
    data: bigint;
    driverParam: string;
    enumValues: undefined;
}>>>;
declare class PgBigSerial64Builder<T extends ColumnBuilderBaseConfig<'bigint', 'PgBigSerial64'>> extends PgColumnBuilder<T> {
    static readonly [entityKind]: string;
    constructor(name: string);
}
declare class PgBigSerial64<T extends ColumnBaseConfig<'bigint', 'PgBigSerial64'>> extends PgColumn<T> {
    static readonly [entityKind]: string;
    getSQLType(): string;
    mapFromDriverValue(value: string): bigint;
}
interface PgBigSerialConfig<T extends 'number' | 'bigint' = 'number' | 'bigint'> {
    mode: T;
}
declare function bigserial<TName extends string, TMode extends PgBigSerialConfig['mode']>(name: TName, config: PgBigSerialConfig<TMode>): TMode extends 'number' ? PgBigSerial53BuilderInitial<TName> : PgBigSerial64BuilderInitial<TName>;

type PgBooleanBuilderInitial<TName extends string> = PgBooleanBuilder<{
    name: TName;
    dataType: 'boolean';
    columnType: 'PgBoolean';
    data: boolean;
    driverParam: boolean;
    enumValues: undefined;
}>;
declare class PgBooleanBuilder<T extends ColumnBuilderBaseConfig<'boolean', 'PgBoolean'>> extends PgColumnBuilder<T> {
    static readonly [entityKind]: string;
    constructor(name: T['name']);
}
declare class PgBoolean<T extends ColumnBaseConfig<'boolean', 'PgBoolean'>> extends PgColumn<T> {
    static readonly [entityKind]: string;
    getSQLType(): string;
}
declare function boolean<TName extends string>(name: TName): PgBooleanBuilderInitial<TName>;

type PgCharBuilderInitial<TName extends string, TEnum extends [string, ...string[]]> = PgCharBuilder<{
    name: TName;
    dataType: 'string';
    columnType: 'PgChar';
    data: TEnum[number];
    enumValues: TEnum;
    driverParam: string;
}>;
declare class PgCharBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgChar'>> extends PgColumnBuilder<T, {
    length: number | undefined;
    enumValues: T['enumValues'];
}> {
    static readonly [entityKind]: string;
    constructor(name: string, config: PgCharConfig<T['enumValues']>);
}
declare class PgChar<T extends ColumnBaseConfig<'string', 'PgChar'>> extends PgColumn<T, {
    length: number | undefined;
    enumValues: T['enumValues'];
}> {
    static readonly [entityKind]: string;
    readonly length: number | undefined;
    readonly enumValues: T["enumValues"];
    getSQLType(): string;
}
interface PgCharConfig<TEnum extends readonly string[] | string[] | undefined> {
    length?: number;
    enum?: TEnum;
}
declare function char<TName extends string, U extends string, T extends Readonly<[U, ...U[]]>>(name: TName, config?: PgCharConfig<T | Writable<T>>): PgCharBuilderInitial<TName, Writable<T>>;

type PgCidrBuilderInitial<TName extends string> = PgCidrBuilder<{
    name: TName;
    dataType: 'string';
    columnType: 'PgCidr';
    data: string;
    driverParam: string;
    enumValues: undefined;
}>;
declare class PgCidrBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgCidr'>> extends PgColumnBuilder<T> {
    static readonly [entityKind]: string;
    constructor(name: T['name']);
}
declare class PgCidr<T extends ColumnBaseConfig<'string', 'PgCidr'>> extends PgColumn<T> {
    static readonly [entityKind]: string;
    getSQLType(): string;
}
declare function cidr<TName extends string>(name: TName): PgCidrBuilderInitial<TName>;

type ConvertCustomConfig<TName extends string, T extends Partial<CustomTypeValues>> = {
    name: TName;
    dataType: 'custom';
    columnType: 'PgCustomColumn';
    data: T['data'];
    driverParam: T['driverData'];
    enumValues: undefined;
} & (T['notNull'] extends true ? {
    notNull: true;
} : {}) & (T['default'] extends true ? {
    hasDefault: true;
} : {});
interface PgCustomColumnInnerConfig {
    customTypeValues: CustomTypeValues;
}
declare class PgCustomColumnBuilder<T extends ColumnBuilderBaseConfig<'custom', 'PgCustomColumn'>> extends PgColumnBuilder<T, {
    fieldConfig: CustomTypeValues['config'];
    customTypeParams: CustomTypeParams<any>;
}, {
    pgColumnBuilderBrand: 'PgCustomColumnBuilderBrand';
}> {
    static readonly [entityKind]: string;
    constructor(name: T['name'], fieldConfig: CustomTypeValues['config'], customTypeParams: CustomTypeParams<any>);
}
declare class PgCustomColumn<T extends ColumnBaseConfig<'custom', 'PgCustomColumn'>> extends PgColumn<T> {
    static readonly [entityKind]: string;
    private sqlName;
    private mapTo?;
    private mapFrom?;
    constructor(table: AnyPgTable<{
        name: T['tableName'];
    }>, config: PgCustomColumnBuilder<T>['config']);
    getSQLType(): string;
    mapFromDriverValue(value: T['driverParam']): T['data'];
    mapToDriverValue(value: T['data']): T['driverParam'];
}
type CustomTypeValues = {
    /**
     * Required type for custom column, that will infer proper type model
     *
     * Examples:
     *
     * If you want your column to be `string` type after selecting/or on inserting - use `data: string`. Like `text`, `varchar`
     *
     * If you want your column to be `number` type after selecting/or on inserting - use `data: number`. Like `integer`
     */
    data: unknown;
    /**
     * Type helper, that represents what type database driver is accepting for specific database data type
     */
    driverData?: unknown;
    /**
     * What config type should be used for {@link CustomTypeParams} `dataType` generation
     */
    config?: unknown;
    /**
     * Whether the config argument should be required or not
     * @default false
     */
    configRequired?: boolean;
    /**
     * If your custom data type should be notNull by default you can use `notNull: true`
     *
     * @example
     * const customSerial = customType<{ data: number, notNull: true, default: true }>({
     * 	  dataType() {
     * 	    return 'serial';
     *    },
     * });
     */
    notNull?: boolean;
    /**
     * If your custom data type has default you can use `default: true`
     *
     * @example
     * const customSerial = customType<{ data: number, notNull: true, default: true }>({
     * 	  dataType() {
     * 	    return 'serial';
     *    },
     * });
     */
    default?: boolean;
};
interface CustomTypeParams<T extends CustomTypeValues> {
    /**
     * Database data type string representation, that is used for migrations
     * @example
     * ```
     * `jsonb`, `text`
     * ```
     *
     * If database data type needs additional params you can use them from `config` param
     * @example
     * ```
     * `varchar(256)`, `numeric(2,3)`
     * ```
     *
     * To make `config` be of specific type please use config generic in {@link CustomTypeValues}
     *
     * @example
     * Usage example
     * ```
     *   dataType() {
     *     return 'boolean';
     *   },
     * ```
     * Or
     * ```
     *   dataType(config) {
     * 	   return typeof config.length !== 'undefined' ? `varchar(${config.length})` : `varchar`;
     * 	 }
     * ```
     */
    dataType: (config: T['config'] | (Equal<T['configRequired'], true> extends true ? never : undefined)) => string;
    /**
     * Optional mapping function, between user input and driver
     * @example
     * For example, when using jsonb we need to map JS/TS object to string before writing to database
     * ```
     * toDriver(value: TData): string {
     * 	 return JSON.stringify(value);
     * }
     * ```
     */
    toDriver?: (value: T['data']) => T['driverData'] | SQL;
    /**
     * Optional mapping function, that is responsible for data mapping from database to JS/TS code
     * @example
     * For example, when using timestamp we need to map string Date representation to JS Date
     * ```
     * fromDriver(value: string): Date {
     * 	return new Date(value);
     * },
     * ```
     */
    fromDriver?: (value: T['driverData']) => T['data'];
}
/**
 * Custom pg database data type generator
 */
declare function customType<T extends CustomTypeValues = CustomTypeValues>(customTypeParams: CustomTypeParams<T>): Equal<T['configRequired'], true> extends true ? <TName extends string>(dbName: TName, fieldConfig: T['config']) => PgCustomColumnBuilder<ConvertCustomConfig<TName, T>> : <TName extends string>(dbName: TName, fieldConfig?: T['config']) => PgCustomColumnBuilder<ConvertCustomConfig<TName, T>>;

declare abstract class PgDateColumnBaseBuilder<T extends ColumnBuilderBaseConfig<ColumnDataType, string>, TRuntimeConfig extends object = object> extends PgColumnBuilder<T, TRuntimeConfig> {
    static readonly [entityKind]: string;
    defaultNow(): HasDefault<this>;
}

type PgDateBuilderInitial<TName extends string> = PgDateBuilder<{
    name: TName;
    dataType: 'date';
    columnType: 'PgDate';
    data: Date;
    driverParam: string;
    enumValues: undefined;
}>;
declare class PgDateBuilder<T extends ColumnBuilderBaseConfig<'date', 'PgDate'>> extends PgDateColumnBaseBuilder<T> {
    static readonly [entityKind]: string;
    constructor(name: T['name']);
}
declare class PgDate<T extends ColumnBaseConfig<'date', 'PgDate'>> extends PgColumn<T> {
    static readonly [entityKind]: string;
    getSQLType(): string;
    mapFromDriverValue(value: string): Date;
    mapToDriverValue(value: Date): string;
}
type PgDateStringBuilderInitial<TName extends string> = PgDateStringBuilder<{
    name: TName;
    dataType: 'string';
    columnType: 'PgDateString';
    data: string;
    driverParam: string;
    enumValues: undefined;
}>;
declare class PgDateStringBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgDateString'>> extends PgDateColumnBaseBuilder<T> {
    static readonly [entityKind]: string;
    constructor(name: T['name']);
}
declare class PgDateString<T extends ColumnBaseConfig<'string', 'PgDateString'>> extends PgColumn<T> {
    static readonly [entityKind]: string;
    getSQLType(): string;
}
declare function date<TName extends string>(name: TName, config?: {
    mode: 'string';
}): PgDateStringBuilderInitial<TName>;
declare function date<TName extends string>(TName: TName, config?: {
    mode: 'date';
}): PgDateBuilderInitial<TName>;

type PgDoublePrecisionBuilderInitial<TName extends string> = PgDoublePrecisionBuilder<{
    name: TName;
    dataType: 'number';
    columnType: 'PgDoublePrecision';
    data: number;
    driverParam: string | number;
    enumValues: undefined;
}>;
declare class PgDoublePrecisionBuilder<T extends ColumnBuilderBaseConfig<'number', 'PgDoublePrecision'>> extends PgColumnBuilder<T> {
    static readonly [entityKind]: string;
    constructor(name: T['name']);
}
declare class PgDoublePrecision<T extends ColumnBaseConfig<'number', 'PgDoublePrecision'>> extends PgColumn<T> {
    static readonly [entityKind]: string;
    getSQLType(): string;
    mapFromDriverValue(value: string | number): number;
}
declare function doublePrecision<TName extends string>(name: TName): PgDoublePrecisionBuilderInitial<TName>;

type PgEnumColumnBuilderInitial<TName extends string, TValues extends [string, ...string[]]> = PgEnumColumnBuilder<{
    name: TName;
    dataType: 'string';
    columnType: 'PgEnumColumn';
    data: TValues[number];
    enumValues: TValues;
    driverParam: string;
}>;
interface PgEnum<TValues extends [string, ...string[]]> {
    <TName extends string>(name: TName): PgEnumColumnBuilderInitial<TName, TValues>;
    readonly enumName: string;
    readonly enumValues: TValues;
}
declare function isPgEnum(obj: unknown): obj is PgEnum<[string, ...string[]]>;
declare class PgEnumColumnBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgEnumColumn'> & {
    enumValues: [string, ...string[]];
}> extends PgColumnBuilder<T, {
    enum: PgEnum<T['enumValues']>;
}> {
    static readonly [entityKind]: string;
    constructor(name: string, enumInstance: PgEnum<T['enumValues']>);
}
declare class PgEnumColumn<T extends ColumnBaseConfig<'string', 'PgEnumColumn'> & {
    enumValues: [string, ...string[]];
}> extends PgColumn<T, {
    enum: PgEnum<T['enumValues']>;
}> {
    static readonly [entityKind]: string;
    readonly enum: PgEnum<T["enumValues"]>;
    readonly enumValues: T["enumValues"];
    constructor(table: AnyPgTable<{
        name: T['tableName'];
    }>, config: PgEnumColumnBuilder<T>['config']);
    getSQLType(): string;
}
declare function pgEnum<U extends string, T extends Readonly<[U, ...U[]]>>(enumName: string, values: T | Writable<T>): PgEnum<Writable<T>>;

type PgInetBuilderInitial<TName extends string> = PgInetBuilder<{
    name: TName;
    dataType: 'string';
    columnType: 'PgInet';
    data: string;
    driverParam: string;
    enumValues: undefined;
}>;
declare class PgInetBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgInet'>> extends PgColumnBuilder<T> {
    static readonly [entityKind]: string;
    constructor(name: T['name']);
}
declare class PgInet<T extends ColumnBaseConfig<'string', 'PgInet'>> extends PgColumn<T> {
    static readonly [entityKind]: string;
    getSQLType(): string;
}
declare function inet<TName extends string>(name: TName): PgInetBuilderInitial<TName>;

type PgIntegerBuilderInitial<TName extends string> = PgIntegerBuilder<{
    name: TName;
    dataType: 'number';
    columnType: 'PgInteger';
    data: number;
    driverParam: number | string;
    enumValues: undefined;
}>;
declare class PgIntegerBuilder<T extends ColumnBuilderBaseConfig<'number', 'PgInteger'>> extends PgColumnBuilder<T> {
    static readonly [entityKind]: string;
    constructor(name: T['name']);
}
declare class PgInteger<T extends ColumnBaseConfig<'number', 'PgInteger'>> extends PgColumn<T> {
    static readonly [entityKind]: string;
    getSQLType(): string;
    mapFromDriverValue(value: number | string): number;
}
declare function integer<TName extends string>(name: TName): PgIntegerBuilderInitial<TName>;

type PgTimestampBuilderInitial<TName extends string> = PgTimestampBuilder<{
    name: TName;
    dataType: 'date';
    columnType: 'PgTimestamp';
    data: Date;
    driverParam: string;
    enumValues: undefined;
}>;
declare class PgTimestampBuilder<T extends ColumnBuilderBaseConfig<'date', 'PgTimestamp'>> extends PgDateColumnBaseBuilder<T, {
    withTimezone: boolean;
    precision: number | undefined;
}> {
    static readonly [entityKind]: string;
    constructor(name: string, withTimezone: boolean, precision: number | undefined);
}
declare class PgTimestamp<T extends ColumnBaseConfig<'date', 'PgTimestamp'>> extends PgColumn<T> {
    static readonly [entityKind]: string;
    readonly withTimezone: boolean;
    readonly precision: number | undefined;
    constructor(table: AnyPgTable<{
        name: T['tableName'];
    }>, config: PgTimestampBuilder<T>['config']);
    getSQLType(): string;
    mapFromDriverValue: (value: string) => Date;
    mapToDriverValue: (value: Date) => string;
}
type PgTimestampStringBuilderInitial<TName extends string> = PgTimestampStringBuilder<{
    name: TName;
    dataType: 'string';
    columnType: 'PgTimestampString';
    data: string;
    driverParam: string;
    enumValues: undefined;
}>;
declare class PgTimestampStringBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgTimestampString'>> extends PgDateColumnBaseBuilder<T, {
    withTimezone: boolean;
    precision: number | undefined;
}> {
    static readonly [entityKind]: string;
    constructor(name: string, withTimezone: boolean, precision: number | undefined);
}
declare class PgTimestampString<T extends ColumnBaseConfig<'string', 'PgTimestampString'>> extends PgColumn<T> {
    static readonly [entityKind]: string;
    readonly withTimezone: boolean;
    readonly precision: number | undefined;
    constructor(table: AnyPgTable<{
        name: T['tableName'];
    }>, config: PgTimestampStringBuilder<T>['config']);
    getSQLType(): string;
}
type Precision = 0 | 1 | 2 | 3 | 4 | 5 | 6;
interface PgTimestampConfig<TMode extends 'date' | 'string' = 'date' | 'string'> {
    mode?: TMode;
    precision?: Precision;
    withTimezone?: boolean;
}
declare function timestamp<TName extends string, TMode extends PgTimestampConfig['mode'] & {}>(name: TName, config?: PgTimestampConfig<TMode>): Equal<TMode, 'string'> extends true ? PgTimestampStringBuilderInitial<TName> : PgTimestampBuilderInitial<TName>;

type PgIntervalBuilderInitial<TName extends string> = PgIntervalBuilder<{
    name: TName;
    dataType: 'string';
    columnType: 'PgInterval';
    data: string;
    driverParam: string;
    enumValues: undefined;
}>;
declare class PgIntervalBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgInterval'>> extends PgColumnBuilder<T, {
    intervalConfig: IntervalConfig;
}> {
    static readonly [entityKind]: string;
    constructor(name: T['name'], intervalConfig: IntervalConfig);
}
declare class PgInterval<T extends ColumnBaseConfig<'string', 'PgInterval'>> extends PgColumn<T, {
    intervalConfig: IntervalConfig;
}> {
    static readonly [entityKind]: string;
    readonly fields: IntervalConfig['fields'];
    readonly precision: IntervalConfig['precision'];
    getSQLType(): string;
}
interface IntervalConfig {
    fields?: 'year' | 'month' | 'day' | 'hour' | 'minute' | 'second' | 'year to month' | 'day to hour' | 'day to minute' | 'day to second' | 'hour to minute' | 'hour to second' | 'minute to second';
    precision?: Precision;
}
declare function interval<TName extends string>(name: TName, config?: IntervalConfig): PgIntervalBuilderInitial<TName>;

type PgJsonBuilderInitial<TName extends string> = PgJsonBuilder<{
    name: TName;
    dataType: 'json';
    columnType: 'PgJson';
    data: unknown;
    driverParam: unknown;
    enumValues: undefined;
}>;
declare class PgJsonBuilder<T extends ColumnBuilderBaseConfig<'json', 'PgJson'>> extends PgColumnBuilder<T> {
    static readonly [entityKind]: string;
    constructor(name: T['name']);
}
declare class PgJson<T extends ColumnBaseConfig<'json', 'PgJson'>> extends PgColumn<T> {
    static readonly [entityKind]: string;
    constructor(table: AnyPgTable<{
        name: T['tableName'];
    }>, config: PgJsonBuilder<T>['config']);
    getSQLType(): string;
    mapToDriverValue(value: T['data']): string;
    mapFromDriverValue(value: T['data'] | string): T['data'];
}
declare function json<TName extends string>(name: TName): PgJsonBuilderInitial<TName>;

type PgJsonbBuilderInitial<TName extends string> = PgJsonbBuilder<{
    name: TName;
    dataType: 'json';
    columnType: 'PgJsonb';
    data: unknown;
    driverParam: unknown;
    enumValues: undefined;
}>;
declare class PgJsonbBuilder<T extends ColumnBuilderBaseConfig<'json', 'PgJsonb'>> extends PgColumnBuilder<T> {
    static readonly [entityKind]: string;
    constructor(name: T['name']);
}
declare class PgJsonb<T extends ColumnBaseConfig<'json', 'PgJsonb'>> extends PgColumn<T> {
    static readonly [entityKind]: string;
    constructor(table: AnyPgTable<{
        name: T['tableName'];
    }>, config: PgJsonbBuilder<T>['config']);
    getSQLType(): string;
    mapToDriverValue(value: T['data']): string;
    mapFromDriverValue(value: T['data'] | string): T['data'];
}
declare function jsonb<TName extends string>(name: TName): PgJsonbBuilderInitial<TName>;

type PgMacaddrBuilderInitial<TName extends string> = PgMacaddrBuilder<{
    name: TName;
    dataType: 'string';
    columnType: 'PgMacaddr';
    data: string;
    driverParam: string;
    enumValues: undefined;
}>;
declare class PgMacaddrBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgMacaddr'>> extends PgColumnBuilder<T> {
    static readonly [entityKind]: string;
    constructor(name: T['name']);
}
declare class PgMacaddr<T extends ColumnBaseConfig<'string', 'PgMacaddr'>> extends PgColumn<T> {
    static readonly [entityKind]: string;
    getSQLType(): string;
}
declare function macaddr<TName extends string>(name: TName): PgMacaddrBuilderInitial<TName>;

type PgMacaddr8BuilderInitial<TName extends string> = PgMacaddr8Builder<{
    name: TName;
    dataType: 'string';
    columnType: 'PgMacaddr8';
    data: string;
    driverParam: string;
    enumValues: undefined;
}>;
declare class PgMacaddr8Builder<T extends ColumnBuilderBaseConfig<'string', 'PgMacaddr8'>> extends PgColumnBuilder<T> {
    static readonly [entityKind]: string;
    constructor(name: T['name']);
}
declare class PgMacaddr8<T extends ColumnBaseConfig<'string', 'PgMacaddr8'>> extends PgColumn<T> {
    static readonly [entityKind]: string;
    getSQLType(): string;
}
declare function macaddr8<TName extends string>(name: TName): PgMacaddr8BuilderInitial<TName>;

type PgNumericBuilderInitial<TName extends string> = PgNumericBuilder<{
    name: TName;
    dataType: 'string';
    columnType: 'PgNumeric';
    data: string;
    driverParam: string;
    enumValues: undefined;
}>;
declare class PgNumericBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgNumeric'>> extends PgColumnBuilder<T, {
    precision: number | undefined;
    scale: number | undefined;
}> {
    static readonly [entityKind]: string;
    constructor(name: string, precision?: number, scale?: number);
}
declare class PgNumeric<T extends ColumnBaseConfig<'string', 'PgNumeric'>> extends PgColumn<T> {
    static readonly [entityKind]: string;
    readonly precision: number | undefined;
    readonly scale: number | undefined;
    constructor(table: AnyPgTable<{
        name: T['tableName'];
    }>, config: PgNumericBuilder<T>['config']);
    getSQLType(): string;
}
declare function numeric<TName extends string>(name: TName, config?: {
    precision: number;
    scale?: number;
} | {
    precision?: number;
    scale: number;
} | {
    precision: number;
    scale: number;
}): PgNumericBuilderInitial<TName>;
declare const decimal: typeof numeric;

type PgRealBuilderInitial<TName extends string> = PgRealBuilder<{
    name: TName;
    dataType: 'number';
    columnType: 'PgReal';
    data: number;
    driverParam: string | number;
    enumValues: undefined;
}>;
declare class PgRealBuilder<T extends ColumnBuilderBaseConfig<'number', 'PgReal'>> extends PgColumnBuilder<T, {
    length: number | undefined;
}> {
    static readonly [entityKind]: string;
    constructor(name: string, length?: number);
}
declare class PgReal<T extends ColumnBaseConfig<'number', 'PgReal'>> extends PgColumn<T> {
    static readonly [entityKind]: string;
    constructor(table: AnyPgTable<{
        name: T['tableName'];
    }>, config: PgRealBuilder<T>['config']);
    getSQLType(): string;
    mapFromDriverValue: (value: string | number) => number;
}
declare function real<TName extends string>(name: TName): PgRealBuilderInitial<TName>;

type PgSerialBuilderInitial<TName extends string> = NotNull<HasDefault<PgSerialBuilder<{
    name: TName;
    dataType: 'number';
    columnType: 'PgSerial';
    data: number;
    driverParam: number;
    enumValues: undefined;
}>>>;
declare class PgSerialBuilder<T extends ColumnBuilderBaseConfig<'number', 'PgSerial'>> extends PgColumnBuilder<T> {
    static readonly [entityKind]: string;
    constructor(name: string);
}
declare class PgSerial<T extends ColumnBaseConfig<'number', 'PgSerial'>> extends PgColumn<T> {
    static readonly [entityKind]: string;
    getSQLType(): string;
}
declare function serial<TName extends string>(name: TName): PgSerialBuilderInitial<TName>;

type PgSmallIntBuilderInitial<TName extends string> = PgSmallIntBuilder<{
    name: TName;
    dataType: 'number';
    columnType: 'PgSmallInt';
    data: number;
    driverParam: number | string;
    enumValues: undefined;
}>;
declare class PgSmallIntBuilder<T extends ColumnBuilderBaseConfig<'number', 'PgSmallInt'>> extends PgColumnBuilder<T> {
    static readonly [entityKind]: string;
    constructor(name: T['name']);
}
declare class PgSmallInt<T extends ColumnBaseConfig<'number', 'PgSmallInt'>> extends PgColumn<T> {
    static readonly [entityKind]: string;
    getSQLType(): string;
    mapFromDriverValue: (value: number | string) => number;
}
declare function smallint<TName extends string>(name: TName): PgSmallIntBuilderInitial<TName>;

type PgSmallSerialBuilderInitial<TName extends string> = PgSmallSerialBuilder<{
    name: TName;
    dataType: 'number';
    columnType: 'PgSmallSerial';
    data: number;
    driverParam: number;
    enumValues: undefined;
}>;
declare class PgSmallSerialBuilder<T extends ColumnBuilderBaseConfig<'number', 'PgSmallSerial'>> extends PgColumnBuilder<T> {
    static readonly [entityKind]: string;
    constructor(name: string);
}
declare class PgSmallSerial<T extends ColumnBaseConfig<'number', 'PgSmallSerial'>> extends PgColumn<T> {
    static readonly [entityKind]: string;
    getSQLType(): string;
}
declare function smallserial<TName extends string>(name: TName): PgSmallSerialBuilderInitial<TName>;

type PgTextBuilderInitial<TName extends string, TEnum extends [string, ...string[]]> = PgTextBuilder<{
    name: TName;
    dataType: 'string';
    columnType: 'PgText';
    data: TEnum[number];
    enumValues: TEnum;
    driverParam: string;
}>;
declare class PgTextBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgText'>> extends PgColumnBuilder<T, {
    enumValues: T['enumValues'];
}> {
    static readonly [entityKind]: string;
    constructor(name: T['name'], config: PgTextConfig<T['enumValues']>);
}
declare class PgText<T extends ColumnBaseConfig<'string', 'PgText'>> extends PgColumn<T, {
    enumValues: T['enumValues'];
}> {
    static readonly [entityKind]: string;
    readonly enumValues: T["enumValues"];
    getSQLType(): string;
}
interface PgTextConfig<TEnum extends readonly string[] | string[] | undefined> {
    enum?: TEnum;
}
declare function text<TName extends string, U extends string, T extends Readonly<[U, ...U[]]>>(name: TName, config?: PgTextConfig<T | Writable<T>>): PgTextBuilderInitial<TName, Writable<T>>;

type PgTimeBuilderInitial<TName extends string> = PgTimeBuilder<{
    name: TName;
    dataType: 'string';
    columnType: 'PgTime';
    data: string;
    driverParam: string;
    enumValues: undefined;
}>;
declare class PgTimeBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgTime'>> extends PgDateColumnBaseBuilder<T, {
    withTimezone: boolean;
    precision: number | undefined;
}> {
    readonly withTimezone: boolean;
    readonly precision: number | undefined;
    static readonly [entityKind]: string;
    constructor(name: T['name'], withTimezone: boolean, precision: number | undefined);
}
declare class PgTime<T extends ColumnBaseConfig<'string', 'PgTime'>> extends PgColumn<T> {
    static readonly [entityKind]: string;
    readonly withTimezone: boolean;
    readonly precision: number | undefined;
    constructor(table: AnyPgTable<{
        name: T['tableName'];
    }>, config: PgTimeBuilder<T>['config']);
    getSQLType(): string;
}
interface TimeConfig {
    precision?: Precision;
    withTimezone?: boolean;
}
declare function time<TName extends string>(name: TName, config?: TimeConfig): PgTimeBuilderInitial<TName>;

type PgUUIDBuilderInitial<TName extends string> = PgUUIDBuilder<{
    name: TName;
    dataType: 'string';
    columnType: 'PgUUID';
    data: string;
    driverParam: string;
    enumValues: undefined;
}>;
declare class PgUUIDBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgUUID'>> extends PgColumnBuilder<T> {
    static readonly [entityKind]: string;
    constructor(name: T['name']);
    /**
     * Adds `default gen_random_uuid()` to the column definition.
     */
    defaultRandom(): ReturnType<this['default']>;
}
declare class PgUUID<T extends ColumnBaseConfig<'string', 'PgUUID'>> extends PgColumn<T> {
    static readonly [entityKind]: string;
    getSQLType(): string;
}
declare function uuid<TName extends string>(name: TName): PgUUIDBuilderInitial<TName>;

type PgVarcharBuilderInitial<TName extends string, TEnum extends [string, ...string[]]> = PgVarcharBuilder<{
    name: TName;
    dataType: 'string';
    columnType: 'PgVarchar';
    data: TEnum[number];
    driverParam: string;
    enumValues: TEnum;
}>;
declare class PgVarcharBuilder<T extends ColumnBuilderBaseConfig<'string', 'PgVarchar'>> extends PgColumnBuilder<T, {
    length: number | undefined;
    enumValues: T['enumValues'];
}> {
    static readonly [entityKind]: string;
    constructor(name: string, config: PgVarcharConfig<T['enumValues']>);
}
declare class PgVarchar<T extends ColumnBaseConfig<'string', 'PgVarchar'>> extends PgColumn<T, {
    length: number | undefined;
    enumValues: T['enumValues'];
}> {
    static readonly [entityKind]: string;
    readonly length: number | undefined;
    readonly enumValues: T["enumValues"];
    getSQLType(): string;
}
interface PgVarcharConfig<TEnum extends readonly string[] | string[] | undefined> {
    length?: number;
    enum?: TEnum;
}
declare function varchar<TName extends string, U extends string, T extends Readonly<[U, ...U[]]>>(name: TName, config?: PgVarcharConfig<T | Writable<T>>): PgVarcharBuilderInitial<TName, Writable<T>>;

declare function alias<TTable extends AnyPgTable | PgViewBase, TAlias extends string>(table: TTable, alias: TAlias): BuildAliasTable<TTable, TAlias>;

declare class PgSchema<TName extends string = string> {
    readonly schemaName: TName;
    static readonly [entityKind]: string;
    constructor(schemaName: TName);
    table: PgTableFn<TName>;
    view: typeof pgView;
    materializedView: typeof pgMaterializedView;
}
declare function isPgSchema(obj: unknown): obj is PgSchema;
declare function pgSchema<T extends string>(name: T): PgSchema<T>;

declare function getTableConfig<TTable extends AnyPgTable>(table: TTable): {
    columns: PgColumn<ColumnBaseConfig<ColumnDataType, string>, {}, {}>[];
    indexes: Index[];
    foreignKeys: ForeignKey[];
    checks: Check[];
    primaryKeys: PrimaryKey[];
    uniqueConstraints: UniqueConstraint[];
    name: string;
    schema: string | undefined;
};
declare function getViewConfig<TName extends string = string, TExisting extends boolean = boolean>(view: PgView<TName, TExisting>): {
    with?: ViewWithConfig | undefined;
    name: TName;
    originalName: TName;
    schema: string | undefined;
    selectedFields: SelectedFields<AnyColumn, Table<TableConfig<Column<any, object, object>>>>;
    isExisting: TExisting;
    query: TExisting extends true ? undefined : SQL<unknown>;
    isAlias: boolean;
};
declare function getMaterializedViewConfig<TName extends string = string, TExisting extends boolean = boolean>(view: PgMaterializedView<TName, TExisting>): {
    with?: PgMaterializedViewWithConfig | undefined;
    using?: string | undefined;
    tablespace?: string | undefined;
    withNoData?: boolean | undefined;
    name: TName;
    originalName: TName;
    schema: string | undefined;
    selectedFields: SelectedFields<AnyColumn, Table<TableConfig<Column<any, object, object>>>>;
    isExisting: TExisting;
    query: TExisting extends true ? undefined : SQL<unknown>;
    isAlias: boolean;
};
declare function parsePgNestedArray(arrayString: string, startFrom?: number): [any[], number];
declare function parsePgArray(arrayString: string): any[];
declare function makePgArray(array: any[]): string;
type ColumnsWithTable<TTableName extends string, TForeignTableName extends string, TColumns extends AnyPgColumn<{
    tableName: TTableName;
}>[]> = {
    [Key in keyof TColumns]: AnyPgColumn<{
        tableName: TForeignTableName;
    }>;
};

export { AnyPgColumn, AnyPgTable, BuildAliasTable, Check, ColumnsWithTable, ConvertCustomConfig, CustomTypeParams, CustomTypeValues, ForeignKey, Index, IntervalConfig, PgBigInt53, PgBigInt53Builder, PgBigInt53BuilderInitial, PgBigInt64, PgBigInt64Builder, PgBigInt64BuilderInitial, PgBigSerial53, PgBigSerial53Builder, PgBigSerial53BuilderInitial, PgBigSerial64, PgBigSerial64Builder, PgBigSerial64BuilderInitial, PgBoolean, PgBooleanBuilder, PgBooleanBuilderInitial, PgChar, PgCharBuilder, PgCharBuilderInitial, PgCharConfig, PgCidr, PgCidrBuilder, PgCidrBuilderInitial, PgColumn, PgColumnBuilder, PgCustomColumn, PgCustomColumnBuilder, PgCustomColumnInnerConfig, PgDate, PgDateBuilder, PgDateBuilderInitial, PgDateString, PgDateStringBuilder, PgDateStringBuilderInitial, PgDoublePrecision, PgDoublePrecisionBuilder, PgDoublePrecisionBuilderInitial, PgEnum, PgEnumColumn, PgEnumColumnBuilder, PgEnumColumnBuilderInitial, PgInet, PgInetBuilder, PgInetBuilderInitial, PgInteger, PgIntegerBuilder, PgInterval, PgIntervalBuilder, PgIntervalBuilderInitial, PgJson, PgJsonBuilder, PgJsonBuilderInitial, PgJsonb, PgJsonbBuilder, PgJsonbBuilderInitial, PgMacaddr, PgMacaddr8, PgMacaddr8Builder, PgMacaddr8BuilderInitial, PgMacaddrBuilder, PgMacaddrBuilderInitial, PgMaterializedView, PgMaterializedViewWithConfig, PgNumeric, PgNumericBuilder, PgNumericBuilderInitial, PgReal, PgRealBuilder, PgRealBuilderInitial, PgSchema, PgSerial, PgSerialBuilder, PgSerialBuilderInitial, PgSmallInt, PgSmallIntBuilder, PgSmallIntBuilderInitial, PgSmallSerial, PgSmallSerialBuilder, PgSmallSerialBuilderInitial, PgTableFn, PgText, PgTextBuilder, PgTextConfig, PgTime, PgTimeBuilder, PgTimeBuilderInitial, PgTimestamp, PgTimestampBuilder, PgTimestampBuilderInitial, PgTimestampConfig, PgTimestampString, PgTimestampStringBuilder, PgTimestampStringBuilderInitial, PgUUID, PgUUIDBuilder, PgUUIDBuilderInitial, PgVarchar, PgVarcharBuilder, PgVarcharBuilderInitial, PgVarcharConfig, PgView, PgViewBase, Precision, PrimaryKey, TimeConfig, UniqueConstraint, ViewWithConfig, alias, bigint, bigserial, boolean, char, cidr, customType, date, decimal, doublePrecision, getMaterializedViewConfig, getTableConfig, getViewConfig, inet, integer, interval, isPgEnum, isPgSchema, json, jsonb, macaddr, macaddr8, makePgArray, numeric, parsePgArray, parsePgNestedArray, pgEnum, pgMaterializedView, pgSchema, pgView, real, serial, smallint, smallserial, text, time, timestamp, uuid, varchar };
