import { T as Table, e as entityKind, C as ColumnBuilder, p as Column, Q as QueryPromise, i as is, S as SQL, b as Param, d as mapUpdateSet, s as sql, j as SelectionProxyHandler, q as getTableColumns, r as View, o as orderSelectedFields, u as getTableName, v as Subquery, w as SubqueryConfig, V as ViewBaseConfig, x as aliasedTableColumn, y as getOperators, z as mapColumnsInSQLToAlias, A as mapColumnsInAliasedSQLToAlias, B as getOrderByOperators, E as normalizeRelation, F as and, G as eq, O as One, D as DrizzleError, M as Many, H as aliasedTable, I as applyMixins, J as TypedQueryBuilder, K as getTableLikeName, W as WithSubquery, g as mapRelationalRow, l as TransactionRollbackError } from './alias-7164ff43.mjs';

/** @internal */
const InlineForeignKeys = Symbol.for('drizzle:MySqlInlineForeignKeys');
class MySqlTable extends Table {
    static [entityKind] = 'MySqlTable';
    /** @internal */
    static Symbol = Object.assign({}, Table.Symbol, {
        InlineForeignKeys: InlineForeignKeys,
    });
    /** @internal */
    [Table.Symbol.Columns];
    /** @internal */
    [InlineForeignKeys] = [];
    /** @internal */
    [Table.Symbol.ExtraConfigBuilder] = undefined;
}
function mysqlTableWithSchema(name, columns, extraConfig, schema, baseName = name) {
    const rawTable = new MySqlTable(name, schema, baseName);
    const builtColumns = Object.fromEntries(Object.entries(columns).map(([name, colBuilder]) => {
        const column = colBuilder.build(rawTable);
        rawTable[InlineForeignKeys].push(...colBuilder.buildForeignKeys(column, rawTable));
        return [name, column];
    }));
    const table = Object.assign(rawTable, builtColumns);
    table[Table.Symbol.Columns] = builtColumns;
    if (extraConfig) {
        table[MySqlTable.Symbol.ExtraConfigBuilder] = extraConfig;
    }
    return table;
}
const mysqlTable = (name, columns, extraConfig) => {
    return mysqlTableWithSchema(name, columns, extraConfig, undefined, name);
};
function mysqlTableCreator(customizeTableName) {
    return (name, columns, extraConfig) => {
        return mysqlTableWithSchema(customizeTableName(name), columns, extraConfig, undefined, name);
    };
}

class ForeignKeyBuilder {
    static [entityKind] = 'MySqlForeignKeyBuilder';
    /** @internal */
    reference;
    /** @internal */
    _onUpdate;
    /** @internal */
    _onDelete;
    constructor(config, actions) {
        this.reference = () => {
            const { columns, foreignColumns } = config();
            return { columns, foreignTable: foreignColumns[0].table, foreignColumns };
        };
        if (actions) {
            this._onUpdate = actions.onUpdate;
            this._onDelete = actions.onDelete;
        }
    }
    onUpdate(action) {
        this._onUpdate = action;
        return this;
    }
    onDelete(action) {
        this._onDelete = action;
        return this;
    }
    /** @internal */
    build(table) {
        return new ForeignKey(table, this);
    }
}
class ForeignKey {
    table;
    static [entityKind] = 'MySqlForeignKey';
    reference;
    onUpdate;
    onDelete;
    constructor(table, builder) {
        this.table = table;
        this.reference = builder.reference;
        this.onUpdate = builder._onUpdate;
        this.onDelete = builder._onDelete;
    }
    getName() {
        const { columns, foreignColumns } = this.reference();
        const columnNames = columns.map((column) => column.name);
        const foreignColumnNames = foreignColumns.map((column) => column.name);
        const chunks = [
            this.table[MySqlTable.Symbol.Name],
            ...columnNames,
            foreignColumns[0].table[MySqlTable.Symbol.Name],
            ...foreignColumnNames,
        ];
        return `${chunks.join('_')}_fk`;
    }
}
function foreignKey(config) {
    function mappedConfig() {
        const { columns, foreignColumns } = config;
        return {
            columns,
            foreignColumns,
        };
    }
    return new ForeignKeyBuilder(mappedConfig);
}

function unique(name) {
    return new UniqueOnConstraintBuilder(name);
}
function uniqueKeyName(table, columns) {
    return `${table[MySqlTable.Symbol.Name]}_${columns.join('_')}_unique`;
}
class UniqueConstraintBuilder {
    name;
    static [entityKind] = 'MySqlUniqueConstraintBuilder';
    /** @internal */
    columns;
    constructor(columns, name) {
        this.name = name;
        this.columns = columns;
    }
    /** @internal */
    build(table) {
        return new UniqueConstraint(table, this.columns, this.name);
    }
}
class UniqueOnConstraintBuilder {
    static [entityKind] = 'MySqlUniqueOnConstraintBuilder';
    /** @internal */
    name;
    constructor(name) {
        this.name = name;
    }
    on(...columns) {
        return new UniqueConstraintBuilder(columns, this.name);
    }
}
class UniqueConstraint {
    table;
    static [entityKind] = 'MySqlUniqueConstraint';
    columns;
    name;
    nullsNotDistinct = false;
    constructor(table, columns, name) {
        this.table = table;
        this.columns = columns;
        this.name = name ?? uniqueKeyName(this.table, this.columns.map((column) => column.name));
    }
    getName() {
        return this.name;
    }
}

class MySqlColumnBuilder extends ColumnBuilder {
    static [entityKind] = 'MySqlColumnBuilder';
    foreignKeyConfigs = [];
    references(ref, actions = {}) {
        this.foreignKeyConfigs.push({ ref, actions });
        return this;
    }
    unique(name) {
        this.config.isUnique = true;
        this.config.uniqueName = name;
        return this;
    }
    /** @internal */
    buildForeignKeys(column, table) {
        return this.foreignKeyConfigs.map(({ ref, actions }) => {
            return ((ref, actions) => {
                const builder = new ForeignKeyBuilder(() => {
                    const foreignColumn = ref();
                    return { columns: [column], foreignColumns: [foreignColumn] };
                });
                if (actions.onUpdate) {
                    builder.onUpdate(actions.onUpdate);
                }
                if (actions.onDelete) {
                    builder.onDelete(actions.onDelete);
                }
                return builder.build(table);
            })(ref, actions);
        });
    }
}
// To understand how to use `MySqlColumn` and `AnyMySqlColumn`, see `Column` and `AnyColumn` documentation.
class MySqlColumn extends Column {
    table;
    static [entityKind] = 'MySqlColumn';
    constructor(table, config) {
        if (!config.uniqueName) {
            config.uniqueName = uniqueKeyName(table, [config.name]);
        }
        super(table, config);
        this.table = table;
    }
}
class MySqlColumnBuilderWithAutoIncrement extends MySqlColumnBuilder {
    static [entityKind] = 'MySqlColumnBuilderWithAutoIncrement';
    constructor(name, dataType, columnType) {
        super(name, dataType, columnType);
        this.config.autoIncrement = false;
    }
    autoincrement() {
        this.config.autoIncrement = true;
        this.config.hasDefault = true;
        return this;
    }
}
class MySqlColumnWithAutoIncrement extends MySqlColumn {
    static [entityKind] = 'MySqlColumnWithAutoIncrement';
    autoIncrement = this.config.autoIncrement;
}

class MySqlDelete extends QueryPromise {
    table;
    session;
    dialect;
    static [entityKind] = 'MySqlDelete';
    config;
    constructor(table, session, dialect) {
        super();
        this.table = table;
        this.session = session;
        this.dialect = dialect;
        this.config = { table };
    }
    where(where) {
        this.config.where = where;
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildDeleteQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    prepare() {
        return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning);
    }
    execute = (placeholderValues) => {
        return this.prepare().execute(placeholderValues);
    };
    createIterator = () => {
        const self = this;
        return async function* (placeholderValues) {
            yield* self.prepare().iterator(placeholderValues);
        };
    };
    iterator = this.createIterator();
}

class MySqlInsertBuilder {
    table;
    session;
    dialect;
    static [entityKind] = 'MySqlInsertBuilder';
    shouldIgnore = false;
    constructor(table, session, dialect) {
        this.table = table;
        this.session = session;
        this.dialect = dialect;
    }
    ignore() {
        this.shouldIgnore = true;
        return this;
    }
    values(values) {
        values = Array.isArray(values) ? values : [values];
        if (values.length === 0) {
            throw new Error('values() must be called with at least one value');
        }
        const mappedValues = values.map((entry) => {
            const result = {};
            const cols = this.table[Table.Symbol.Columns];
            for (const colKey of Object.keys(entry)) {
                const colValue = entry[colKey];
                result[colKey] = is(colValue, SQL) ? colValue : new Param(colValue, cols[colKey]);
            }
            return result;
        });
        return new MySqlInsert(this.table, mappedValues, this.shouldIgnore, this.session, this.dialect);
    }
}
class MySqlInsert extends QueryPromise {
    session;
    dialect;
    static [entityKind] = 'MySqlInsert';
    config;
    constructor(table, values, ignore, session, dialect) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.config = { table, values, ignore };
    }
    onDuplicateKeyUpdate(config) {
        const setSql = this.dialect.buildUpdateSet(this.config.table, mapUpdateSet(this.config.table, config.set));
        this.config.onConflict = sql `update ${setSql}`;
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildInsertQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    prepare() {
        return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), undefined);
    }
    execute = (placeholderValues) => {
        return this.prepare().execute(placeholderValues);
    };
    createIterator = () => {
        const self = this;
        return async function* (placeholderValues) {
            yield* self.prepare().iterator(placeholderValues);
        };
    };
    iterator = this.createIterator();
}

class ViewBuilderCore {
    name;
    schema;
    static [entityKind] = 'MySqlViewBuilder';
    constructor(name, schema) {
        this.name = name;
        this.schema = schema;
    }
    config = {};
    algorithm(algorithm) {
        this.config.algorithm = algorithm;
        return this;
    }
    definer(definer) {
        this.config.definer = definer;
        return this;
    }
    sqlSecurity(sqlSecurity) {
        this.config.sqlSecurity = sqlSecurity;
        return this;
    }
    withCheckOption(withCheckOption) {
        this.config.withCheckOption = withCheckOption ?? 'cascaded';
        return this;
    }
}
class ViewBuilder extends ViewBuilderCore {
    static [entityKind] = 'MySqlViewBuilder';
    as(qb) {
        if (typeof qb === 'function') {
            qb = qb(new QueryBuilder());
        }
        const selectionProxy = new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        });
        const aliasedSelection = new Proxy(qb.getSelectedFields(), selectionProxy);
        return new Proxy(new MySqlView({
            mysqlConfig: this.config,
            config: {
                name: this.name,
                schema: this.schema,
                selectedFields: aliasedSelection,
                query: qb.getSQL().inlineParams(),
            },
        }), selectionProxy);
    }
}
class ManualViewBuilder extends ViewBuilderCore {
    static [entityKind] = 'MySqlManualViewBuilder';
    columns;
    constructor(name, columns, schema) {
        super(name, schema);
        this.columns = getTableColumns(mysqlTable(name, columns));
    }
    existing() {
        return new Proxy(new MySqlView({
            mysqlConfig: undefined,
            config: {
                name: this.name,
                schema: this.schema,
                selectedFields: this.columns,
                query: undefined,
            },
        }), new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        }));
    }
    as(query) {
        return new Proxy(new MySqlView({
            mysqlConfig: this.config,
            config: {
                name: this.name,
                schema: this.schema,
                selectedFields: this.columns,
                query: query.inlineParams(),
            },
        }), new SelectionProxyHandler({
            alias: this.name,
            sqlBehavior: 'error',
            sqlAliasedBehavior: 'alias',
            replaceOriginalName: true,
        }));
    }
}
class MySqlViewBase extends View {
    static [entityKind] = 'MySqlViewBase';
}
const MySqlViewConfig = Symbol.for('drizzle:MySqlViewConfig');
class MySqlView extends MySqlViewBase {
    static [entityKind] = 'MySqlView';
    [MySqlViewConfig];
    constructor({ mysqlConfig, config }) {
        super(config);
        this[MySqlViewConfig] = mysqlConfig;
    }
}
/** @internal */
function mysqlViewWithSchema(name, selection, schema) {
    if (selection) {
        return new ManualViewBuilder(name, selection, schema);
    }
    return new ViewBuilder(name, schema);
}
function mysqlView(name, selection) {
    return mysqlViewWithSchema(name, selection, undefined);
}

// TODO find out how to use all/values. Seems like I need those functions
// Build project
// copy runtime tests to be sure it's working
// Add mysql to drizzle-kit
// Add Planetscale Driver and create example repo
class MySqlDialect {
    static [entityKind] = 'MySqlDialect';
    async migrate(migrations, session, config) {
        const migrationsTable = config.migrationsTable ?? '__drizzle_migrations';
        const migrationTableCreate = sql `
			create table if not exists ${sql.identifier(migrationsTable)} (
				id serial primary key,
				hash text not null,
				created_at bigint
			)
		`;
        await session.execute(migrationTableCreate);
        const dbMigrations = await session.all(sql `select id, hash, created_at from ${sql.identifier(migrationsTable)} order by created_at desc limit 1`);
        const lastDbMigration = dbMigrations[0];
        await session.transaction(async (tx) => {
            for (const migration of migrations) {
                if (!lastDbMigration
                    || Number(lastDbMigration.created_at) < migration.folderMillis) {
                    for (const stmt of migration.sql) {
                        await tx.execute(sql.raw(stmt));
                    }
                    await tx.execute(sql `insert into ${sql.identifier(migrationsTable)} (\`hash\`, \`created_at\`) values(${migration.hash}, ${migration.folderMillis})`);
                }
            }
        });
    }
    escapeName(name) {
        return `\`${name}\``;
    }
    escapeParam(_num) {
        return `?`;
    }
    escapeString(str) {
        return `'${str.replace(/'/g, "''")}'`;
    }
    buildDeleteQuery({ table, where, returning }) {
        const returningSql = returning
            ? sql ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const whereSql = where ? sql ` where ${where}` : undefined;
        return sql `delete from ${table}${whereSql}${returningSql}`;
    }
    buildUpdateSet(table, set) {
        const setEntries = Object.entries(set);
        const setSize = setEntries.length;
        return sql.join(setEntries
            .flatMap(([colName, value], i) => {
            const col = table[Table.Symbol.Columns][colName];
            const res = sql `${sql.identifier(col.name)} = ${value}`;
            if (i < setSize - 1) {
                return [res, sql.raw(', ')];
            }
            return [res];
        }));
    }
    buildUpdateQuery({ table, set, where, returning }) {
        const setSql = this.buildUpdateSet(table, set);
        const returningSql = returning
            ? sql ` returning ${this.buildSelection(returning, { isSingleTable: true })}`
            : undefined;
        const whereSql = where ? sql ` where ${where}` : undefined;
        return sql `update ${table} set ${setSql}${whereSql}${returningSql}`;
    }
    /**
     * Builds selection SQL with provided fields/expressions
     *
     * Examples:
     *
     * `select <selection> from`
     *
     * `insert ... returning <selection>`
     *
     * If `isSingleTable` is true, then columns won't be prefixed with table name
     */
    buildSelection(fields, { isSingleTable = false } = {}) {
        const columnsLen = fields.length;
        const chunks = fields
            .flatMap(({ field }, i) => {
            const chunk = [];
            if (is(field, SQL.Aliased) && field.isSelectionField) {
                chunk.push(sql.identifier(field.fieldAlias));
            }
            else if (is(field, SQL.Aliased) || is(field, SQL)) {
                const query = is(field, SQL.Aliased) ? field.sql : field;
                if (isSingleTable) {
                    chunk.push(new SQL(query.queryChunks.map((c) => {
                        if (is(c, MySqlColumn)) {
                            return sql.identifier(c.name);
                        }
                        return c;
                    })));
                }
                else {
                    chunk.push(query);
                }
                if (is(field, SQL.Aliased)) {
                    chunk.push(sql ` as ${sql.identifier(field.fieldAlias)}`);
                }
            }
            else if (is(field, Column)) {
                if (isSingleTable) {
                    chunk.push(sql.identifier(field.name));
                }
                else {
                    chunk.push(field);
                }
            }
            if (i < columnsLen - 1) {
                chunk.push(sql `, `);
            }
            return chunk;
        });
        return sql.join(chunks);
    }
    buildSelectQuery({ withList, fields, fieldsFlat, where, having, table, joins, orderBy, groupBy, limit, offset, lockingClause, distinct, }) {
        const fieldsList = fieldsFlat ?? orderSelectedFields(fields);
        for (const f of fieldsList) {
            if (is(f.field, Column)
                && getTableName(f.field.table)
                    !== (is(table, Subquery)
                        ? table[SubqueryConfig].alias
                        : is(table, MySqlViewBase)
                            ? table[ViewBaseConfig].name
                            : is(table, SQL)
                                ? undefined
                                : getTableName(table))
                && !((table) => joins?.some(({ alias }) => alias === (table[Table.Symbol.IsAlias] ? getTableName(table) : table[Table.Symbol.BaseName])))(f.field.table)) {
                const tableName = getTableName(f.field.table);
                throw new Error(`Your "${f.path.join('->')}" field references a column "${tableName}"."${f.field.name}", but the table "${tableName}" is not part of the query! Did you forget to join it?`);
            }
        }
        const isSingleTable = !joins || joins.length === 0;
        let withSql;
        if (withList?.length) {
            const withSqlChunks = [sql `with `];
            for (const [i, w] of withList.entries()) {
                withSqlChunks.push(sql `${sql.identifier(w[SubqueryConfig].alias)} as (${w[SubqueryConfig].sql})`);
                if (i < withList.length - 1) {
                    withSqlChunks.push(sql `, `);
                }
            }
            withSqlChunks.push(sql ` `);
            withSql = sql.join(withSqlChunks);
        }
        const distinctSql = distinct ? sql ` distinct` : undefined;
        const selection = this.buildSelection(fieldsList, { isSingleTable });
        const tableSql = (() => {
            if (is(table, Table) && table[Table.Symbol.OriginalName] !== table[Table.Symbol.Name]) {
                return sql `${sql.identifier(table[Table.Symbol.OriginalName])} ${sql.identifier(table[Table.Symbol.Name])}`;
            }
            return table;
        })();
        const joinsArray = [];
        if (joins) {
            for (const [index, joinMeta] of joins.entries()) {
                if (index === 0) {
                    joinsArray.push(sql ` `);
                }
                const table = joinMeta.table;
                const lateralSql = joinMeta.lateral ? sql ` lateral` : undefined;
                if (is(table, MySqlTable)) {
                    const tableName = table[MySqlTable.Symbol.Name];
                    const tableSchema = table[MySqlTable.Symbol.Schema];
                    const origTableName = table[MySqlTable.Symbol.OriginalName];
                    const alias = tableName === origTableName ? undefined : joinMeta.alias;
                    joinsArray.push(sql `${sql.raw(joinMeta.joinType)} join${lateralSql} ${tableSchema ? sql `${sql.identifier(tableSchema)}.` : undefined}${sql.identifier(origTableName)}${alias && sql ` ${sql.identifier(alias)}`} on ${joinMeta.on}`);
                }
                else if (is(table, View)) {
                    const viewName = table[ViewBaseConfig].name;
                    const viewSchema = table[ViewBaseConfig].schema;
                    const origViewName = table[ViewBaseConfig].originalName;
                    const alias = viewName === origViewName ? undefined : joinMeta.alias;
                    joinsArray.push(sql `${sql.raw(joinMeta.joinType)} join${lateralSql} ${viewSchema ? sql `${sql.identifier(viewSchema)}.` : undefined}${sql.identifier(origViewName)}${alias && sql ` ${sql.identifier(alias)}`} on ${joinMeta.on}`);
                }
                else {
                    joinsArray.push(sql `${sql.raw(joinMeta.joinType)} join${lateralSql} ${table} on ${joinMeta.on}`);
                }
                if (index < joins.length - 1) {
                    joinsArray.push(sql ` `);
                }
            }
        }
        const joinsSql = sql.join(joinsArray);
        const whereSql = where ? sql ` where ${where}` : undefined;
        const havingSql = having ? sql ` having ${having}` : undefined;
        let orderBySql;
        if (orderBy && orderBy.length > 0) {
            orderBySql = sql ` order by ${sql.join(orderBy, sql `, `)}`;
        }
        let groupBySql;
        if (groupBy && groupBy.length > 0) {
            groupBySql = sql ` group by ${sql.join(groupBy, sql `, `)}`;
        }
        const limitSql = limit ? sql ` limit ${limit}` : undefined;
        const offsetSql = offset ? sql ` offset ${offset}` : undefined;
        let lockingClausesSql;
        if (lockingClause) {
            const { config, strength } = lockingClause;
            lockingClausesSql = sql ` for ${sql.raw(strength)}`;
            if (config.noWait) {
                lockingClausesSql.append(sql ` no wait`);
            }
            else if (config.skipLocked) {
                lockingClausesSql.append(sql ` skip locked`);
            }
        }
        return sql `${withSql}select${distinctSql} ${selection} from ${tableSql}${joinsSql}${whereSql}${groupBySql}${havingSql}${orderBySql}${limitSql}${offsetSql}${lockingClausesSql}`;
    }
    buildInsertQuery({ table, values, ignore, onConflict }) {
        const isSingleValue = values.length === 1;
        const valuesSqlList = [];
        const columns = table[Table.Symbol.Columns];
        const colEntries = isSingleValue
            ? Object.keys(values[0]).map((fieldName) => [fieldName, columns[fieldName]])
            : Object.entries(columns);
        const insertOrder = colEntries.map(([, column]) => sql.identifier(column.name));
        for (const [valueIndex, value] of values.entries()) {
            const valueList = [];
            for (const [fieldName] of colEntries) {
                const colValue = value[fieldName];
                if (colValue === undefined || (is(colValue, Param) && colValue.value === undefined)) {
                    valueList.push(sql `default`);
                }
                else {
                    valueList.push(colValue);
                }
            }
            valuesSqlList.push(valueList);
            if (valueIndex < values.length - 1) {
                valuesSqlList.push(sql `, `);
            }
        }
        const valuesSql = sql.join(valuesSqlList);
        const ignoreSql = ignore ? sql ` ignore` : undefined;
        const onConflictSql = onConflict ? sql ` on duplicate key ${onConflict}` : undefined;
        return sql `insert${ignoreSql} into ${table} ${insertOrder} values ${valuesSql}${onConflictSql}`;
    }
    sqlToQuery(sql) {
        return sql.toQuery({
            escapeName: this.escapeName,
            escapeParam: this.escapeParam,
            escapeString: this.escapeString,
        });
    }
    buildRelationalQuery({ fullSchema, schema, tableNamesMap, table, tableConfig, queryConfig: config, tableAlias, nestedQueryRelation, joinOn, }) {
        let selection = [];
        let limit, offset, orderBy, where;
        const joins = [];
        if (config === true) {
            const selectionEntries = Object.entries(tableConfig.columns);
            selection = selectionEntries.map(([key, value]) => ({
                dbKey: value.name,
                tsKey: key,
                field: aliasedTableColumn(value, tableAlias),
                relationTableTsKey: undefined,
                isJson: false,
                selection: [],
            }));
        }
        else {
            const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]));
            if (config.where) {
                const whereSql = typeof config.where === 'function'
                    ? config.where(aliasedColumns, getOperators())
                    : config.where;
                where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
            }
            const fieldsSelection = [];
            let selectedColumns = [];
            // Figure out which columns to select
            if (config.columns) {
                let isIncludeMode = false;
                for (const [field, value] of Object.entries(config.columns)) {
                    if (value === undefined) {
                        continue;
                    }
                    if (field in tableConfig.columns) {
                        if (!isIncludeMode && value === true) {
                            isIncludeMode = true;
                        }
                        selectedColumns.push(field);
                    }
                }
                if (selectedColumns.length > 0) {
                    selectedColumns = isIncludeMode
                        ? selectedColumns.filter((c) => config.columns?.[c] === true)
                        : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
                }
            }
            else {
                // Select all columns if selection is not specified
                selectedColumns = Object.keys(tableConfig.columns);
            }
            for (const field of selectedColumns) {
                const column = tableConfig.columns[field];
                fieldsSelection.push({ tsKey: field, value: column });
            }
            let selectedRelations = [];
            // Figure out which relations to select
            if (config.with) {
                selectedRelations = Object.entries(config.with)
                    .filter((entry) => !!entry[1])
                    .map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
            }
            let extras;
            // Figure out which extras to select
            if (config.extras) {
                extras = typeof config.extras === 'function'
                    ? config.extras(aliasedColumns, { sql })
                    : config.extras;
                for (const [tsKey, value] of Object.entries(extras)) {
                    fieldsSelection.push({
                        tsKey,
                        value: mapColumnsInAliasedSQLToAlias(value, tableAlias),
                    });
                }
            }
            // Transform `fieldsSelection` into `selection`
            // `fieldsSelection` shouldn't be used after this point
            for (const { tsKey, value } of fieldsSelection) {
                selection.push({
                    dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
                    tsKey,
                    field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
                    relationTableTsKey: undefined,
                    isJson: false,
                    selection: [],
                });
            }
            let orderByOrig = typeof config.orderBy === 'function'
                ? config.orderBy(aliasedColumns, getOrderByOperators())
                : config.orderBy ?? [];
            if (!Array.isArray(orderByOrig)) {
                orderByOrig = [orderByOrig];
            }
            orderBy = orderByOrig.map((orderByValue) => {
                if (is(orderByValue, Column)) {
                    return aliasedTableColumn(orderByValue, tableAlias);
                }
                return mapColumnsInSQLToAlias(orderByValue, tableAlias);
            });
            limit = config.limit;
            offset = config.offset;
            // Process all relations
            for (const { tsKey: selectedRelationTsKey, queryConfig: selectedRelationConfigValue, relation, } of selectedRelations) {
                const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
                const relationTableName = relation.referencedTable[Table.Symbol.Name];
                const relationTableTsName = tableNamesMap[relationTableName];
                const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
                const joinOn = and(...normalizedRelation.fields.map((field, i) => eq(aliasedTableColumn(normalizedRelation.references[i], relationTableAlias), aliasedTableColumn(field, tableAlias))));
                const builtRelation = this.buildRelationalQuery({
                    fullSchema,
                    schema,
                    tableNamesMap,
                    table: fullSchema[relationTableTsName],
                    tableConfig: schema[relationTableTsName],
                    queryConfig: is(relation, One)
                        ? (selectedRelationConfigValue === true
                            ? { limit: 1 }
                            : { ...selectedRelationConfigValue, limit: 1 })
                        : selectedRelationConfigValue,
                    tableAlias: relationTableAlias,
                    joinOn,
                    nestedQueryRelation: relation,
                });
                const field = sql `${sql.identifier(relationTableAlias)}.${sql.identifier('data')}`.as(selectedRelationTsKey);
                joins.push({
                    on: sql `true`,
                    table: new Subquery(builtRelation.sql, {}, relationTableAlias),
                    alias: relationTableAlias,
                    joinType: 'left',
                    lateral: true,
                });
                selection.push({
                    dbKey: selectedRelationTsKey,
                    tsKey: selectedRelationTsKey,
                    field,
                    relationTableTsKey: relationTableTsName,
                    isJson: true,
                    selection: builtRelation.selection,
                });
            }
        }
        if (selection.length === 0) {
            throw new DrizzleError(`No fields selected for table "${tableConfig.tsName}" ("${tableAlias}")`);
        }
        let result;
        where = and(joinOn, where);
        if (nestedQueryRelation) {
            let field = sql `json_array(${sql.join(selection.map(({ field, tsKey, isJson }) => isJson
                ? sql `${sql.identifier(`${tableAlias}_${tsKey}`)}.${sql.identifier('data')}`
                : is(field, SQL.Aliased)
                    ? field.sql
                    : field), sql `, `)})`;
            if (is(nestedQueryRelation, Many)) {
                field = sql `coalesce(json_arrayagg(${field}), json_array())`;
            }
            const nestedSelection = [{
                    dbKey: 'data',
                    tsKey: 'data',
                    field: field.as('data'),
                    isJson: true,
                    relationTableTsKey: tableConfig.tsName,
                    selection,
                }];
            const needsSubquery = limit !== undefined || offset !== undefined || (orderBy?.length ?? 0) > 0;
            if (needsSubquery) {
                result = this.buildSelectQuery({
                    table: aliasedTable(table, tableAlias),
                    fields: {},
                    fieldsFlat: [
                        {
                            path: [],
                            field: sql.raw('*'),
                        },
                        ...(((orderBy?.length ?? 0) > 0)
                            ? [{
                                    path: [],
                                    field: sql `row_number() over (order by ${sql.join(orderBy, sql `, `)})`,
                                }]
                            : []),
                    ],
                    where,
                    limit,
                    offset,
                });
                where = undefined;
                limit = undefined;
                offset = undefined;
                orderBy = undefined;
            }
            else {
                result = aliasedTable(table, tableAlias);
            }
            result = this.buildSelectQuery({
                table: is(result, MySqlTable) ? result : new Subquery(result, {}, tableAlias),
                fields: {},
                fieldsFlat: nestedSelection.map(({ field }) => ({
                    path: [],
                    field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
                })),
                joins,
                where,
                limit,
                offset,
                orderBy,
            });
        }
        else {
            result = this.buildSelectQuery({
                table: aliasedTable(table, tableAlias),
                fields: {},
                fieldsFlat: selection.map(({ field }) => ({
                    path: [],
                    field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
                })),
                joins,
                where,
                limit,
                offset,
                orderBy,
            });
        }
        return {
            tableTsKey: tableConfig.tsName,
            sql: result,
            selection,
        };
    }
    buildRelationalQueryWithoutLateralSubqueries({ fullSchema, schema, tableNamesMap, table, tableConfig, queryConfig: config, tableAlias, nestedQueryRelation, joinOn, }) {
        let selection = [];
        let limit, offset, orderBy = [], where;
        if (config === true) {
            const selectionEntries = Object.entries(tableConfig.columns);
            selection = selectionEntries.map(([key, value]) => ({
                dbKey: value.name,
                tsKey: key,
                field: aliasedTableColumn(value, tableAlias),
                relationTableTsKey: undefined,
                isJson: false,
                selection: [],
            }));
        }
        else {
            const aliasedColumns = Object.fromEntries(Object.entries(tableConfig.columns).map(([key, value]) => [key, aliasedTableColumn(value, tableAlias)]));
            if (config.where) {
                const whereSql = typeof config.where === 'function'
                    ? config.where(aliasedColumns, getOperators())
                    : config.where;
                where = whereSql && mapColumnsInSQLToAlias(whereSql, tableAlias);
            }
            const fieldsSelection = [];
            let selectedColumns = [];
            // Figure out which columns to select
            if (config.columns) {
                let isIncludeMode = false;
                for (const [field, value] of Object.entries(config.columns)) {
                    if (value === undefined) {
                        continue;
                    }
                    if (field in tableConfig.columns) {
                        if (!isIncludeMode && value === true) {
                            isIncludeMode = true;
                        }
                        selectedColumns.push(field);
                    }
                }
                if (selectedColumns.length > 0) {
                    selectedColumns = isIncludeMode
                        ? selectedColumns.filter((c) => config.columns?.[c] === true)
                        : Object.keys(tableConfig.columns).filter((key) => !selectedColumns.includes(key));
                }
            }
            else {
                // Select all columns if selection is not specified
                selectedColumns = Object.keys(tableConfig.columns);
            }
            for (const field of selectedColumns) {
                const column = tableConfig.columns[field];
                fieldsSelection.push({ tsKey: field, value: column });
            }
            let selectedRelations = [];
            // Figure out which relations to select
            if (config.with) {
                selectedRelations = Object.entries(config.with)
                    .filter((entry) => !!entry[1])
                    .map(([tsKey, queryConfig]) => ({ tsKey, queryConfig, relation: tableConfig.relations[tsKey] }));
            }
            let extras;
            // Figure out which extras to select
            if (config.extras) {
                extras = typeof config.extras === 'function'
                    ? config.extras(aliasedColumns, { sql })
                    : config.extras;
                for (const [tsKey, value] of Object.entries(extras)) {
                    fieldsSelection.push({
                        tsKey,
                        value: mapColumnsInAliasedSQLToAlias(value, tableAlias),
                    });
                }
            }
            // Transform `fieldsSelection` into `selection`
            // `fieldsSelection` shouldn't be used after this point
            for (const { tsKey, value } of fieldsSelection) {
                selection.push({
                    dbKey: is(value, SQL.Aliased) ? value.fieldAlias : tableConfig.columns[tsKey].name,
                    tsKey,
                    field: is(value, Column) ? aliasedTableColumn(value, tableAlias) : value,
                    relationTableTsKey: undefined,
                    isJson: false,
                    selection: [],
                });
            }
            let orderByOrig = typeof config.orderBy === 'function'
                ? config.orderBy(aliasedColumns, getOrderByOperators())
                : config.orderBy ?? [];
            if (!Array.isArray(orderByOrig)) {
                orderByOrig = [orderByOrig];
            }
            orderBy = orderByOrig.map((orderByValue) => {
                if (is(orderByValue, Column)) {
                    return aliasedTableColumn(orderByValue, tableAlias);
                }
                return mapColumnsInSQLToAlias(orderByValue, tableAlias);
            });
            limit = config.limit;
            offset = config.offset;
            // Process all relations
            for (const { tsKey: selectedRelationTsKey, queryConfig: selectedRelationConfigValue, relation, } of selectedRelations) {
                const normalizedRelation = normalizeRelation(schema, tableNamesMap, relation);
                const relationTableName = relation.referencedTable[Table.Symbol.Name];
                const relationTableTsName = tableNamesMap[relationTableName];
                const relationTableAlias = `${tableAlias}_${selectedRelationTsKey}`;
                const joinOn = and(...normalizedRelation.fields.map((field, i) => eq(aliasedTableColumn(normalizedRelation.references[i], relationTableAlias), aliasedTableColumn(field, tableAlias))));
                const builtRelation = this.buildRelationalQueryWithoutLateralSubqueries({
                    fullSchema,
                    schema,
                    tableNamesMap,
                    table: fullSchema[relationTableTsName],
                    tableConfig: schema[relationTableTsName],
                    queryConfig: is(relation, One)
                        ? (selectedRelationConfigValue === true
                            ? { limit: 1 }
                            : { ...selectedRelationConfigValue, limit: 1 })
                        : selectedRelationConfigValue,
                    tableAlias: relationTableAlias,
                    joinOn,
                    nestedQueryRelation: relation,
                });
                let fieldSql = sql `(${builtRelation.sql})`;
                if (is(relation, Many)) {
                    fieldSql = sql `coalesce(${fieldSql}, json_array())`;
                }
                const field = fieldSql.as(selectedRelationTsKey);
                selection.push({
                    dbKey: selectedRelationTsKey,
                    tsKey: selectedRelationTsKey,
                    field,
                    relationTableTsKey: relationTableTsName,
                    isJson: true,
                    selection: builtRelation.selection,
                });
            }
        }
        if (selection.length === 0) {
            throw new DrizzleError(`No fields selected for table "${tableConfig.tsName}" ("${tableAlias}"). You need to have at least one item in "columns", "with" or "extras". If you need to select all columns, omit the "columns" key or set it to undefined.`);
        }
        let result;
        where = and(joinOn, where);
        if (nestedQueryRelation) {
            let field = sql `json_array(${sql.join(selection.map(({ field }) => is(field, MySqlColumn) ? sql.identifier(field.name) : is(field, SQL.Aliased) ? field.sql : field), sql `, `)})`;
            if (is(nestedQueryRelation, Many)) {
                field = sql `json_arrayagg(${field})`;
            }
            const nestedSelection = [{
                    dbKey: 'data',
                    tsKey: 'data',
                    field,
                    isJson: true,
                    relationTableTsKey: tableConfig.tsName,
                    selection,
                }];
            const needsSubquery = limit !== undefined || offset !== undefined || orderBy.length > 0;
            if (needsSubquery) {
                result = this.buildSelectQuery({
                    table: aliasedTable(table, tableAlias),
                    fields: {},
                    fieldsFlat: [
                        {
                            path: [],
                            field: sql.raw('*'),
                        },
                        ...(orderBy.length > 0)
                            ? [{
                                    path: [],
                                    field: sql `row_number() over (order by ${sql.join(orderBy, sql `, `)})`,
                                }]
                            : [],
                    ],
                    where,
                    limit,
                    offset,
                });
                where = undefined;
                limit = undefined;
                offset = undefined;
                orderBy = undefined;
            }
            else {
                result = aliasedTable(table, tableAlias);
            }
            result = this.buildSelectQuery({
                table: is(result, MySqlTable) ? result : new Subquery(result, {}, tableAlias),
                fields: {},
                fieldsFlat: nestedSelection.map(({ field }) => ({
                    path: [],
                    field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
                })),
                where,
                limit,
                offset,
                orderBy,
            });
        }
        else {
            result = this.buildSelectQuery({
                table: aliasedTable(table, tableAlias),
                fields: {},
                fieldsFlat: selection.map(({ field }) => ({
                    path: [],
                    field: is(field, Column) ? aliasedTableColumn(field, tableAlias) : field,
                })),
                where,
                limit,
                offset,
                orderBy,
            });
        }
        return {
            tableTsKey: tableConfig.tsName,
            sql: result,
            selection,
        };
    }
}

class MySqlSelectBuilder {
    static [entityKind] = 'MySqlSelectBuilder';
    fields;
    session;
    dialect;
    withList = [];
    distinct;
    constructor(config) {
        this.fields = config.fields;
        this.session = config.session;
        this.dialect = config.dialect;
        if (config.withList) {
            this.withList = config.withList;
        }
        this.distinct = config.distinct;
    }
    from(source) {
        const isPartialSelect = !!this.fields;
        let fields;
        if (this.fields) {
            fields = this.fields;
        }
        else if (is(source, Subquery)) {
            // This is required to use the proxy handler to get the correct field values from the subquery
            fields = Object.fromEntries(Object.keys(source[SubqueryConfig].selection).map((key) => [key, source[key]]));
        }
        else if (is(source, MySqlViewBase)) {
            fields = source[ViewBaseConfig].selectedFields;
        }
        else if (is(source, SQL)) {
            fields = {};
        }
        else {
            fields = getTableColumns(source);
        }
        return new MySqlSelect({
            table: source,
            fields,
            isPartialSelect,
            session: this.session,
            dialect: this.dialect,
            withList: this.withList,
            distinct: this.distinct,
        });
    }
}
class MySqlSelectQueryBuilder extends TypedQueryBuilder {
    static [entityKind] = 'MySqlSelectQueryBuilder';
    _;
    config;
    joinsNotNullableMap;
    tableName;
    isPartialSelect;
    /** @internal */
    session;
    dialect;
    constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }) {
        super();
        this.config = {
            withList,
            table,
            fields: { ...fields },
            distinct,
        };
        this.isPartialSelect = isPartialSelect;
        this.session = session;
        this.dialect = dialect;
        this._ = {
            selectedFields: fields,
        };
        this.tableName = getTableLikeName(table);
        this.joinsNotNullableMap = typeof this.tableName === 'string' ? { [this.tableName]: true } : {};
    }
    createJoin(joinType) {
        return (table, on) => {
            const baseTableName = this.tableName;
            const tableName = getTableLikeName(table);
            if (typeof tableName === 'string' && this.config.joins?.some((join) => join.alias === tableName)) {
                throw new Error(`Alias "${tableName}" is already used in this query`);
            }
            if (!this.isPartialSelect) {
                // If this is the first join and this is not a partial select and we're not selecting from raw SQL, "move" the fields from the main table to the nested object
                if (Object.keys(this.joinsNotNullableMap).length === 1 && typeof baseTableName === 'string') {
                    this.config.fields = {
                        [baseTableName]: this.config.fields,
                    };
                }
                if (typeof tableName === 'string' && !is(table, SQL)) {
                    const selection = is(table, Subquery)
                        ? table[SubqueryConfig].selection
                        : is(table, View)
                            ? table[ViewBaseConfig].selectedFields
                            : table[Table.Symbol.Columns];
                    this.config.fields[tableName] = selection;
                }
            }
            if (typeof on === 'function') {
                on = on(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' })));
            }
            if (!this.config.joins) {
                this.config.joins = [];
            }
            this.config.joins.push({ on, table, joinType, alias: tableName });
            if (typeof tableName === 'string') {
                switch (joinType) {
                    case 'left': {
                        this.joinsNotNullableMap[tableName] = false;
                        break;
                    }
                    case 'right': {
                        this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
                        this.joinsNotNullableMap[tableName] = true;
                        break;
                    }
                    case 'inner': {
                        this.joinsNotNullableMap[tableName] = true;
                        break;
                    }
                    case 'full': {
                        this.joinsNotNullableMap = Object.fromEntries(Object.entries(this.joinsNotNullableMap).map(([key]) => [key, false]));
                        this.joinsNotNullableMap[tableName] = false;
                        break;
                    }
                }
            }
            return this;
        };
    }
    leftJoin = this.createJoin('left');
    rightJoin = this.createJoin('right');
    innerJoin = this.createJoin('inner');
    fullJoin = this.createJoin('full');
    where(where) {
        if (typeof where === 'function') {
            where = where(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' })));
        }
        this.config.where = where;
        return this;
    }
    having(having) {
        if (typeof having === 'function') {
            having = having(new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: 'sql', sqlBehavior: 'sql' })));
        }
        this.config.having = having;
        return this;
    }
    groupBy(...columns) {
        if (typeof columns[0] === 'function') {
            const groupBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: 'alias', sqlBehavior: 'sql' })));
            this.config.groupBy = Array.isArray(groupBy) ? groupBy : [groupBy];
        }
        else {
            this.config.groupBy = columns;
        }
        return this;
    }
    orderBy(...columns) {
        if (typeof columns[0] === 'function') {
            const orderBy = columns[0](new Proxy(this.config.fields, new SelectionProxyHandler({ sqlAliasedBehavior: 'alias', sqlBehavior: 'sql' })));
            this.config.orderBy = Array.isArray(orderBy) ? orderBy : [orderBy];
        }
        else {
            this.config.orderBy = columns;
        }
        return this;
    }
    limit(limit) {
        this.config.limit = limit;
        return this;
    }
    offset(offset) {
        this.config.offset = offset;
        return this;
    }
    for(strength, config = {}) {
        this.config.lockingClause = { strength, config };
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildSelectQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    as(alias) {
        return new Proxy(new Subquery(this.getSQL(), this.config.fields, alias), new SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }));
    }
}
class MySqlSelect extends MySqlSelectQueryBuilder {
    static [entityKind] = 'MySqlSelect';
    prepare() {
        if (!this.session) {
            throw new Error('Cannot execute a query on a query builder. Please use a database instance instead.');
        }
        const fieldsList = orderSelectedFields(this.config.fields);
        const query = this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), fieldsList);
        query.joinsNotNullableMap = this.joinsNotNullableMap;
        return query;
    }
    execute = ((placeholderValues) => {
        return this.prepare().execute(placeholderValues);
    });
    createIterator = () => {
        const self = this;
        return async function* (placeholderValues) {
            yield* self.prepare().iterator(placeholderValues);
        };
    };
    iterator = this.createIterator();
}
applyMixins(MySqlSelect, [QueryPromise]);

class QueryBuilder {
    static [entityKind] = 'MySqlQueryBuilder';
    dialect;
    $with(alias) {
        const queryBuilder = this;
        return {
            as(qb) {
                if (typeof qb === 'function') {
                    qb = qb(queryBuilder);
                }
                return new Proxy(new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }));
            },
        };
    }
    with(...queries) {
        const self = this;
        function select(fields) {
            return new MySqlSelectBuilder({
                fields: fields ?? undefined,
                session: undefined,
                dialect: self.getDialect(),
                withList: queries,
            });
        }
        function selectDistinct(fields) {
            return new MySqlSelectBuilder({
                fields: fields ?? undefined,
                session: undefined,
                dialect: self.getDialect(),
                withList: queries,
                distinct: true,
            });
        }
        return { select, selectDistinct };
    }
    select(fields) {
        return new MySqlSelectBuilder({ fields: fields ?? undefined, session: undefined, dialect: this.getDialect() });
    }
    selectDistinct(fields) {
        return new MySqlSelectBuilder({
            fields: fields ?? undefined,
            session: undefined,
            dialect: this.getDialect(),
            distinct: true,
        });
    }
    // Lazy load dialect to avoid circular dependency
    getDialect() {
        if (!this.dialect) {
            this.dialect = new MySqlDialect();
        }
        return this.dialect;
    }
}

class MySqlUpdateBuilder {
    table;
    session;
    dialect;
    static [entityKind] = 'MySqlUpdateBuilder';
    constructor(table, session, dialect) {
        this.table = table;
        this.session = session;
        this.dialect = dialect;
    }
    set(values) {
        return new MySqlUpdate(this.table, mapUpdateSet(this.table, values), this.session, this.dialect);
    }
}
class MySqlUpdate extends QueryPromise {
    session;
    dialect;
    static [entityKind] = 'MySqlUpdate';
    config;
    constructor(table, set, session, dialect) {
        super();
        this.session = session;
        this.dialect = dialect;
        this.config = { set, table };
    }
    where(where) {
        this.config.where = where;
        return this;
    }
    /** @internal */
    getSQL() {
        return this.dialect.buildUpdateQuery(this.config);
    }
    toSQL() {
        const { typings: _typings, ...rest } = this.dialect.sqlToQuery(this.getSQL());
        return rest;
    }
    prepare() {
        return this.session.prepareQuery(this.dialect.sqlToQuery(this.getSQL()), this.config.returning);
    }
    execute = (placeholderValues) => {
        return this.prepare().execute(placeholderValues);
    };
    createIterator = () => {
        const self = this;
        return async function* (placeholderValues) {
            yield* self.prepare().iterator(placeholderValues);
        };
    };
    iterator = this.createIterator();
}

class RelationalQueryBuilder {
    fullSchema;
    schema;
    tableNamesMap;
    table;
    tableConfig;
    dialect;
    session;
    mode;
    static [entityKind] = 'MySqlRelationalQueryBuilder';
    constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session, mode) {
        this.fullSchema = fullSchema;
        this.schema = schema;
        this.tableNamesMap = tableNamesMap;
        this.table = table;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
        this.mode = mode;
    }
    findMany(config) {
        return new MySqlRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? config : {}, 'many', this.mode);
    }
    findFirst(config) {
        return new MySqlRelationalQuery(this.fullSchema, this.schema, this.tableNamesMap, this.table, this.tableConfig, this.dialect, this.session, config ? { ...config, limit: 1 } : { limit: 1 }, 'first', this.mode);
    }
}
class MySqlRelationalQuery extends QueryPromise {
    fullSchema;
    schema;
    tableNamesMap;
    table;
    tableConfig;
    dialect;
    session;
    config;
    queryMode;
    mode;
    static [entityKind] = 'MySqlRelationalQuery';
    constructor(fullSchema, schema, tableNamesMap, table, tableConfig, dialect, session, config, queryMode, mode) {
        super();
        this.fullSchema = fullSchema;
        this.schema = schema;
        this.tableNamesMap = tableNamesMap;
        this.table = table;
        this.tableConfig = tableConfig;
        this.dialect = dialect;
        this.session = session;
        this.config = config;
        this.queryMode = queryMode;
        this.mode = mode;
    }
    prepare() {
        const query = this.mode === 'planetscale'
            ? this.dialect.buildRelationalQueryWithoutLateralSubqueries({
                fullSchema: this.fullSchema,
                schema: this.schema,
                tableNamesMap: this.tableNamesMap,
                table: this.table,
                tableConfig: this.tableConfig,
                queryConfig: this.config,
                tableAlias: this.tableConfig.tsName,
            })
            : this.dialect.buildRelationalQuery({
                fullSchema: this.fullSchema,
                schema: this.schema,
                tableNamesMap: this.tableNamesMap,
                table: this.table,
                tableConfig: this.tableConfig,
                queryConfig: this.config,
                tableAlias: this.tableConfig.tsName,
            });
        const builtQuery = this.dialect.sqlToQuery(query.sql);
        return this.session.prepareQuery(builtQuery, undefined, (rawRows) => {
            const rows = rawRows.map((row) => mapRelationalRow(this.schema, this.tableConfig, row, query.selection));
            if (this.queryMode === 'first') {
                return rows[0];
            }
            return rows;
        });
    }
    execute() {
        return this.prepare().execute();
    }
}

class MySqlDatabase {
    dialect;
    session;
    mode;
    static [entityKind] = 'MySqlDatabase';
    query;
    constructor(
    /** @internal */
    dialect, 
    /** @internal */
    session, schema, mode) {
        this.dialect = dialect;
        this.session = session;
        this.mode = mode;
        this._ = schema
            ? { schema: schema.schema, tableNamesMap: schema.tableNamesMap }
            : { schema: undefined, tableNamesMap: {} };
        this.query = {};
        if (this._.schema) {
            for (const [tableName, columns] of Object.entries(this._.schema)) {
                this.query[tableName] =
                    new RelationalQueryBuilder(schema.fullSchema, this._.schema, this._.tableNamesMap, schema.fullSchema[tableName], columns, dialect, session, this.mode);
            }
        }
    }
    $with(alias) {
        return {
            as(qb) {
                if (typeof qb === 'function') {
                    qb = qb(new QueryBuilder());
                }
                return new Proxy(new WithSubquery(qb.getSQL(), qb.getSelectedFields(), alias, true), new SelectionProxyHandler({ alias, sqlAliasedBehavior: 'alias', sqlBehavior: 'error' }));
            },
        };
    }
    with(...queries) {
        const self = this;
        function select(fields) {
            return new MySqlSelectBuilder({
                fields: fields ?? undefined,
                session: self.session,
                dialect: self.dialect,
                withList: queries,
            });
        }
        function selectDistinct(fields) {
            return new MySqlSelectBuilder({
                fields: fields ?? undefined,
                session: self.session,
                dialect: self.dialect,
                withList: queries,
                distinct: true,
            });
        }
        return { select, selectDistinct };
    }
    select(fields) {
        return new MySqlSelectBuilder({ fields: fields ?? undefined, session: this.session, dialect: this.dialect });
    }
    selectDistinct(fields) {
        return new MySqlSelectBuilder({
            fields: fields ?? undefined,
            session: this.session,
            dialect: this.dialect,
            distinct: true,
        });
    }
    update(table) {
        return new MySqlUpdateBuilder(table, this.session, this.dialect);
    }
    insert(table) {
        return new MySqlInsertBuilder(table, this.session, this.dialect);
    }
    delete(table) {
        return new MySqlDelete(table, this.session, this.dialect);
    }
    execute(query) {
        return this.session.execute(query.getSQL());
    }
    transaction(transaction, config) {
        return this.session.transaction(transaction, config);
    }
}

class PreparedQuery {
    static [entityKind] = 'MySqlPreparedQuery';
    /** @internal */
    joinsNotNullableMap;
}
class MySqlSession {
    dialect;
    static [entityKind] = 'MySqlSession';
    constructor(dialect) {
        this.dialect = dialect;
    }
    execute(query) {
        return this.prepareQuery(this.dialect.sqlToQuery(query), undefined).execute();
    }
    getSetTransactionSQL(config) {
        const parts = [];
        if (config.isolationLevel) {
            parts.push(`isolation level ${config.isolationLevel}`);
        }
        return parts.length ? sql.join(['set transaction ', parts.join(' ')]) : undefined;
    }
    getStartTransactionSQL(config) {
        const parts = [];
        if (config.withConsistentSnapshot) {
            parts.push('with consistent snapshot');
        }
        if (config.accessMode) {
            parts.push(config.accessMode);
        }
        return parts.length ? sql.join(['start transaction ', parts.join(' ')]) : undefined;
    }
}
class MySqlTransaction extends MySqlDatabase {
    schema;
    nestedIndex;
    static [entityKind] = 'MySqlTransaction';
    constructor(dialect, session, schema, nestedIndex, mode) {
        super(dialect, session, schema, mode);
        this.schema = schema;
        this.nestedIndex = nestedIndex;
    }
    rollback() {
        throw new TransactionRollbackError();
    }
}

export { mysqlTableCreator as A, ViewBuilder as B, ManualViewBuilder as C, MySqlViewBase as D, MySqlView as E, ForeignKeyBuilder as F, mysqlView as G, InlineForeignKeys as I, MySqlSession as M, PreparedQuery as P, QueryBuilder as Q, UniqueConstraintBuilder as U, ViewBuilderCore as V, MySqlTransaction as a, MySqlDatabase as b, MySqlDialect as c, MySqlColumnBuilderWithAutoIncrement as d, MySqlColumnWithAutoIncrement as e, MySqlColumnBuilder as f, MySqlColumn as g, MySqlTable as h, mysqlViewWithSchema as i, MySqlViewConfig as j, ForeignKey as k, foreignKey as l, mysqlTableWithSchema as m, uniqueKeyName as n, UniqueOnConstraintBuilder as o, UniqueConstraint as p, MySqlDelete as q, MySqlInsertBuilder as r, MySqlInsert as s, MySqlSelectBuilder as t, unique as u, MySqlSelectQueryBuilder as v, MySqlSelect as w, MySqlUpdateBuilder as x, MySqlUpdate as y, mysqlTable as z };
//# sourceMappingURL=session-ac71392b.mjs.map
