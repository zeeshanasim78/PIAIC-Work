/// <reference types="node" />
/// <reference types="bun-types" />
import { g as SQLiteView, h as SQLiteViewBase, i as BuildAliasTable } from '../select.types.d-7da7fae0.js';
export { A as AnySQLiteSelect, B as BaseSQLiteDatabase, J as Join, u as JoinFn, M as ManualViewBuilder, P as PreparedQuery, e as PreparedQueryConfig, Q as QueryBuilder, R as Result, f as SQLiteAsyncDialect, l as SQLiteDelete, k as SQLiteDeleteConfig, j as SQLiteDialect, p as SQLiteInsert, o as SQLiteInsertBuilder, m as SQLiteInsertConfig, n as SQLiteInsertValue, s as SQLiteSelect, q as SQLiteSelectBuilder, t as SQLiteSelectConfig, C as SQLiteSelectHKT, x as SQLiteSelectHKTBase, y as SQLiteSelectKind, r as SQLiteSelectQueryBuilder, z as SQLiteSelectQueryBuilderHKT, S as SQLiteSession, a as SQLiteSyncDialect, d as SQLiteTransaction, c as SQLiteTransactionConfig, G as SQLiteUpdate, F as SQLiteUpdateBuilder, D as SQLiteUpdateConfig, E as SQLiteUpdateSetSource, L as SQLiteViewConfig, N as SQLiteViewWithSelection, w as SelectedFields, v as SelectedFieldsFlat, b as SelectedFieldsOrdered, H as SubqueryWithSelection, K as ViewBuilder, V as ViewBuilderConfig, I as ViewBuilderCore, W as WithSubqueryWithSelection, O as sqliteView, T as view } from '../select.types.d-7da7fae0.js';
import { i as ColumnBuilderBaseConfig, aK as SQLiteColumnBuilder, e as entityKind, b as ColumnBaseConfig, aL as SQLiteColumn, aw as Equal, aM as AnySQLiteTable, a as SQL, aN as Index, aO as ForeignKey, aP as Check, aQ as PrimaryKey, aR as UniqueConstraint, E as SelectedFields, A as AnyColumn, T as Table, ak as TableConfig, C as Column, g as ColumnDataType, H as HasDefault, N as NotNull, j as MakeColumnConfig, az as Or, aC as Writable, aS as SQLiteTable } from '../column.d-04875079.js';
export { aW as AnySQLiteColumn, aT as CheckBuilder, aZ as ForeignKeyBuilder, b2 as IndexBuilder, b1 as IndexBuilderOn, b0 as IndexColumn, a$ as IndexConfig, b6 as PrimaryKeyBuilder, aY as Reference, aV as ReferenceConfig, b7 as SQLiteTableExtraConfig, ba as SQLiteTableFn, b9 as SQLiteTableWithColumns, b8 as TableConfig, bf as UniqueConstraintBuilder, bg as UniqueOnConstraintBuilder, aX as UpdateDeleteAction, aU as check, a_ as foreignKey, b3 as index, b5 as primaryKey, bb as sqliteTable, bc as sqliteTableCreator, be as unique, b4 as uniqueIndex, bd as uniqueKeyName } from '../column.d-04875079.js';
import '../select.types.d-f5caa4d6.js';
import '../migrator.js';
import '../query-promise.d-31db3408.js';

type BlobMode = 'buffer' | 'json' | 'bigint';
type SQLiteBigIntBuilderInitial<TName extends string> = SQLiteBigIntBuilder<{
    name: TName;
    dataType: 'bigint';
    columnType: 'SQLiteBigInt';
    data: bigint;
    driverParam: Buffer;
    enumValues: undefined;
}>;
declare class SQLiteBigIntBuilder<T extends ColumnBuilderBaseConfig<'bigint', 'SQLiteBigInt'>> extends SQLiteColumnBuilder<T> {
    static readonly [entityKind]: string;
    constructor(name: T['name']);
}
declare class SQLiteBigInt<T extends ColumnBaseConfig<'bigint', 'SQLiteBigInt'>> extends SQLiteColumn<T> {
    static readonly [entityKind]: string;
    getSQLType(): string;
    mapFromDriverValue(value: Buffer): bigint;
    mapToDriverValue(value: bigint): Buffer;
}
type SQLiteBlobJsonBuilderInitial<TName extends string> = SQLiteBlobJsonBuilder<{
    name: TName;
    dataType: 'json';
    columnType: 'SQLiteBlobJson';
    data: unknown;
    driverParam: Buffer;
    enumValues: undefined;
}>;
declare class SQLiteBlobJsonBuilder<T extends ColumnBuilderBaseConfig<'json', 'SQLiteBlobJson'>> extends SQLiteColumnBuilder<T> {
    static readonly [entityKind]: string;
    constructor(name: T['name']);
}
declare class SQLiteBlobJson<T extends ColumnBaseConfig<'json', 'SQLiteBlobJson'>> extends SQLiteColumn<T> {
    static readonly [entityKind]: string;
    getSQLType(): string;
    mapFromDriverValue(value: Buffer): T['data'];
    mapToDriverValue(value: T['data']): Buffer;
}
type SQLiteBlobBufferBuilderInitial<TName extends string> = SQLiteBlobBufferBuilder<{
    name: TName;
    dataType: 'buffer';
    columnType: 'SQLiteBlobBuffer';
    data: Buffer;
    driverParam: Buffer;
    enumValues: undefined;
}>;
declare class SQLiteBlobBufferBuilder<T extends ColumnBuilderBaseConfig<'buffer', 'SQLiteBlobBuffer'>> extends SQLiteColumnBuilder<T> {
    static readonly [entityKind]: string;
    constructor(name: T['name']);
}
declare class SQLiteBlobBuffer<T extends ColumnBaseConfig<'buffer', 'SQLiteBlobBuffer'>> extends SQLiteColumn<T> {
    static readonly [entityKind]: string;
    getSQLType(): string;
}
interface BlobConfig<TMode extends BlobMode = BlobMode> {
    mode: TMode;
}
declare function blob<TName extends string, TMode extends BlobMode = BlobMode>(name: TName, config?: BlobConfig<TMode>): Equal<TMode, 'bigint'> extends true ? SQLiteBigIntBuilderInitial<TName> : Equal<TMode, 'buffer'> extends true ? SQLiteBlobBufferBuilderInitial<TName> : SQLiteBlobJsonBuilderInitial<TName>;

type ConvertCustomConfig<TName extends string, T extends Partial<CustomTypeValues>> = {
    name: TName;
    dataType: 'custom';
    columnType: 'SQLiteCustomColumn';
    data: T['data'];
    driverParam: T['driverData'];
    enumValues: undefined;
} & (T['notNull'] extends true ? {
    notNull: true;
} : {}) & (T['default'] extends true ? {
    hasDefault: true;
} : {});
interface SQLiteCustomColumnInnerConfig {
    customTypeValues: CustomTypeValues;
}
declare class SQLiteCustomColumnBuilder<T extends ColumnBuilderBaseConfig<'custom', 'SQLiteCustomColumn'>> extends SQLiteColumnBuilder<T, {
    fieldConfig: CustomTypeValues['config'];
    customTypeParams: CustomTypeParams<any>;
}, {
    sqliteColumnBuilderBrand: 'SQLiteCustomColumnBuilderBrand';
}> {
    static readonly [entityKind]: string;
    constructor(name: T['name'], fieldConfig: CustomTypeValues['config'], customTypeParams: CustomTypeParams<any>);
}
declare class SQLiteCustomColumn<T extends ColumnBaseConfig<'custom', 'SQLiteCustomColumn'>> extends SQLiteColumn<T> {
    static readonly [entityKind]: string;
    private sqlName;
    private mapTo?;
    private mapFrom?;
    constructor(table: AnySQLiteTable<{
        name: T['tableName'];
    }>, config: SQLiteCustomColumnBuilder<T>['config']);
    getSQLType(): string;
    mapFromDriverValue(value: T['driverParam']): T['data'];
    mapToDriverValue(value: T['data']): T['driverParam'];
}
type CustomTypeValues = {
    /**
     * Required type for custom column, that will infer proper type model
     *
     * Examples:
     *
     * If you want your column to be `string` type after selecting/or on inserting - use `data: string`. Like `text`, `varchar`
     *
     * If you want your column to be `number` type after selecting/or on inserting - use `data: number`. Like `integer`
     */
    data: unknown;
    /**
     * Type helper, that represents what type database driver is accepting for specific database data type
     */
    driverData?: unknown;
    /**
     * What config type should be used for {@link CustomTypeParams} `dataType` generation
     */
    config?: unknown;
    /**
     * Whether the config argument should be required or not
     * @default false
     */
    configRequired?: boolean;
    /**
     * If your custom data type should be notNull by default you can use `notNull: true`
     *
     * @example
     * const customSerial = customType<{ data: number, notNull: true, default: true }>({
     * 	  dataType() {
     * 	    return 'serial';
     *    },
     * });
     */
    notNull?: boolean;
    /**
     * If your custom data type has default you can use `default: true`
     *
     * @example
     * const customSerial = customType<{ data: number, notNull: true, default: true }>({
     * 	  dataType() {
     * 	    return 'serial';
     *    },
     * });
     */
    default?: boolean;
};
interface CustomTypeParams<T extends CustomTypeValues> {
    /**
     * Database data type string representation, that is used for migrations
     * @example
     * ```
     * `jsonb`, `text`
     * ```
     *
     * If database data type needs additional params you can use them from `config` param
     * @example
     * ```
     * `varchar(256)`, `numeric(2,3)`
     * ```
     *
     * To make `config` be of specific type please use config generic in {@link CustomTypeValues}
     *
     * @example
     * Usage example
     * ```
     *   dataType() {
     *     return 'boolean';
     *   },
     * ```
     * Or
     * ```
     *   dataType(config) {
     * 	   return typeof config.length !== 'undefined' ? `varchar(${config.length})` : `varchar`;
     * 	 }
     * ```
     */
    dataType: (config: T['config'] | (Equal<T['configRequired'], true> extends true ? never : undefined)) => string;
    /**
     * Optional mapping function, between user input and driver
     * @example
     * For example, when using jsonb we need to map JS/TS object to string before writing to database
     * ```
     * toDriver(value: TData): string {
     * 	 return JSON.stringify(value);
     * }
     * ```
     */
    toDriver?: (value: T['data']) => T['driverData'] | SQL;
    /**
     * Optional mapping function, that is responsible for data mapping from database to JS/TS code
     * @example
     * For example, when using timestamp we need to map string Date representation to JS Date
     * ```
     * fromDriver(value: string): Date {
     * 	return new Date(value);
     * },
     * ```
     */
    fromDriver?: (value: T['driverData']) => T['data'];
}
/**
 * Custom sqlite database data type generator
 */
declare function customType<T extends CustomTypeValues = CustomTypeValues>(customTypeParams: CustomTypeParams<T>): Equal<T['configRequired'], true> extends true ? <TName extends string>(dbName: TName, fieldConfig: T['config']) => SQLiteCustomColumnBuilder<ConvertCustomConfig<TName, T>> : <TName extends string>(dbName: TName, fieldConfig?: T['config']) => SQLiteCustomColumnBuilder<ConvertCustomConfig<TName, T>>;

declare function getTableConfig<TTable extends AnySQLiteTable>(table: TTable): {
    columns: SQLiteColumn<any, object>[];
    indexes: Index[];
    foreignKeys: ForeignKey[];
    checks: Check[];
    primaryKeys: PrimaryKey[];
    uniqueConstraints: UniqueConstraint[];
    name: string;
};
type OnConflict = 'rollback' | 'abort' | 'fail' | 'ignore' | 'replace';
declare function getViewConfig<TName extends string = string, TExisting extends boolean = boolean>(view: SQLiteView<TName, TExisting>): {
    algorithm?: "undefined" | "merge" | "temptable" | undefined;
    definer?: string | undefined;
    sqlSecurity?: "definer" | "invoker" | undefined;
    withCheckOption?: "local" | "cascaded" | undefined;
    name: TName;
    originalName: TName;
    schema: string | undefined;
    selectedFields: SelectedFields<AnyColumn, Table<TableConfig<Column<any, object, object>>>>;
    isExisting: TExisting;
    query: TExisting extends true ? undefined : SQL<unknown>;
    isAlias: boolean;
};

interface PrimaryKeyConfig {
    autoIncrement?: boolean;
    onConflict?: OnConflict;
}
declare abstract class SQLiteBaseIntegerBuilder<T extends ColumnBuilderBaseConfig<ColumnDataType, string>, TRuntimeConfig extends object = object> extends SQLiteColumnBuilder<T, TRuntimeConfig & {
    autoIncrement: boolean;
}, {}, {
    primaryKeyHasDefault: true;
}> {
    static readonly [entityKind]: string;
    constructor(name: T['name'], dataType: T['dataType'], columnType: T['columnType']);
    primaryKey(config?: PrimaryKeyConfig): HasDefault<NotNull<this>>;
}
declare abstract class SQLiteBaseInteger<T extends ColumnBaseConfig<ColumnDataType, string>, TRuntimeConfig extends object = object> extends SQLiteColumn<T, TRuntimeConfig & {
    autoIncrement: boolean;
}> {
    static readonly [entityKind]: string;
    readonly autoIncrement: boolean;
    getSQLType(): string;
}
type SQLiteIntegerBuilderInitial<TName extends string> = SQLiteIntegerBuilder<{
    name: TName;
    dataType: 'number';
    columnType: 'SQLiteInteger';
    data: number;
    driverParam: number;
    enumValues: undefined;
}>;
declare class SQLiteIntegerBuilder<T extends ColumnBuilderBaseConfig<'number', 'SQLiteInteger'>> extends SQLiteBaseIntegerBuilder<T> {
    static readonly [entityKind]: string;
    constructor(name: T['name']);
    build<TTableName extends string>(table: AnySQLiteTable<{
        name: TTableName;
    }>): SQLiteInteger<MakeColumnConfig<T, TTableName>>;
}
declare class SQLiteInteger<T extends ColumnBaseConfig<'number', 'SQLiteInteger'>> extends SQLiteBaseInteger<T> {
    static readonly [entityKind]: string;
}
type SQLiteTimestampBuilderInitial<TName extends string> = SQLiteTimestampBuilder<{
    name: TName;
    dataType: 'date';
    columnType: 'SQLiteTimestamp';
    data: Date;
    driverParam: number;
    enumValues: undefined;
}>;
declare class SQLiteTimestampBuilder<T extends ColumnBuilderBaseConfig<'date', 'SQLiteTimestamp'>> extends SQLiteBaseIntegerBuilder<T, {
    mode: 'timestamp' | 'timestamp_ms';
}> {
    static readonly [entityKind]: string;
    constructor(name: T['name'], mode: 'timestamp' | 'timestamp_ms');
    /**
     * @deprecated Use `default()` with your own expression instead.
     *
     * Adds `DEFAULT (cast((julianday('now') - 2440587.5)*86400000 as integer))` to the column, which is the current epoch timestamp in milliseconds.
     */
    defaultNow(): HasDefault<this>;
    build<TTableName extends string>(table: AnySQLiteTable<{
        name: TTableName;
    }>): SQLiteTimestamp<MakeColumnConfig<T, TTableName>>;
}
declare class SQLiteTimestamp<T extends ColumnBaseConfig<'date', 'SQLiteTimestamp'>> extends SQLiteBaseInteger<T, {
    mode: 'timestamp' | 'timestamp_ms';
}> {
    static readonly [entityKind]: string;
    readonly mode: 'timestamp' | 'timestamp_ms';
    mapFromDriverValue(value: number): Date;
    mapToDriverValue(value: Date): number;
}
type SQLiteBooleanBuilderInitial<TName extends string> = SQLiteBooleanBuilder<{
    name: TName;
    dataType: 'boolean';
    columnType: 'SQLiteBoolean';
    data: boolean;
    driverParam: number;
    enumValues: undefined;
}>;
declare class SQLiteBooleanBuilder<T extends ColumnBuilderBaseConfig<'boolean', 'SQLiteBoolean'>> extends SQLiteBaseIntegerBuilder<T, {
    mode: 'boolean';
}> {
    static readonly [entityKind]: string;
    constructor(name: T['name'], mode: 'boolean');
    build<TTableName extends string>(table: AnySQLiteTable<{
        name: TTableName;
    }>): SQLiteBoolean<MakeColumnConfig<T, TTableName>>;
}
declare class SQLiteBoolean<T extends ColumnBaseConfig<'boolean', 'SQLiteBoolean'>> extends SQLiteBaseInteger<T, {
    mode: 'boolean';
}> {
    static readonly [entityKind]: string;
    readonly mode: 'boolean';
    mapFromDriverValue(value: number): boolean;
    mapToDriverValue(value: boolean): number;
}
interface IntegerConfig<TMode extends 'number' | 'timestamp' | 'timestamp_ms' | 'boolean' = 'number' | 'timestamp' | 'timestamp_ms' | 'boolean'> {
    mode: TMode;
}
declare function integer<TName extends string, TMode extends IntegerConfig['mode']>(name: TName, config?: IntegerConfig<TMode>): Or<Equal<TMode, 'timestamp'>, Equal<TMode, 'timestamp_ms'>> extends true ? SQLiteTimestampBuilderInitial<TName> : Equal<TMode, 'boolean'> extends true ? SQLiteBooleanBuilderInitial<TName> : SQLiteIntegerBuilderInitial<TName>;
declare const int: typeof integer;

type SQLiteNumericBuilderInitial<TName extends string> = SQLiteNumericBuilder<{
    name: TName;
    dataType: 'string';
    columnType: 'SQLiteNumeric';
    data: string;
    driverParam: string;
    enumValues: undefined;
}>;
declare class SQLiteNumericBuilder<T extends ColumnBuilderBaseConfig<'string', 'SQLiteNumeric'>> extends SQLiteColumnBuilder<T> {
    static readonly [entityKind]: string;
    constructor(name: T['name']);
}
declare class SQLiteNumeric<T extends ColumnBaseConfig<'string', 'SQLiteNumeric'>> extends SQLiteColumn<T> {
    static readonly [entityKind]: string;
    getSQLType(): string;
}
declare function numeric<TName extends string>(name: TName): SQLiteNumericBuilderInitial<TName>;

type SQLiteRealBuilderInitial<TName extends string> = SQLiteRealBuilder<{
    name: TName;
    dataType: 'number';
    columnType: 'SQLiteReal';
    data: number;
    driverParam: number;
    enumValues: undefined;
}>;
declare class SQLiteRealBuilder<T extends ColumnBuilderBaseConfig<'number', 'SQLiteReal'>> extends SQLiteColumnBuilder<T> {
    static readonly [entityKind]: string;
    constructor(name: T['name']);
}
declare class SQLiteReal<T extends ColumnBaseConfig<'number', 'SQLiteReal'>> extends SQLiteColumn<T> {
    static readonly [entityKind]: string;
    getSQLType(): string;
}
declare function real<TName extends string>(name: TName): SQLiteRealBuilderInitial<TName>;

type SQLiteTextBuilderInitial<TName extends string, TEnum extends [string, ...string[]]> = SQLiteTextBuilder<{
    name: TName;
    dataType: 'string';
    columnType: 'SQLiteText';
    data: TEnum[number];
    driverParam: string;
    enumValues: TEnum;
}>;
declare class SQLiteTextBuilder<T extends ColumnBuilderBaseConfig<'string', 'SQLiteText'>> extends SQLiteColumnBuilder<T, {
    length: number | undefined;
    enumValues: T['enumValues'];
}> {
    static readonly [entityKind]: string;
    constructor(name: T['name'], config: SQLiteTextConfig<T['enumValues']>);
}
declare class SQLiteText<T extends ColumnBaseConfig<'string', 'SQLiteText'>> extends SQLiteColumn<T, {
    length: number | undefined;
    enumValues: T['enumValues'];
}> {
    static readonly [entityKind]: string;
    readonly enumValues: T["enumValues"];
    readonly length: number | undefined;
    constructor(table: AnySQLiteTable<{
        name: T['tableName'];
    }>, config: SQLiteTextBuilder<T>['config']);
    getSQLType(): string;
}
interface SQLiteTextConfig<TEnum extends readonly string[] | string[] | undefined> {
    length?: number;
    enum?: TEnum;
}
declare function text<TName extends string, U extends string, T extends Readonly<[U, ...U[]]>>(name: TName, config?: SQLiteTextConfig<T | Writable<T>>): SQLiteTextBuilderInitial<TName, Writable<T>>;

declare function alias<TTable extends SQLiteTable | SQLiteViewBase, TAlias extends string>(table: TTable, alias: TAlias): BuildAliasTable<TTable, TAlias>;

export { AnySQLiteTable, BlobConfig, BuildAliasTable, Check, ConvertCustomConfig, CustomTypeParams, CustomTypeValues, ForeignKey, Index, IntegerConfig, OnConflict, PrimaryKey, PrimaryKeyConfig, SQLiteBaseInteger, SQLiteBaseIntegerBuilder, SQLiteBigInt, SQLiteBigIntBuilder, SQLiteBigIntBuilderInitial, SQLiteBlobBuffer, SQLiteBlobBufferBuilder, SQLiteBlobBufferBuilderInitial, SQLiteBlobJson, SQLiteBlobJsonBuilder, SQLiteBlobJsonBuilderInitial, SQLiteBoolean, SQLiteBooleanBuilder, SQLiteBooleanBuilderInitial, SQLiteColumn, SQLiteColumnBuilder, SQLiteCustomColumn, SQLiteCustomColumnBuilder, SQLiteCustomColumnInnerConfig, SQLiteInteger, SQLiteIntegerBuilder, SQLiteIntegerBuilderInitial, SQLiteNumeric, SQLiteNumericBuilder, SQLiteNumericBuilderInitial, SQLiteReal, SQLiteRealBuilder, SQLiteRealBuilderInitial, SQLiteTable, SQLiteText, SQLiteTextBuilder, SQLiteTextBuilderInitial, SQLiteTextConfig, SQLiteTimestamp, SQLiteTimestampBuilder, SQLiteTimestampBuilderInitial, SQLiteView, SQLiteViewBase, UniqueConstraint, alias, blob, customType, getTableConfig, getViewConfig, int, integer, numeric, real, text };
