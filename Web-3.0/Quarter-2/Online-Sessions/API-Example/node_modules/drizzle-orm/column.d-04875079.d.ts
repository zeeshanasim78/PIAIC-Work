declare const entityKind: unique symbol;
declare const hasOwnEntityKind: unique symbol;
interface DrizzleEntity {
    [entityKind]: string;
}
type DrizzleEntityClass<T> = ((abstract new (...args: any[]) => T) | (new (...args: any[]) => T)) & DrizzleEntity;
declare function is<T extends DrizzleEntityClass<any>>(value: any, type: T): value is InstanceType<T>;

declare const ViewBaseConfig: unique symbol;
type ColumnsSelection = Record<string, unknown>;
declare abstract class View<TName extends string = string, TExisting extends boolean = boolean, TSelection extends ColumnsSelection = ColumnsSelection> implements SQLWrapper {
    static readonly [entityKind]: string;
    _: {
        brand: 'View';
        viewBrand: string;
        name: TName;
        existing: TExisting;
        selectedFields: TSelection;
    };
    constructor({ name, schema, selectedFields, query }: {
        name: TName;
        schema: string | undefined;
        selectedFields: SelectedFields<AnyColumn, Table>;
        query: SQL | undefined;
    });
    getSQL(): SQL<unknown>;
}

declare const SubqueryConfig: unique symbol;
declare class Subquery<TAlias extends string = string, TSelectedFields = unknown> implements SQLWrapper {
    static readonly [entityKind]: string;
    _: {
        brand: 'Subquery';
        selectedFields: TSelectedFields;
        alias: TAlias;
    };
    constructor(sql: SQL, selection: Record<string, unknown>, alias: string, isWith?: boolean);
    getSQL(): SQL<unknown>;
}
declare class WithSubquery<TAlias extends string = string, TSelection = unknown> extends Subquery<TAlias, TSelection> {
    static readonly [entityKind]: string;
}
declare class SelectionProxyHandler<T extends Subquery | Record<string, unknown> | View> implements ProxyHandler<Subquery | Record<string, unknown> | View> {
    static readonly [entityKind]: string;
    private config;
    constructor(config: SelectionProxyHandler<T>['config']);
    get(subquery: T, prop: string | symbol): any;
}

/**
 * This class is used to indicate a primitive param value that is used in `sql` tag.
 * It is only used on type level and is never instantiated at runtime.
 * If you see a value of this type in the code, its runtime value is actually the primitive param value.
 */
declare class FakePrimitiveParam {
    static readonly [entityKind]: string;
}
type Chunk = string | Table | View | AnyColumn | Name | Param | Placeholder | SQL;
interface BuildQueryConfig {
    escapeName(name: string): string;
    escapeParam(num: number, value: unknown): string;
    escapeString(str: string): string;
    prepareTyping?: (encoder: DriverValueEncoder<unknown, unknown>) => QueryTypingsValue;
    paramStartIndex?: {
        value: number;
    };
    inlineParams?: boolean;
}
type QueryTypingsValue = 'json' | 'decimal' | 'time' | 'timestamp' | 'uuid' | 'date' | 'none';
interface Query {
    sql: string;
    params: unknown[];
    typings?: QueryTypingsValue[];
}
/**
 * Any value that implements the `getSQL` method. The implementations include:
 * - `Table`
 * - `Column`
 * - `View`
 * - `Subquery`
 * - `SQL`
 * - `SQL.Aliased`
 * - `Placeholder`
 * - `Param`
 */
interface SQLWrapper {
    getSQL(): SQL;
}
declare function isSQLWrapper(value: unknown): value is SQLWrapper;
declare class StringChunk implements SQLWrapper {
    static readonly [entityKind]: string;
    readonly value: string[];
    constructor(value: string | string[]);
    getSQL(): SQL<unknown>;
}
type GetDecoderResult<T> = T extends Column ? T['_']['data'] : T extends DriverValueDecoder<infer TData, any> | DriverValueDecoder<infer TData, any>['mapFromDriverValue'] ? TData : never;
/**
 * Any DB name (table, column, index etc.)
 */
declare class Name implements SQLWrapper {
    readonly value: string;
    static readonly [entityKind]: string;
    protected brand: 'Name';
    constructor(value: string);
    getSQL(): SQL<unknown>;
}
/**
 * Any DB name (table, column, index etc.)
 * @deprecated Use `sql.identifier` instead.
 */
declare function name(value: string): Name;
interface DriverValueDecoder<TData, TDriverParam> {
    mapFromDriverValue(value: TDriverParam): TData;
}
interface DriverValueEncoder<TData, TDriverParam> {
    mapToDriverValue(value: TData): TDriverParam | SQL;
}
declare function isDriverValueEncoder(value: unknown): value is DriverValueEncoder<any, any>;
declare const noopDecoder: DriverValueDecoder<any, any>;
declare const noopEncoder: DriverValueEncoder<any, any>;
interface DriverValueMapper<TData, TDriverParam> extends DriverValueDecoder<TData, TDriverParam>, DriverValueEncoder<TData, TDriverParam> {
}
declare const noopMapper: DriverValueMapper<any, any>;
/** Parameter value that is optionally bound to an encoder (for example, a column). */
declare class Param<TDataType = unknown, TDriverParamType = TDataType> implements SQLWrapper {
    readonly value: TDataType;
    readonly encoder: DriverValueEncoder<TDataType, TDriverParamType>;
    static readonly [entityKind]: string;
    protected brand: 'BoundParamValue';
    /**
     * @param value - Parameter value
     * @param encoder - Encoder to convert the value to a driver parameter
     */
    constructor(value: TDataType, encoder?: DriverValueEncoder<TDataType, TDriverParamType>);
    getSQL(): SQL<unknown>;
}
declare function param<TData, TDriver>(value: TData, encoder?: DriverValueEncoder<TData, TDriver>): Param<TData, TDriver>;
/**
 * Anything that can be passed to the `` sql`...` `` tagged function.
 */
type SQLChunk = StringChunk | SQLChunk[] | SQLWrapper | SQL | Table | View | Subquery | AnyColumn | Param | Name | undefined | FakePrimitiveParam | Placeholder;
declare function sql<T>(strings: TemplateStringsArray, ...params: any[]): SQL<T>;
declare namespace sql {
    function empty(): SQL;
    /** @deprecated - use `sql.join()` */
    function fromList(list: SQLChunk[]): SQL;
    /**
     * Convenience function to create an SQL query from a raw string.
     * @param str The raw SQL query string.
     */
    function raw(str: string): SQL;
    /**
     * Join a list of SQL chunks with a separator.
     * @example
     * ```ts
     * const query = sql.join([sql`a`, sql`b`, sql`c`]);
     * // sql`abc`
     * ```
     * @example
     * ```ts
     * const query = sql.join([sql`a`, sql`b`, sql`c`], sql`, `);
     * // sql`a, b, c`
     * ```
     */
    function join(chunks: SQLChunk[], separator?: SQLChunk): SQL;
    /**
     * Create a SQL chunk that represents a DB identifier (table, column, index etc.).
     * When used in a query, the identifier will be escaped based on the DB engine.
     * For example, in PostgreSQL, identifiers are escaped with double quotes.
     *
     * **WARNING: This function does not offer any protection against SQL injections, so you must validate any user input beforehand.**
     *
     * @example ```ts
     * const query = sql`SELECT * FROM ${sql.identifier('my-table')}`;
     * // 'SELECT * FROM "my-table"'
     * ```
     */
    function identifier(value: string): Name;
}
declare class SQL<T = unknown> implements SQLWrapper {
    readonly queryChunks: SQLChunk[];
    static readonly [entityKind]: string;
    _: {
        brand: 'SQL';
        type: T;
    };
    private shouldInlineParams;
    constructor(queryChunks: SQLChunk[]);
    append(query: SQL): this;
    toQuery(config: BuildQueryConfig): Query;
    buildQueryFromSourceParams(chunks: SQLChunk[], _config: BuildQueryConfig): Query;
    private mapInlineParam;
    getSQL(): SQL;
    as(alias: string): SQL.Aliased<T>;
    /**
     * @deprecated
     * Use ``sql<DataType>`query`.as(alias)`` instead.
     */
    as<TData>(): SQL<TData>;
    /**
     * @deprecated
     * Use ``sql<DataType>`query`.as(alias)`` instead.
     */
    as<TData>(alias: string): SQL.Aliased<TData>;
    mapWith<TDecoder extends DriverValueDecoder<any, any> | DriverValueDecoder<any, any>['mapFromDriverValue']>(decoder: TDecoder): SQL<GetDecoderResult<TDecoder>>;
    inlineParams(): this;
}
declare namespace SQL {
    class Aliased<T = unknown> implements SQLWrapper {
        readonly sql: SQL;
        readonly fieldAlias: string;
        static readonly [entityKind]: string;
        _: {
            brand: 'SQL.Aliased';
            type: T;
        };
        constructor(sql: SQL, fieldAlias: string);
        getSQL(): SQL;
    }
}
declare class Placeholder<TName extends string = string, TValue = any> implements SQLWrapper {
    readonly name: TName;
    static readonly [entityKind]: string;
    protected: TValue;
    constructor(name: TName);
    getSQL(): SQL;
}
declare function placeholder<TName extends string>(name: TName): Placeholder<TName>;
declare function fillPlaceholders(params: unknown[], values: Record<string, unknown>): unknown[];

type RequiredKeyOnly<TKey extends string, T extends Column> = T extends AnyColumn<{
    notNull: true;
    hasDefault: false;
}> ? TKey : never;
type OptionalKeyOnly<TKey extends string, T extends Column> = TKey extends RequiredKeyOnly<TKey, T> ? never : TKey;
type SelectedFieldsFlat<TColumn extends Column> = Record<string, TColumn | SQL | SQL.Aliased>;
type SelectedFieldsFlatFull<TColumn extends Column> = Record<string, TColumn | SQL | SQL.Aliased>;
type SelectedFields<TColumn extends Column, TTable extends Table> = Record<string, SelectedFieldsFlat<TColumn>[string] | TTable | SelectedFieldsFlat<TColumn>>;
type SelectedFieldsOrdered<TColumn extends Column> = {
    path: string[];
    field: TColumn | SQL | SQL.Aliased;
}[];

interface Logger {
    logQuery(query: string, params: unknown[]): void;
}
interface LogWriter {
    write(message: string): void;
}
declare class ConsoleLogWriter implements LogWriter {
    static readonly [entityKind]: string;
    write(message: string): void;
}
declare class DefaultLogger implements Logger {
    static readonly [entityKind]: string;
    readonly writer: LogWriter;
    constructor(config?: {
        writer: LogWriter;
    });
    logQuery(query: string, params: unknown[]): void;
}
declare class NoopLogger implements Logger {
    static readonly [entityKind]: string;
    logQuery(): void;
}

type UpdateSet = Record<string, SQL | Param | null | undefined>;
type OneOrMany<T> = T | T[];
type Update<T, TUpdate> = Simplify<{
    [K in Exclude<keyof T, keyof TUpdate>]: T[K];
} & TUpdate>;
type Simplify<T> = {
    [K in keyof T]: T[K];
} & {};
type SimplifyMappedType<T> = [T] extends [unknown] ? T : never;
type ShallowRecord<K extends keyof any, T> = SimplifyMappedType<{
    [P in K]: T;
}>;
type Assume<T, U> = T extends U ? T : U;
type Equal<X, Y> = (<T>() => T extends X ? 1 : 2) extends (<T>() => T extends Y ? 1 : 2) ? true : false;
interface DrizzleTypeError<T> {
    $brand: 'DrizzleTypeError';
    $error: T;
}
type ValueOrArray<T> = T | T[];
type Or<T1, T2> = T1 extends true ? true : T2 extends true ? true : false;
type IfThenElse<If, Then, Else> = If extends true ? Then : Else;
type PromiseOf<T> = T extends Promise<infer U> ? U : T;
type Writable<T> = {
    -readonly [P in keyof T]: T[P];
};
declare function getTableColumns<T extends Table>(table: T): T['_']['columns'];
type ColumnsWithTable$3<TTableName extends string, TForeignTableName extends string, TColumns extends AnyColumn<{
    tableName: TTableName;
}>[]> = {
    [Key in keyof TColumns]: AnyColumn<{
        tableName: TForeignTableName;
    }>;
};
interface DrizzleConfig<TSchema extends Record<string, unknown> = Record<string, never>> {
    logger?: boolean | Logger;
    schema?: TSchema;
}
type KnownKeysOnly<T, U> = {
    [K in keyof T]: K extends keyof U ? T[K] : never;
};
declare function iife<T extends unknown[], U>(fn: (...args: T) => U, ...args: T): U;
type IsAny<T> = 0 extends (1 & T) ? true : false;

interface TableConfig$3<TColumn extends Column = Column<any>> {
    name: string;
    schema: string | undefined;
    columns: Record<string, TColumn>;
    dialect: string;
}
type UpdateTableConfig<T extends TableConfig$3, TUpdate extends Partial<TableConfig$3>> = Required<Update<T, TUpdate>>;
declare const IsDrizzleTable: unique symbol;
declare class Table<T extends TableConfig$3 = TableConfig$3> implements SQLWrapper {
    static readonly [entityKind]: string;
    readonly _: {
        readonly brand: 'Table';
        readonly config: T;
        readonly name: T['name'];
        readonly schema: T['schema'];
        readonly columns: T['columns'];
        readonly model: {
            select: InferModel<Table<T>>;
            insert: InferModel<Table<T>, 'insert'>;
        };
    };
    [IsDrizzleTable]: boolean;
    constructor(name: string, schema: string | undefined, baseName: string);
    getSQL(): SQL<unknown>;
}
declare function isTable(table: unknown): table is Table;
type AnyTable<TPartial extends Partial<TableConfig$3> = {}> = Table<UpdateTableConfig<TableConfig$3, TPartial>>;
declare function getTableName<T extends Table>(table: T): T['_']['name'];
type MapColumnName<TName extends string, TColumn extends Column, TDBColumNames extends boolean> = TDBColumNames extends true ? TColumn['_']['name'] : TName;
type InferModelFromColumns<TColumns extends Record<string, Column>, TInferMode extends 'select' | 'insert' = 'select', TConfig extends {
    dbColumnNames: boolean;
} = {
    dbColumnNames: false;
}> = TInferMode extends 'insert' ? Simplify<{
    [Key in keyof TColumns & string as RequiredKeyOnly<MapColumnName<Key, TColumns[Key], TConfig['dbColumnNames']>, TColumns[Key]>]: GetColumnData<TColumns[Key], 'query'>;
} & {
    [Key in keyof TColumns & string as OptionalKeyOnly<MapColumnName<Key, TColumns[Key], TConfig['dbColumnNames']>, TColumns[Key]>]?: GetColumnData<TColumns[Key], 'query'>;
}> : {
    [Key in keyof TColumns & string as MapColumnName<Key, TColumns[Key], TConfig['dbColumnNames']>]: GetColumnData<TColumns[Key], 'query'>;
};
type InferModel<TTable extends Table, TInferMode extends 'select' | 'insert' = 'select', TConfig extends {
    dbColumnNames: boolean;
} = {
    dbColumnNames: false;
}> = InferModelFromColumns<TTable['_']['columns'], TInferMode, TConfig>;

declare class CheckBuilder$2 {
    name: string;
    value: SQL;
    static readonly [entityKind]: string;
    protected brand: 'MySqlConstraintBuilder';
    constructor(name: string, value: SQL);
}
declare class Check$2 {
    table: AnyMySqlTable;
    static readonly [entityKind]: string;
    readonly name: string;
    readonly value: SQL;
    constructor(table: AnyMySqlTable, builder: CheckBuilder$2);
}
declare function check$2(name: string, value: SQL): CheckBuilder$2;

interface IndexConfig$2 {
    name: string;
    columns: IndexColumn$2[];
    /**
     * If true, the index will be created as `create unique index` instead of `create index`.
     */
    unique?: boolean;
    /**
     * If set, the index will be created as `create index ... using { 'btree' | 'hash' }`.
     */
    using?: 'btree' | 'hash';
    /**
     * If set, the index will be created as `create index ... algorythm { 'default' | 'inplace' | 'copy' }`.
     */
    algorythm?: 'default' | 'inplace' | 'copy';
    /**
     * If set, adds locks to the index creation.
     */
    lock?: 'default' | 'none' | 'shared' | 'exclusive';
}
type IndexColumn$2 = AnyMySqlColumn | SQL;
declare class IndexBuilderOn$2 {
    private name;
    private unique;
    static readonly [entityKind]: string;
    constructor(name: string, unique: boolean);
    on(...columns: [IndexColumn$2, ...IndexColumn$2[]]): IndexBuilder$2;
}
interface AnyIndexBuilder$1 {
    build(table: AnyMySqlTable): Index$2;
}
interface IndexBuilder$2 extends AnyIndexBuilder$1 {
}
declare class IndexBuilder$2 implements AnyIndexBuilder$1 {
    static readonly [entityKind]: string;
    constructor(name: string, columns: IndexColumn$2[], unique: boolean);
    using(using: IndexConfig$2['using']): this;
    algorythm(algorythm: IndexConfig$2['algorythm']): this;
    lock(lock: IndexConfig$2['lock']): this;
}
declare class Index$2 {
    static readonly [entityKind]: string;
    readonly config: IndexConfig$2 & {
        table: AnyMySqlTable;
    };
    constructor(config: IndexConfig$2, table: AnyMySqlTable);
}
type GetColumnsTableName$1<TColumns> = TColumns extends AnyMySqlColumn<{
    tableName: infer TTableName extends string;
}> | AnyMySqlColumn<{
    tableName: infer TTableName extends string;
}>[] ? TTableName : never;
declare function index$2(name: string): IndexBuilderOn$2;
declare function uniqueIndex$2(name: string): IndexBuilderOn$2;

declare function primaryKey$2<TTableName extends string, TColumns extends AnyMySqlColumn<{
    tableName: TTableName;
}>[]>(...columns: TColumns): PrimaryKeyBuilder$2;
declare class PrimaryKeyBuilder$2 {
    static readonly [entityKind]: string;
    constructor(columns: AnyMySqlColumn[]);
}
declare class PrimaryKey$2 {
    readonly table: AnyMySqlTable;
    static readonly [entityKind]: string;
    readonly columns: AnyMySqlColumn<{}>[];
    constructor(table: AnyMySqlTable, columns: AnyMySqlColumn<{}>[]);
    getName(): string;
}

declare function unique$2(name?: string): UniqueOnConstraintBuilder$2;
declare function uniqueKeyName$2(table: AnyMySqlTable, columns: string[]): string;
declare class UniqueConstraintBuilder$2 {
    private name?;
    static readonly [entityKind]: string;
    constructor(columns: AnyMySqlColumn[], name?: string | undefined);
}
declare class UniqueOnConstraintBuilder$2 {
    static readonly [entityKind]: string;
    constructor(name?: string);
    on(...columns: [AnyMySqlColumn, ...AnyMySqlColumn[]]): UniqueConstraintBuilder$2;
}
declare class UniqueConstraint$2 {
    readonly table: AnyMySqlTable;
    static readonly [entityKind]: string;
    readonly columns: AnyMySqlColumn<{}>[];
    readonly name?: string;
    readonly nullsNotDistinct: boolean;
    constructor(table: AnyMySqlTable, columns: AnyMySqlColumn<{}>[], name?: string);
    getName(): string | undefined;
}

type MySqlTableExtraConfig = Record<string, AnyIndexBuilder$1 | CheckBuilder$2 | ForeignKeyBuilder$2 | PrimaryKeyBuilder$2 | UniqueConstraintBuilder$2>;
type TableConfig$2 = TableConfig$3<MySqlColumn>;
declare class MySqlTable<T extends TableConfig$2 = TableConfig$2> extends Table<T> {
    static readonly [entityKind]: string;
    protected $columns: T['columns'];
}
type AnyMySqlTable<TPartial extends Partial<TableConfig$2> = {}> = MySqlTable<UpdateTableConfig<TableConfig$2, TPartial>>;
type MySqlTableWithColumns<T extends TableConfig$2> = MySqlTable<T> & {
    [Key in keyof T['columns']]: T['columns'][Key];
};
declare function mysqlTableWithSchema<TTableName extends string, TSchemaName extends string | undefined, TColumnsMap extends Record<string, MySqlColumnBuilder>>(name: TTableName, columns: TColumnsMap, extraConfig: ((self: BuildColumns<TTableName, TColumnsMap, 'mysql'>) => MySqlTableExtraConfig) | undefined, schema: TSchemaName, baseName?: TTableName): MySqlTableWithColumns<{
    name: TTableName;
    schema: TSchemaName;
    columns: BuildColumns<TTableName, TColumnsMap, 'mysql'>;
    dialect: 'mysql';
}>;
interface MySqlTableFn<TSchemaName extends string | undefined = undefined> {
    <TTableName extends string, TColumnsMap extends Record<string, MySqlColumnBuilder>>(name: TTableName, columns: TColumnsMap, extraConfig?: (self: BuildColumns<TTableName, TColumnsMap, 'mysql'>) => MySqlTableExtraConfig): MySqlTableWithColumns<{
        name: TTableName;
        schema: TSchemaName;
        columns: BuildColumns<TTableName, TColumnsMap, 'mysql'>;
        dialect: 'mysql';
    }>;
}
declare const mysqlTable: MySqlTableFn;
declare function mysqlTableCreator(customizeTableName: (name: string) => string): MySqlTableFn;

type UpdateDeleteAction$2 = 'cascade' | 'restrict' | 'no action' | 'set null' | 'set default';
type Reference$2 = () => {
    readonly columns: AnyMySqlColumn[];
    readonly foreignTable: AnyMySqlTable;
    readonly foreignColumns: AnyMySqlColumn[];
};
declare class ForeignKeyBuilder$2 {
    static readonly [entityKind]: string;
    constructor(config: () => {
        columns: AnyMySqlColumn[];
        foreignColumns: AnyMySqlColumn[];
    }, actions?: {
        onUpdate?: UpdateDeleteAction$2;
        onDelete?: UpdateDeleteAction$2;
    } | undefined);
    onUpdate(action: UpdateDeleteAction$2): this;
    onDelete(action: UpdateDeleteAction$2): this;
}
type AnyForeignKeyBuilder$1 = ForeignKeyBuilder$2;
declare class ForeignKey$2 {
    readonly table: AnyMySqlTable;
    static readonly [entityKind]: string;
    readonly reference: Reference$2;
    readonly onUpdate: UpdateDeleteAction$2 | undefined;
    readonly onDelete: UpdateDeleteAction$2 | undefined;
    constructor(table: AnyMySqlTable, builder: ForeignKeyBuilder$2);
    getName(): string;
}
type ColumnsWithTable$2<TTableName extends string, TColumns extends AnyMySqlColumn[]> = {
    [Key in keyof TColumns]: AnyMySqlColumn<{
        tableName: TTableName;
    }>;
};
type GetColumnsTable<TColumns extends AnyMySqlColumn | AnyMySqlColumn[]> = (TColumns extends AnyMySqlColumn ? TColumns : TColumns extends AnyMySqlColumn[] ? TColumns[number] : never) extends AnyMySqlColumn<{
    tableName: infer TTableName extends string;
}> ? TTableName : never;
declare function foreignKey$2<TTableName extends string, TForeignTableName extends string, TColumns extends [AnyMySqlColumn<{
    tableName: TTableName;
}>, ...AnyMySqlColumn<{
    tableName: TTableName;
}>[]]>(config: {
    columns: TColumns;
    foreignColumns: ColumnsWithTable$2<TForeignTableName, TColumns>;
}): ForeignKeyBuilder$2;

interface ReferenceConfig$2 {
    ref: () => AnyMySqlColumn;
    actions: {
        onUpdate?: UpdateDeleteAction$2;
        onDelete?: UpdateDeleteAction$2;
    };
}
declare abstract class MySqlColumnBuilder<T extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>, TRuntimeConfig extends object = object, TTypeConfig extends object = object, TExtraConfig extends ColumnBuilderExtraConfig = ColumnBuilderExtraConfig> extends ColumnBuilder<T, TRuntimeConfig, TTypeConfig & {
    dialect: 'mysql';
}, TExtraConfig> {
    static readonly [entityKind]: string;
    private foreignKeyConfigs;
    references(ref: ReferenceConfig$2['ref'], actions?: ReferenceConfig$2['actions']): this;
    unique(name?: string): this;
}
declare abstract class MySqlColumn<T extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>, TRuntimeConfig extends object = object> extends Column<T, TRuntimeConfig, {
    dialect: 'mysql';
}> {
    readonly table: MySqlTable;
    static readonly [entityKind]: string;
    constructor(table: MySqlTable, config: ColumnBuilderRuntimeConfig<T['data'], TRuntimeConfig>);
}
type AnyMySqlColumn<TPartial extends Partial<ColumnBaseConfig<ColumnDataType, string>> = {}> = MySqlColumn<Required<Update<ColumnBaseConfig<ColumnDataType, string>, TPartial>>>;
interface MySqlColumnWithAutoIncrementConfig {
    autoIncrement: boolean;
}
declare abstract class MySqlColumnBuilderWithAutoIncrement<T extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>, TRuntimeConfig extends object = object, TExtraConfig extends ColumnBuilderExtraConfig = ColumnBuilderExtraConfig> extends MySqlColumnBuilder<T, TRuntimeConfig & MySqlColumnWithAutoIncrementConfig, TExtraConfig> {
    static readonly [entityKind]: string;
    constructor(name: NonNullable<T['name']>, dataType: T['dataType'], columnType: T['columnType']);
    autoincrement(): HasDefault<this>;
}
declare abstract class MySqlColumnWithAutoIncrement<T extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>, TRuntimeConfig extends object = object> extends MySqlColumn<T, MySqlColumnWithAutoIncrementConfig & TRuntimeConfig> {
    static readonly [entityKind]: string;
    readonly autoIncrement: boolean;
}

declare class CheckBuilder$1 {
    name: string;
    value: SQL;
    static readonly [entityKind]: string;
    protected brand: 'PgConstraintBuilder';
    constructor(name: string, value: SQL);
}
declare class Check$1 {
    table: AnyPgTable;
    static readonly [entityKind]: string;
    readonly name: string;
    readonly value: SQL;
    constructor(table: AnyPgTable, builder: CheckBuilder$1);
}
declare function check$1(name: string, value: SQL): CheckBuilder$1;

type UpdateDeleteAction$1 = 'cascade' | 'restrict' | 'no action' | 'set null' | 'set default';
type Reference$1 = () => {
    readonly columns: PgColumn[];
    readonly foreignTable: AnyPgTable;
    readonly foreignColumns: PgColumn[];
};
declare class ForeignKeyBuilder$1 {
    static readonly [entityKind]: string;
    constructor(config: () => {
        columns: PgColumn[];
        foreignColumns: PgColumn[];
    }, actions?: {
        onUpdate?: UpdateDeleteAction$1;
        onDelete?: UpdateDeleteAction$1;
    } | undefined);
    onUpdate(action: UpdateDeleteAction$1): this;
    onDelete(action: UpdateDeleteAction$1): this;
}
type AnyForeignKeyBuilder = ForeignKeyBuilder$1;
declare class ForeignKey$1 {
    readonly table: AnyPgTable;
    static readonly [entityKind]: string;
    readonly reference: Reference$1;
    readonly onUpdate: UpdateDeleteAction$1 | undefined;
    readonly onDelete: UpdateDeleteAction$1 | undefined;
    constructor(table: AnyPgTable, builder: ForeignKeyBuilder$1);
    getName(): string;
}
type ColumnsWithTable$1<TTableName extends string, TColumns extends PgColumn[]> = {
    [Key in keyof TColumns]: AnyPgColumn<{
        tableName: TTableName;
    }>;
};
declare function foreignKey$1<TTableName extends string, TForeignTableName extends string, TColumns extends [AnyPgColumn<{
    tableName: TTableName;
}>, ...AnyPgColumn<{
    tableName: TTableName;
}>[]]>(config: {
    columns: TColumns;
    foreignColumns: ColumnsWithTable$1<TForeignTableName, TColumns>;
}): ForeignKeyBuilder$1;

interface ReferenceConfig$1 {
    ref: () => AnyPgColumn;
    actions: {
        onUpdate?: UpdateDeleteAction$1;
        onDelete?: UpdateDeleteAction$1;
    };
}
declare abstract class PgColumnBuilder<T extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>, TRuntimeConfig extends object = object, TTypeConfig extends object = object, TExtraConfig extends ColumnBuilderExtraConfig = ColumnBuilderExtraConfig> extends ColumnBuilder<T, TRuntimeConfig, TTypeConfig & {
    dialect: 'pg';
}, TExtraConfig> {
    private foreignKeyConfigs;
    static readonly [entityKind]: string;
    array(size?: number): PgArrayBuilder<{
        name: T['name'];
        dataType: 'array';
        columnType: 'PgArray';
        data: T['data'][];
        driverParam: T['driverParam'][] | string;
        enumValues: T['enumValues'];
    } & (T extends {
        notNull: true;
    } ? {
        notNull: true;
    } : {}) & (T extends {
        hasDefault: true;
    } ? {
        hasDefault: true;
    } : {}), T>;
    references(ref: ReferenceConfig$1['ref'], actions?: ReferenceConfig$1['actions']): this;
    unique(name?: string, config?: {
        nulls: 'distinct' | 'not distinct';
    }): this;
}
type AnyPgColumnBuilder = PgColumnBuilder<ColumnBuilderBaseConfig<ColumnDataType, string>>;
declare abstract class PgColumn<T extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>, TRuntimeConfig extends object = {}, TTypeConfig extends object = {}> extends Column<T, TRuntimeConfig, TTypeConfig & {
    dialect: 'pg';
}> {
    readonly table: PgTable;
    static readonly [entityKind]: string;
    constructor(table: PgTable, config: ColumnBuilderRuntimeConfig<T['data'], TRuntimeConfig>);
}
type AnyPgColumn<TPartial extends Partial<ColumnBaseConfig<ColumnDataType, string>> = {}> = PgColumn<Required<Update<ColumnBaseConfig<ColumnDataType, string>, TPartial>>>;

interface IndexConfig$1 {
    name?: string;
    columns: IndexColumn$1[];
    /**
     * If true, the index will be created as `create unique index` instead of `create index`.
     */
    unique: boolean;
    /**
     * If true, the index will be created as `create index concurrently` instead of `create index`.
     */
    concurrently?: boolean;
    /**
     * If true, the index will be created as `create index ... on only <table>` instead of `create index ... on <table>`.
     */
    only: boolean;
    /**
     * If set, the index will be created as `create index ... using <method>`.
     */
    using?: SQL;
    /**
     * If set, the index will be created as `create index ... asc | desc`.
     */
    order?: 'asc' | 'desc';
    /**
     * If set, adds `nulls first` or `nulls last` to the index.
     */
    nulls?: 'first' | 'last';
    /**
     * Condition for partial index.
     */
    where?: SQL;
}
type IndexColumn$1 = AnyPgColumn;
declare class IndexBuilderOn$1 {
    private unique;
    private name?;
    static readonly [entityKind]: string;
    constructor(unique: boolean, name?: string | undefined);
    on(...columns: [IndexColumn$1, ...IndexColumn$1[]]): IndexBuilder$1;
    onOnly(...columns: [IndexColumn$1, ...IndexColumn$1[]]): IndexBuilder$1;
}
interface AnyIndexBuilder {
    build(table: AnyPgTable): Index$1;
}
interface IndexBuilder$1 extends AnyIndexBuilder {
}
declare class IndexBuilder$1 implements AnyIndexBuilder {
    static readonly [entityKind]: string;
    constructor(columns: IndexColumn$1[], unique: boolean, only: boolean, name?: string);
    concurrently(): this;
    using(method: SQL): this;
    asc(): Omit<this, 'asc' | 'desc'>;
    desc(): Omit<this, 'asc' | 'desc'>;
    nullsFirst(): Omit<this, 'nullsFirst' | 'nullsLast'>;
    nullsLast(): Omit<this, 'nullsFirst' | 'nullsLast'>;
    where(condition: SQL): Omit<this, 'where'>;
}
declare class Index$1 {
    static readonly [entityKind]: string;
    readonly config: IndexConfig$1 & {
        table: AnyPgTable;
    };
    constructor(config: IndexConfig$1, table: AnyPgTable);
}
type GetColumnsTableName<TColumns> = TColumns extends AnyPgColumn ? TColumns['_']['name'] : TColumns extends AnyPgColumn[] ? TColumns[number]['_']['name'] : never;
declare function index$1(name?: string): IndexBuilderOn$1;
declare function uniqueIndex$1(name?: string): IndexBuilderOn$1;

declare function primaryKey$1<TTableName extends string, TColumns extends AnyPgColumn<{
    tableName: TTableName;
}>[]>(...columns: TColumns): PrimaryKeyBuilder$1;
declare class PrimaryKeyBuilder$1 {
    static readonly [entityKind]: string;
    constructor(columns: AnyPgColumn[]);
}
declare class PrimaryKey$1 {
    readonly table: AnyPgTable;
    static readonly [entityKind]: string;
    readonly columns: AnyPgColumn<{}>[];
    constructor(table: AnyPgTable, columns: AnyPgColumn<{}>[]);
    getName(): string;
}

declare function unique$1(name?: string): UniqueOnConstraintBuilder$1;
declare function uniqueKeyName$1(table: AnyPgTable, columns: string[]): string;
declare class UniqueConstraintBuilder$1 {
    private name?;
    static readonly [entityKind]: string;
    constructor(columns: PgColumn[], name?: string | undefined);
    nullsNotDistinct(): this;
}
declare class UniqueOnConstraintBuilder$1 {
    static readonly [entityKind]: string;
    constructor(name?: string);
    on(...columns: [PgColumn, ...PgColumn[]]): UniqueConstraintBuilder$1;
}
declare class UniqueConstraint$1 {
    readonly table: AnyPgTable;
    static readonly [entityKind]: string;
    readonly columns: PgColumn[];
    readonly name?: string;
    readonly nullsNotDistinct: boolean;
    constructor(table: AnyPgTable, columns: PgColumn[], nullsNotDistinct: boolean, name?: string);
    getName(): string | undefined;
}

type PgTableExtraConfig = Record<string, AnyIndexBuilder | CheckBuilder$1 | ForeignKeyBuilder$1 | PrimaryKeyBuilder$1 | UniqueConstraintBuilder$1>;
type TableConfig$1 = TableConfig$3<PgColumn>;
declare class PgTable<T extends TableConfig$1 = TableConfig$1> extends Table<T> {
    static readonly [entityKind]: string;
}
type AnyPgTable<TPartial extends Partial<TableConfig$1> = {}> = PgTable<UpdateTableConfig<TableConfig$1, TPartial>>;
type PgTableWithColumns<T extends TableConfig$1> = PgTable<T> & {
    [Key in keyof T['columns']]: T['columns'][Key];
};
interface PgTableFn<TSchema extends string | undefined = undefined> {
    <TTableName extends string, TColumnsMap extends Record<string, PgColumnBuilder>>(name: TTableName, columns: TColumnsMap, extraConfig?: (self: BuildColumns<TTableName, TColumnsMap, 'pg'>) => PgTableExtraConfig): PgTableWithColumns<{
        name: TTableName;
        schema: TSchema;
        columns: BuildColumns<TTableName, TColumnsMap, 'pg'>;
        dialect: 'pg';
    }>;
}
declare const pgTable: PgTableFn;
declare function pgTableCreator(customizeTableName: (name: string) => string): PgTableFn;

declare class PgArrayBuilder<T extends ColumnBuilderBaseConfig<'array', 'PgArray'>, TBase extends ColumnBuilderBaseConfig<ColumnDataType, string>> extends PgColumnBuilder<T, {
    baseBuilder: PgColumnBuilder<TBase>;
    size: number | undefined;
}, {
    baseBuilder: PgColumnBuilder<TBase>;
}> {
    static readonly [entityKind] = "PgArrayBuilder";
    constructor(name: string, baseBuilder: PgArrayBuilder<T, TBase>['config']['baseBuilder'], size: number | undefined);
}
declare class PgArray<T extends ColumnBaseConfig<'array', 'PgArray'>, TBase extends ColumnBuilderBaseConfig<ColumnDataType, string>> extends PgColumn<T> {
    readonly baseColumn: PgColumn;
    readonly range?: [number | undefined, number | undefined] | undefined;
    readonly size: number | undefined;
    static readonly [entityKind]: string;
    constructor(table: AnyPgTable<{
        name: T['tableName'];
    }>, config: PgArrayBuilder<T, TBase>['config'], baseColumn: PgColumn, range?: [number | undefined, number | undefined] | undefined);
    getSQLType(): string;
    mapFromDriverValue(value: unknown[] | string): T['data'];
    mapToDriverValue(value: unknown[], isNestedArray?: boolean): unknown[] | string;
}

declare class CheckBuilder {
    name: string;
    value: SQL;
    static readonly [entityKind]: string;
    protected brand: 'SQLiteConstraintBuilder';
    constructor(name: string, value: SQL);
    build(table: AnySQLiteTable): Check;
}
declare class Check {
    table: AnySQLiteTable;
    static readonly [entityKind]: string;
    _: {
        brand: 'SQLiteCheck';
    };
    readonly name: string;
    readonly value: SQL;
    constructor(table: AnySQLiteTable, builder: CheckBuilder);
}
declare function check(name: string, value: SQL): CheckBuilder;

interface IndexConfig {
    name: string;
    columns: IndexColumn[];
    unique: boolean;
    where: SQL | undefined;
}
type IndexColumn = SQLiteColumn | SQL;
declare class IndexBuilderOn {
    private name;
    private unique;
    static readonly [entityKind]: string;
    constructor(name: string, unique: boolean);
    on(...columns: [IndexColumn, ...IndexColumn[]]): IndexBuilder;
}
declare class IndexBuilder {
    static readonly [entityKind]: string;
    _: {
        brand: 'SQLiteIndexBuilder';
    };
    constructor(name: string, columns: IndexColumn[], unique: boolean);
    /**
     * Condition for partial index.
     */
    where(condition: SQL): this;
}
declare class Index {
    static readonly [entityKind]: string;
    _: {
        brand: 'SQLiteIndex';
    };
    readonly config: IndexConfig & {
        table: AnySQLiteTable;
    };
    constructor(config: IndexConfig, table: AnySQLiteTable);
}
declare function index(name: string): IndexBuilderOn;
declare function uniqueIndex(name: string): IndexBuilderOn;

declare function primaryKey<TTableName extends string, TColumns extends AnySQLiteColumn<{
    tableName: TTableName;
}>[]>(...columns: TColumns): PrimaryKeyBuilder;
declare class PrimaryKeyBuilder {
    static readonly [entityKind]: string;
    _: {
        brand: 'SQLitePrimaryKeyBuilder';
    };
    constructor(columns: SQLiteColumn[]);
}
declare class PrimaryKey {
    readonly table: AnySQLiteTable;
    static readonly [entityKind]: string;
    readonly columns: SQLiteColumn[];
    constructor(table: AnySQLiteTable, columns: SQLiteColumn[]);
    getName(): string;
}

declare function uniqueKeyName(table: SQLiteTable, columns: string[]): string;
declare function unique(name?: string): UniqueOnConstraintBuilder;
declare class UniqueConstraintBuilder {
    private name?;
    static readonly [entityKind]: string;
    constructor(columns: SQLiteColumn[], name?: string | undefined);
}
declare class UniqueOnConstraintBuilder {
    static readonly [entityKind]: string;
    constructor(name?: string);
    on(...columns: [SQLiteColumn, ...SQLiteColumn[]]): UniqueConstraintBuilder;
}
declare class UniqueConstraint {
    readonly table: SQLiteTable;
    static readonly [entityKind]: string;
    readonly columns: SQLiteColumn[];
    readonly name?: string;
    constructor(table: SQLiteTable, columns: SQLiteColumn[], name?: string);
    getName(): string | undefined;
}

type SQLiteTableExtraConfig = Record<string, IndexBuilder | CheckBuilder | ForeignKeyBuilder | PrimaryKeyBuilder | UniqueConstraintBuilder>;
type TableConfig = TableConfig$3<SQLiteColumn<any>>;
declare class SQLiteTable<T extends TableConfig = TableConfig> extends Table<T> {
    static readonly [entityKind]: string;
}
type AnySQLiteTable<TPartial extends Partial<TableConfig> = {}> = SQLiteTable<UpdateTableConfig<TableConfig, TPartial>>;
type SQLiteTableWithColumns<T extends TableConfig> = SQLiteTable<T> & {
    [Key in keyof T['columns']]: T['columns'][Key];
};
interface SQLiteTableFn<TSchema extends string | undefined = undefined> {
    <TTableName extends string, TColumnsMap extends Record<string, SQLiteColumnBuilder>>(name: TTableName, columns: TColumnsMap, extraConfig?: (self: BuildColumns<TTableName, TColumnsMap, 'sqlite'>) => SQLiteTableExtraConfig): SQLiteTableWithColumns<{
        name: TTableName;
        schema: TSchema;
        columns: BuildColumns<TTableName, TColumnsMap, 'sqlite'>;
        dialect: 'sqlite';
    }>;
}
declare const sqliteTable: SQLiteTableFn;
declare function sqliteTableCreator(customizeTableName: (name: string) => string): SQLiteTableFn;

type UpdateDeleteAction = 'cascade' | 'restrict' | 'no action' | 'set null' | 'set default';
type Reference = () => {
    readonly columns: SQLiteColumn[];
    readonly foreignTable: AnySQLiteTable;
    readonly foreignColumns: SQLiteColumn[];
};
declare class ForeignKeyBuilder {
    static readonly [entityKind]: string;
    _: {
        brand: 'SQLiteForeignKeyBuilder';
        foreignTableName: 'TForeignTableName';
    };
    constructor(config: () => {
        columns: SQLiteColumn[];
        foreignColumns: SQLiteColumn[];
    }, actions?: {
        onUpdate?: UpdateDeleteAction;
        onDelete?: UpdateDeleteAction;
    } | undefined);
    onUpdate(action: UpdateDeleteAction): this;
    onDelete(action: UpdateDeleteAction): this;
}
declare class ForeignKey {
    readonly table: AnySQLiteTable;
    static readonly [entityKind]: string;
    readonly reference: Reference;
    readonly onUpdate: UpdateDeleteAction | undefined;
    readonly onDelete: UpdateDeleteAction | undefined;
    constructor(table: AnySQLiteTable, builder: ForeignKeyBuilder);
    getName(): string;
}
type ColumnsWithTable<TTableName extends string, TColumns extends SQLiteColumn[]> = {
    [Key in keyof TColumns]: AnySQLiteColumn<{
        tableName: TTableName;
    }>;
};
declare function foreignKey<TTableName extends string, TForeignTableName extends string, TColumns extends [AnySQLiteColumn<{
    tableName: TTableName;
}>, ...AnySQLiteColumn<{
    tableName: TTableName;
}>[]]>(config: () => {
    columns: TColumns;
    foreignColumns: ColumnsWithTable<TForeignTableName, TColumns>;
}): ForeignKeyBuilder;

interface ReferenceConfig {
    ref: () => SQLiteColumn;
    actions: {
        onUpdate?: UpdateDeleteAction;
        onDelete?: UpdateDeleteAction;
    };
}
declare abstract class SQLiteColumnBuilder<T extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>, TRuntimeConfig extends object = object, TTypeConfig extends object = object, TExtraConfig extends ColumnBuilderExtraConfig = object> extends ColumnBuilder<T, TRuntimeConfig, TTypeConfig & {
    dialect: 'sqlite';
}, TExtraConfig> {
    static readonly [entityKind]: string;
    private foreignKeyConfigs;
    references(ref: ReferenceConfig['ref'], actions?: ReferenceConfig['actions']): this;
    unique(name?: string): this;
}
declare abstract class SQLiteColumn<T extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>, TRuntimeConfig extends object = object> extends Column<T, TRuntimeConfig, {
    dialect: 'sqlite';
}> {
    readonly table: SQLiteTable;
    static readonly [entityKind]: string;
    constructor(table: SQLiteTable, config: ColumnBuilderRuntimeConfig<T['data'], TRuntimeConfig>);
}
type AnySQLiteColumn<TPartial extends Partial<ColumnBaseConfig<ColumnDataType, string>> = {}> = SQLiteColumn<Required<Update<ColumnBaseConfig<ColumnDataType, string>, TPartial>>>;

type ColumnDataType = 'string' | 'number' | 'boolean' | 'array' | 'json' | 'date' | 'bigint' | 'custom' | 'buffer';
type Dialect = 'pg' | 'mysql' | 'sqlite' | 'common';
interface ColumnBuilderBaseConfig<TDataType extends ColumnDataType, TColumnType extends string> {
    name: string;
    dataType: TDataType;
    columnType: TColumnType;
    data: unknown;
    driverParam: unknown;
    enumValues: string[] | undefined;
}
type MakeColumnConfig<T extends ColumnBuilderBaseConfig<ColumnDataType, string>, TTableName extends string> = {
    name: T['name'];
    tableName: TTableName;
    dataType: T['dataType'];
    columnType: T['columnType'];
    data: T extends {
        $type: infer U;
    } ? U : T['data'];
    driverParam: T['driverParam'];
    notNull: T extends {
        notNull: true;
    } ? true : false;
    hasDefault: T extends {
        hasDefault: true;
    } ? true : false;
    enumValues: T['enumValues'];
    baseColumn: T extends {
        baseBuilder: infer U extends ColumnBuilder;
    } ? BuildColumn<TTableName, U, 'common'> : never;
} & {};
type ColumnBuilderTypeConfig<T extends ColumnBuilderBaseConfig<ColumnDataType, string>, TTypeConfig extends object = object> = {
    brand: 'ColumnBuilder';
    name: T['name'];
    dataType: T['dataType'];
    columnType: T['columnType'];
    data: T['data'];
    driverParam: T['driverParam'];
    notNull: T extends {
        notNull: infer U;
    } ? U : boolean;
    hasDefault: T extends {
        hasDefault: infer U;
    } ? U : boolean;
    enumValues: T['enumValues'];
} & TTypeConfig;
type ColumnBuilderRuntimeConfig<TData, TRuntimeConfig extends object = object> = {
    name: string;
    notNull: boolean;
    default: TData | SQL | undefined;
    hasDefault: boolean;
    primaryKey: boolean;
    isUnique: boolean;
    uniqueName: string | undefined;
    uniqueType: string | undefined;
    dataType: string;
    columnType: string;
} & TRuntimeConfig;
interface ColumnBuilderExtraConfig {
    primaryKeyHasDefault?: boolean;
}
type NotNull<T extends ColumnBuilder> = T & {
    _: {
        notNull: true;
    };
};
type HasDefault<T extends ColumnBuilder> = T & {
    _: {
        hasDefault: true;
    };
};
type $Type<T extends ColumnBuilder, TType> = T & {
    _: {
        $type: TType;
    };
};
declare abstract class ColumnBuilder<T extends ColumnBuilderBaseConfig<ColumnDataType, string> = ColumnBuilderBaseConfig<ColumnDataType, string>, TRuntimeConfig extends object = object, TTypeConfig extends object = object, TExtraConfig extends ColumnBuilderExtraConfig = ColumnBuilderExtraConfig> {
    static readonly [entityKind]: string;
    _: ColumnBuilderTypeConfig<T, TTypeConfig>;
    protected config: ColumnBuilderRuntimeConfig<T['data'], TRuntimeConfig>;
    constructor(name: T['name'], dataType: T['dataType'], columnType: T['columnType']);
    $type<TType>(): $Type<this, TType>;
    notNull(): NotNull<this>;
    default(value: (this['_'] extends {
        $type: infer U;
    } ? U : T['data']) | SQL): HasDefault<this>;
    primaryKey(): TExtraConfig['primaryKeyHasDefault'] extends true ? HasDefault<NotNull<this>> : NotNull<this>;
}
type BuildColumn<TTableName extends string, TBuilder extends ColumnBuilder, TDialect extends Dialect> = TDialect extends 'pg' ? PgColumn<MakeColumnConfig<TBuilder['_'], TTableName>> : TDialect extends 'mysql' ? MySqlColumn<MakeColumnConfig<TBuilder['_'], TTableName>> : TDialect extends 'sqlite' ? SQLiteColumn<MakeColumnConfig<TBuilder['_'], TTableName>> : TDialect extends 'common' ? Column<MakeColumnConfig<TBuilder['_'], TTableName>> : never;
type BuildColumns<TTableName extends string, TConfigMap extends Record<string, ColumnBuilder>, TDialect extends Dialect> = {
    [Key in keyof TConfigMap]: BuildColumn<TTableName, TConfigMap[Key], TDialect>;
} & {};
type ChangeColumnTableName<TColumn extends Column, TAlias extends string, TDialect extends Dialect> = TDialect extends 'pg' ? PgColumn<MakeColumnConfig<TColumn['_'], TAlias>> : TDialect extends 'mysql' ? MySqlColumn<MakeColumnConfig<TColumn['_'], TAlias>> : TDialect extends 'sqlite' ? SQLiteColumn<MakeColumnConfig<TColumn['_'], TAlias>> : never;

interface ColumnBaseConfig<TDataType extends ColumnDataType, TColumnType extends string> extends ColumnBuilderBaseConfig<TDataType, TColumnType> {
    tableName: string;
    notNull: boolean;
    hasDefault: boolean;
}
type ColumnTypeConfig<T extends ColumnBaseConfig<ColumnDataType, string>, TTypeConfig extends object> = T & {
    brand: 'Column';
    tableName: T['tableName'];
    name: T['name'];
    dataType: T['dataType'];
    columnType: T['columnType'];
    data: T['data'];
    driverParam: T['driverParam'];
    notNull: T['notNull'];
    hasDefault: T['hasDefault'];
    enumValues: T['enumValues'];
    baseColumn: T extends {
        baseColumn: infer U;
    } ? U : unknown;
} & TTypeConfig;
type ColumnRuntimeConfig<TData, TRuntimeConfig extends object> = ColumnBuilderRuntimeConfig<TData, TRuntimeConfig>;
interface Column<T extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>, TRuntimeConfig extends object = object, TTypeConfig extends object = object> extends DriverValueMapper<T['data'], T['driverParam']>, SQLWrapper {
}
declare abstract class Column<T extends ColumnBaseConfig<ColumnDataType, string> = ColumnBaseConfig<ColumnDataType, string>, TRuntimeConfig extends object = object, TTypeConfig extends object = object> implements DriverValueMapper<T['data'], T['driverParam']>, SQLWrapper {
    readonly table: Table;
    static readonly [entityKind]: string;
    readonly _: ColumnTypeConfig<T, TTypeConfig>;
    readonly name: string;
    readonly primary: boolean;
    readonly notNull: boolean;
    readonly default: T['data'] | SQL | undefined;
    readonly hasDefault: boolean;
    readonly isUnique: boolean;
    readonly uniqueName: string | undefined;
    readonly uniqueType: string | undefined;
    readonly dataType: T['dataType'];
    readonly columnType: T['columnType'];
    readonly enumValues: T['enumValues'];
    protected config: ColumnRuntimeConfig<T['data'], TRuntimeConfig>;
    constructor(table: Table, config: ColumnRuntimeConfig<T['data'], TRuntimeConfig>);
    abstract getSQLType(): string;
    mapFromDriverValue(value: unknown): unknown;
    mapToDriverValue(value: unknown): unknown;
}
type UpdateColConfig<T extends ColumnBaseConfig<ColumnDataType, string>, TUpdate extends Partial<ColumnBaseConfig<ColumnDataType, string>>> = Update<T, TUpdate>;
type AnyColumn<TPartial extends Partial<ColumnBaseConfig<ColumnDataType, string>> = {}> = Column<Required<Update<ColumnBaseConfig<ColumnDataType, string>, TPartial>>>;
type GetColumnData<TColumn extends Column, TInferMode extends 'query' | 'raw' = 'query'> = TInferMode extends 'raw' ? TColumn['_']['data'] : TColumn['_']['notNull'] extends true ? TColumn['_']['data'] : TColumn['_']['data'] | null;
type InferColumnsDataTypes<TColumns extends Record<string, Column>> = {
    [Key in keyof TColumns]: GetColumnData<TColumns[Key], 'query'>;
};

export { $Type as $, AnyColumn as A, BuildColumn as B, Column as C, DrizzleConfig as D, SelectedFields as E, SelectedFieldsOrdered as F, GetColumnData as G, HasDefault as H, InferModel as I, FakePrimitiveParam as J, Chunk as K, Logger as L, MapColumnName as M, NotNull as N, OptionalKeyOnly as O, BuildQueryConfig as P, Query as Q, RequiredKeyOnly as R, Simplify as S, Table as T, UpdateColConfig as U, View as V, QueryTypingsValue as W, SQLWrapper as X, isSQLWrapper as Y, StringChunk as Z, GetDecoderResult as _, SQL as a, IndexConfig as a$, Name as a0, name as a1, DriverValueDecoder as a2, DriverValueEncoder as a3, isDriverValueEncoder as a4, noopDecoder as a5, noopEncoder as a6, DriverValueMapper as a7, noopMapper as a8, Param as a9, IfThenElse as aA, PromiseOf as aB, Writable as aC, getTableColumns as aD, ColumnsWithTable$3 as aE, KnownKeysOnly as aF, iife as aG, IsAny as aH, ViewBaseConfig as aI, ColumnsSelection as aJ, SQLiteColumnBuilder as aK, SQLiteColumn as aL, AnySQLiteTable as aM, Index as aN, ForeignKey as aO, Check as aP, PrimaryKey as aQ, UniqueConstraint as aR, SQLiteTable as aS, CheckBuilder as aT, check as aU, ReferenceConfig as aV, AnySQLiteColumn as aW, UpdateDeleteAction as aX, Reference as aY, ForeignKeyBuilder as aZ, foreignKey as a_, param as aa, SQLChunk as ab, sql as ac, Placeholder as ad, placeholder as ae, fillPlaceholders as af, SubqueryConfig as ag, Subquery as ah, WithSubquery as ai, SelectionProxyHandler as aj, TableConfig$3 as ak, UpdateTableConfig as al, isTable as am, AnyTable as an, getTableName as ao, InferModelFromColumns as ap, UpdateSet as aq, OneOrMany as ar, Update as as, SimplifyMappedType as at, ShallowRecord as au, Assume as av, Equal as aw, DrizzleTypeError as ax, ValueOrArray as ay, Or as az, ColumnBaseConfig as b, TableConfig$2 as b$, IndexColumn as b0, IndexBuilderOn as b1, IndexBuilder as b2, index as b3, uniqueIndex as b4, primaryKey as b5, PrimaryKeyBuilder as b6, SQLiteTableExtraConfig as b7, TableConfig as b8, SQLiteTableWithColumns as b9, Check$2 as bA, PrimaryKey$2 as bB, UniqueConstraint$2 as bC, CheckBuilder$2 as bD, check$2 as bE, ReferenceConfig$2 as bF, MySqlColumnWithAutoIncrementConfig as bG, UpdateDeleteAction$2 as bH, Reference$2 as bI, ForeignKeyBuilder$2 as bJ, AnyForeignKeyBuilder$1 as bK, GetColumnsTable as bL, foreignKey$2 as bM, IndexColumn$2 as bN, IndexBuilderOn$2 as bO, AnyIndexBuilder$1 as bP, IndexBuilder$2 as bQ, GetColumnsTableName$1 as bR, index$2 as bS, uniqueIndex$2 as bT, primaryKey$2 as bU, PrimaryKeyBuilder$2 as bV, unique$2 as bW, uniqueKeyName$2 as bX, UniqueConstraintBuilder$2 as bY, UniqueOnConstraintBuilder$2 as bZ, MySqlTableExtraConfig as b_, SQLiteTableFn as ba, sqliteTable as bb, sqliteTableCreator as bc, uniqueKeyName as bd, unique as be, UniqueConstraintBuilder as bf, UniqueOnConstraintBuilder as bg, AnyMySqlTable as bh, AnyMySqlColumn as bi, MySqlColumnBuilder as bj, MySqlTable as bk, MySqlTableWithColumns as bl, AnyPgTable as bm, AnyPgColumn as bn, PgColumn as bo, IndexColumn$1 as bp, PgColumnBuilder as bq, AnyPgColumnBuilder as br, PgTable as bs, PgTableWithColumns as bt, MySqlColumnBuilderWithAutoIncrement as bu, MySqlColumnWithAutoIncrement as bv, MySqlColumn as bw, MySqlTableFn as bx, Index$2 as by, ForeignKey$2 as bz, ColumnTypeConfig as c, mysqlTableWithSchema as c0, mysqlTable as c1, mysqlTableCreator as c2, PgTableFn as c3, Index$1 as c4, ForeignKey$1 as c5, Check$1 as c6, PrimaryKey$1 as c7, UniqueConstraint$1 as c8, CheckBuilder$1 as c9, check$1 as ca, PgArrayBuilder as cb, PgArray as cc, ReferenceConfig$1 as cd, UpdateDeleteAction$1 as ce, Reference$1 as cf, ForeignKeyBuilder$1 as cg, AnyForeignKeyBuilder as ch, foreignKey$1 as ci, IndexBuilderOn$1 as cj, AnyIndexBuilder as ck, IndexBuilder$1 as cl, GetColumnsTableName as cm, index$1 as cn, uniqueIndex$1 as co, primaryKey$1 as cp, PrimaryKeyBuilder$1 as cq, unique$1 as cr, uniqueKeyName$1 as cs, UniqueConstraintBuilder$1 as ct, UniqueOnConstraintBuilder$1 as cu, PgTableExtraConfig as cv, TableConfig$1 as cw, pgTable as cx, pgTableCreator as cy, ColumnRuntimeConfig as d, entityKind as e, InferColumnsDataTypes as f, ColumnDataType as g, Dialect as h, ColumnBuilderBaseConfig as i, MakeColumnConfig as j, ColumnBuilderTypeConfig as k, ColumnBuilderRuntimeConfig as l, ColumnBuilderExtraConfig as m, ColumnBuilder as n, BuildColumns as o, ChangeColumnTableName as p, hasOwnEntityKind as q, DrizzleEntity as r, DrizzleEntityClass as s, is as t, LogWriter as u, ConsoleLogWriter as v, DefaultLogger as w, NoopLogger as x, SelectedFieldsFlat as y, SelectedFieldsFlatFull as z };
