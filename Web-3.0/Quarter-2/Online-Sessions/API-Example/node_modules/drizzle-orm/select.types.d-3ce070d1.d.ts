import { e as entityKind, bm as AnyPgTable, aF as KnownKeysOnly, Q as Query, aJ as ColumnsSelection, ah as Subquery, ai as WithSubquery, ax as DrizzleTypeError, bn as AnyPgColumn, X as SQLWrapper, a as SQL, aq as UpdateSet, a3 as DriverValueEncoder, W as QueryTypingsValue, bo as PgColumn, I as InferModel, G as GetColumnData, a9 as Param, ad as Placeholder, bp as IndexColumn, ay as ValueOrArray, bq as PgColumnBuilder, o as BuildColumns, br as AnyPgColumnBuilder, V as View, bs as PgTable, T as Table, bt as PgTableWithColumns, al as UpdateTableConfig, av as Assume, y as SelectedFieldsFlat$1, E as SelectedFields$1, F as SelectedFieldsOrdered$1 } from './column.d-04875079.js';
import { A as AddAliasToSelection, T as TypedQueryBuilder, f as SelectResultFields, G as GetSelectTableName, a as GetSelectTableSelection, S as SelectMode, J as JoinNullability, B as BuildSubquerySelection, b as SelectResult, c as JoinType, M as MapColumnsToTableAlias, d as AppendToResult, e as AppendToNullabilityMap } from './select.types.d-f5caa4d6.js';
import { T as TablesRelationalConfig, L as TableRelationalConfig, K as DBQueryConfig, V as BuildQueryResult, Q as QueryPromise, N as ExtractTablesWithRelations, R as RelationalSchemaConfig, a as Relation, a3 as BuildRelationalQueryResult } from './query-promise.d-31db3408.js';
import { MigrationMeta } from './migrator.js';

declare class RelationalQueryBuilder<TSchema extends TablesRelationalConfig, TFields extends TableRelationalConfig> {
    private fullSchema;
    private schema;
    private tableNamesMap;
    private table;
    private tableConfig;
    private dialect;
    private session;
    static readonly [entityKind]: string;
    constructor(fullSchema: Record<string, unknown>, schema: TSchema, tableNamesMap: Record<string, string>, table: AnyPgTable, tableConfig: TableRelationalConfig, dialect: PgDialect, session: PgSession);
    findMany<TConfig extends DBQueryConfig<'many', true, TSchema, TFields>>(config?: KnownKeysOnly<TConfig, DBQueryConfig<'many', true, TSchema, TFields>>): PgRelationalQuery<BuildQueryResult<TSchema, TFields, TConfig>[]>;
    findFirst<TSelection extends Omit<DBQueryConfig<'many', true, TSchema, TFields>, 'limit'>>(config?: KnownKeysOnly<TSelection, Omit<DBQueryConfig<'many', true, TSchema, TFields>, 'limit'>>): PgRelationalQuery<BuildQueryResult<TSchema, TFields, TSelection> | undefined>;
}
declare class PgRelationalQuery<TResult> extends QueryPromise<TResult> {
    private fullSchema;
    private schema;
    private tableNamesMap;
    private table;
    private tableConfig;
    private dialect;
    private session;
    private config;
    private mode;
    static readonly [entityKind]: string;
    protected $brand: 'PgRelationalQuery';
    constructor(fullSchema: Record<string, unknown>, schema: TablesRelationalConfig, tableNamesMap: Record<string, string>, table: AnyPgTable, tableConfig: TableRelationalConfig, dialect: PgDialect, session: PgSession, config: DBQueryConfig<'many', true> | true, mode: 'many' | 'first');
    private _prepare;
    prepare(name: string): PreparedQuery<PreparedQueryConfig & {
        execute: TResult;
    }>;
    execute(): Promise<TResult>;
}

interface PgRefreshMaterializedView<TQueryResult extends QueryResultHKT> extends QueryPromise<QueryResultKind<TQueryResult, never>> {
}
declare class PgRefreshMaterializedView<TQueryResult extends QueryResultHKT> extends QueryPromise<QueryResultKind<TQueryResult, never>> {
    private session;
    private dialect;
    static readonly [entityKind]: string;
    private config;
    constructor(view: PgMaterializedView, session: PgSession, dialect: PgDialect);
    concurrently(): this;
    withNoData(): this;
    toSQL(): {
        sql: Query['sql'];
        params: Query['params'];
    };
    private _prepare;
    prepare(name: string): PreparedQuery<PreparedQueryConfig & {
        execute: QueryResultKind<TQueryResult, never>;
    }>;
    execute: ReturnType<this['prepare']>['execute'];
}

type SubqueryWithSelection<TSelection extends ColumnsSelection, TAlias extends string> = Subquery<TAlias, AddAliasToSelection<TSelection, TAlias, 'pg'>> & AddAliasToSelection<TSelection, TAlias, 'pg'>;
type WithSubqueryWithSelection<TSelection extends ColumnsSelection, TAlias extends string> = WithSubquery<TAlias, AddAliasToSelection<TSelection, TAlias, 'pg'>> & AddAliasToSelection<TSelection, TAlias, 'pg'>;

declare class PgDatabase<TQueryResult extends QueryResultHKT, TFullSchema extends Record<string, unknown> = Record<string, never>, TSchema extends TablesRelationalConfig = ExtractTablesWithRelations<TFullSchema>> {
    static readonly [entityKind]: string;
    readonly _: {
        readonly schema: TSchema | undefined;
        readonly tableNamesMap: Record<string, string>;
    };
    query: TFullSchema extends Record<string, never> ? DrizzleTypeError<'Seems like the schema generic is missing - did you forget to add it to your DB type?'> : {
        [K in keyof TSchema]: RelationalQueryBuilder<TSchema, TSchema[K]>;
    };
    constructor(
    /** @internal */
    dialect: PgDialect, 
    /** @internal */
    session: PgSession<any, any, any>, schema: RelationalSchemaConfig<TSchema> | undefined);
    $with<TAlias extends string>(alias: TAlias): {
        as<TSelection extends ColumnsSelection>(qb: TypedQueryBuilder<TSelection, unknown> | ((qb: QueryBuilder) => TypedQueryBuilder<TSelection, unknown>)): WithSubqueryWithSelection<TSelection, TAlias>;
    };
    with(...queries: WithSubquery[]): {
        select: {
            (): PgSelectBuilder<undefined>;
            <TSelection extends SelectedFields>(fields: TSelection): PgSelectBuilder<TSelection, "db">;
        };
    };
    select(): PgSelectBuilder<undefined>;
    select<TSelection extends SelectedFields>(fields: TSelection): PgSelectBuilder<TSelection>;
    selectDistinct(): PgSelectBuilder<undefined>;
    selectDistinct<TSelection extends SelectedFields>(fields: TSelection): PgSelectBuilder<TSelection>;
    selectDistinctOn(on: (AnyPgColumn | SQLWrapper)[]): PgSelectBuilder<undefined>;
    selectDistinctOn<TSelection extends SelectedFields>(on: (AnyPgColumn | SQLWrapper)[], fields: TSelection): PgSelectBuilder<TSelection>;
    update<TTable extends AnyPgTable>(table: TTable): PgUpdateBuilder<TTable, TQueryResult>;
    insert<TTable extends AnyPgTable>(table: TTable): PgInsertBuilder<TTable, TQueryResult>;
    delete<TTable extends AnyPgTable>(table: TTable): PgDelete<TTable, TQueryResult>;
    refreshMaterializedView<TView extends PgMaterializedView>(view: TView): PgRefreshMaterializedView<TQueryResult>;
    execute<TRow extends Record<string, unknown> = Record<string, unknown>>(query: SQLWrapper): Promise<QueryResultKind<TQueryResult, TRow>>;
    transaction<T>(transaction: (tx: PgTransaction<TQueryResult, TFullSchema, TSchema>) => Promise<T>, config?: PgTransactionConfig): Promise<T>;
}

interface PreparedQueryConfig {
    execute: unknown;
    all: unknown;
    values: unknown;
}
declare abstract class PreparedQuery<T extends PreparedQueryConfig> {
    static readonly [entityKind]: string;
    abstract execute(placeholderValues?: Record<string, unknown>): Promise<T['execute']>;
}
interface PgTransactionConfig {
    isolationLevel?: 'read uncommitted' | 'read committed' | 'repeatable read' | 'serializable';
    accessMode?: 'read only' | 'read write';
    deferrable?: boolean;
}
declare abstract class PgSession<TQueryResult extends QueryResultHKT = QueryResultHKT, TFullSchema extends Record<string, unknown> = Record<string, never>, TSchema extends TablesRelationalConfig = Record<string, never>> {
    protected dialect: PgDialect;
    static readonly [entityKind]: string;
    constructor(dialect: PgDialect);
    abstract prepareQuery<T extends PreparedQueryConfig = PreparedQueryConfig>(query: Query, fields: SelectedFieldsOrdered | undefined, name: string | undefined, customResultMapper?: (rows: unknown[][], mapColumnValue?: (value: unknown) => unknown) => T['execute']): PreparedQuery<T>;
    execute<T>(query: SQL): Promise<T>;
    all<T = unknown>(query: SQL): Promise<T[]>;
    abstract transaction<T>(transaction: (tx: PgTransaction<TQueryResult, TFullSchema, TSchema>) => Promise<T>, config?: PgTransactionConfig): Promise<T>;
}
declare abstract class PgTransaction<TQueryResult extends QueryResultHKT, TFullSchema extends Record<string, unknown> = Record<string, never>, TSchema extends TablesRelationalConfig = Record<string, never>> extends PgDatabase<TQueryResult, TFullSchema, TSchema> {
    protected schema: {
        fullSchema: Record<string, unknown>;
        schema: TSchema;
        tableNamesMap: Record<string, string>;
    } | undefined;
    protected readonly nestedIndex: number;
    static readonly [entityKind]: string;
    constructor(dialect: PgDialect, session: PgSession<any, any, any>, schema: {
        fullSchema: Record<string, unknown>;
        schema: TSchema;
        tableNamesMap: Record<string, string>;
    } | undefined, nestedIndex?: number);
    rollback(): never;
    setTransaction(config: PgTransactionConfig): Promise<void>;
    abstract transaction<T>(transaction: (tx: PgTransaction<TQueryResult, TFullSchema, TSchema>) => Promise<T>): Promise<T>;
}
interface QueryResultHKT {
    readonly $brand: 'QueryRowHKT';
    readonly row: unknown;
    readonly type: unknown;
}
type QueryResultKind<TKind extends QueryResultHKT, TRow> = (TKind & {
    readonly row: TRow;
})['type'];

declare class PgDialect {
    static readonly [entityKind]: string;
    migrate(migrations: MigrationMeta[], session: PgSession): Promise<void>;
    escapeName(name: string): string;
    escapeParam(num: number): string;
    escapeString(str: string): string;
    buildDeleteQuery({ table, where, returning }: PgDeleteConfig): SQL;
    buildUpdateSet(table: AnyPgTable, set: UpdateSet): SQL;
    buildUpdateQuery({ table, set, where, returning }: PgUpdateConfig): SQL;
    /**
     * Builds selection SQL with provided fields/expressions
     *
     * Examples:
     *
     * `select <selection> from`
     *
     * `insert ... returning <selection>`
     *
     * If `isSingleTable` is true, then columns won't be prefixed with table name
     */
    private buildSelection;
    buildSelectQuery({ withList, fields, fieldsFlat, where, having, table, joins, orderBy, groupBy, limit, offset, lockingClauses, distinct, }: PgSelectConfig): SQL;
    buildInsertQuery({ table, values, onConflict, returning }: PgInsertConfig): SQL;
    buildRefreshMaterializedViewQuery({ view, concurrently, withNoData }: {
        view: PgMaterializedView;
        concurrently?: boolean;
        withNoData?: boolean;
    }): SQL;
    prepareTyping(encoder: DriverValueEncoder<unknown, unknown>): QueryTypingsValue;
    sqlToQuery(sql: SQL): Query;
    buildRelationalQueryWithoutPK({ fullSchema, schema, tableNamesMap, table, tableConfig, queryConfig: config, tableAlias, nestedQueryRelation, joinOn, }: {
        fullSchema: Record<string, unknown>;
        schema: TablesRelationalConfig;
        tableNamesMap: Record<string, string>;
        table: AnyPgTable;
        tableConfig: TableRelationalConfig;
        queryConfig: true | DBQueryConfig<'many', true>;
        tableAlias: string;
        nestedQueryRelation?: Relation;
        joinOn?: SQL;
    }): BuildRelationalQueryResult<AnyPgTable, PgColumn>;
}

interface PgDeleteConfig {
    where?: SQL | undefined;
    table: AnyPgTable;
    returning?: SelectedFieldsOrdered;
}
interface PgDelete<TTable extends AnyPgTable, TQueryResult extends QueryResultHKT, TReturning extends Record<string, unknown> | undefined = undefined> extends QueryPromise<TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[]> {
}
declare class PgDelete<TTable extends AnyPgTable, TQueryResult extends QueryResultHKT, TReturning extends Record<string, unknown> | undefined = undefined> extends QueryPromise<TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[]> implements SQLWrapper {
    private session;
    private dialect;
    static readonly [entityKind]: string;
    private config;
    constructor(table: TTable, session: PgSession, dialect: PgDialect);
    where(where: SQL | undefined): Omit<this, 'where'>;
    returning(): PgDelete<TTable, TQueryResult, InferModel<TTable>>;
    returning<TSelectedFields extends SelectedFieldsFlat>(fields: TSelectedFields): PgDelete<TTable, TQueryResult, SelectResultFields<TSelectedFields>>;
    toSQL(): {
        sql: Query['sql'];
        params: Query['params'];
    };
    private _prepare;
    prepare(name: string): PreparedQuery<PreparedQueryConfig & {
        execute: TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[];
    }>;
    execute: ReturnType<this['prepare']>['execute'];
}

interface PgUpdateConfig {
    where?: SQL | undefined;
    set: UpdateSet;
    table: AnyPgTable;
    returning?: SelectedFieldsOrdered;
}
type PgUpdateSetSource<TTable extends AnyPgTable> = {
    [Key in keyof TTable['_']['columns']]?: GetColumnData<TTable['_']['columns'][Key]> | SQL;
} & {};
declare class PgUpdateBuilder<TTable extends AnyPgTable, TQueryResult extends QueryResultHKT> {
    private table;
    private session;
    private dialect;
    static readonly [entityKind]: string;
    readonly _: {
        readonly table: TTable;
    };
    constructor(table: TTable, session: PgSession, dialect: PgDialect);
    set(values: PgUpdateSetSource<TTable>): PgUpdate<TTable, TQueryResult>;
}
interface PgUpdate<TTable extends AnyPgTable, TQueryResult extends QueryResultHKT, TReturning extends Record<string, unknown> | undefined = undefined> extends QueryPromise<TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[]>, SQLWrapper {
}
declare class PgUpdate<TTable extends AnyPgTable, TQueryResult extends QueryResultHKT, TReturning extends Record<string, unknown> | undefined = undefined> extends QueryPromise<TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[]> implements SQLWrapper {
    private session;
    private dialect;
    static readonly [entityKind]: string;
    readonly _: {
        readonly table: TTable;
        readonly return: TReturning;
    };
    private config;
    constructor(table: TTable, set: UpdateSet, session: PgSession, dialect: PgDialect);
    where(where: SQL | undefined): this;
    returning(): PgUpdate<TTable, TQueryResult, InferModel<TTable>>;
    returning<TSelectedFields extends SelectedFields>(fields: TSelectedFields): PgUpdate<TTable, TQueryResult, SelectResultFields<TSelectedFields>>;
    toSQL(): Omit<Query, 'typings'>;
    private _prepare;
    prepare(name: string): PreparedQuery<PreparedQueryConfig & {
        execute: TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[];
    }>;
    execute: ReturnType<this['prepare']>['execute'];
}

interface PgInsertConfig<TTable extends AnyPgTable = AnyPgTable> {
    table: TTable;
    values: Record<string, Param | SQL>[];
    onConflict?: SQL;
    returning?: SelectedFieldsOrdered;
}
type PgInsertValue<TTable extends AnyPgTable> = {
    [Key in keyof InferModel<TTable, 'insert'>]: InferModel<TTable, 'insert'>[Key] | SQL | Placeholder;
} & {};
declare class PgInsertBuilder<TTable extends AnyPgTable, TQueryResult extends QueryResultHKT> {
    private table;
    private session;
    private dialect;
    static readonly [entityKind]: string;
    constructor(table: TTable, session: PgSession, dialect: PgDialect);
    values(value: PgInsertValue<TTable>): PgInsert<TTable, TQueryResult>;
    values(values: PgInsertValue<TTable>[]): PgInsert<TTable, TQueryResult>;
}
interface PgInsert<TTable extends AnyPgTable, TQueryResult extends QueryResultHKT, TReturning extends Record<string, unknown> | undefined = undefined> extends QueryPromise<TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[]>, SQLWrapper {
}
declare class PgInsert<TTable extends AnyPgTable, TQueryResult extends QueryResultHKT, TReturning extends Record<string, unknown> | undefined = undefined> extends QueryPromise<TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[]> implements SQLWrapper {
    private session;
    private dialect;
    static readonly [entityKind]: string;
    _: {
        table: TTable;
        return: TReturning;
    };
    private config;
    constructor(table: TTable, values: PgInsertConfig['values'], session: PgSession, dialect: PgDialect);
    returning(): PgInsert<TTable, TQueryResult, InferModel<TTable>>;
    returning<TSelectedFields extends SelectedFieldsFlat>(fields: TSelectedFields): PgInsert<TTable, TQueryResult, SelectResultFields<TSelectedFields>>;
    onConflictDoNothing(config?: {
        target?: IndexColumn | IndexColumn[];
        where?: SQL;
    }): this;
    onConflictDoUpdate(config: {
        target: IndexColumn | IndexColumn[];
        where?: SQL;
        set: PgUpdateSetSource<TTable>;
    }): this;
    toSQL(): {
        sql: Query['sql'];
        params: Query['params'];
    };
    private _prepare;
    prepare(name: string): PreparedQuery<PreparedQueryConfig & {
        execute: TReturning extends undefined ? QueryResultKind<TQueryResult, never> : TReturning[];
    }>;
    execute: ReturnType<this['prepare']>['execute'];
}

type CreatePgSelectFromBuilderMode<TBuilderMode extends 'db' | 'qb', TTableName extends string | undefined, TSelection extends ColumnsSelection, TSelectMode extends SelectMode> = TBuilderMode extends 'db' ? PgSelect<TTableName, TSelection, TSelectMode> : PgSelectQueryBuilder<PgSelectQueryBuilderHKT, TTableName, TSelection, TSelectMode>;
declare class PgSelectBuilder<TSelection extends SelectedFields | undefined, TBuilderMode extends 'db' | 'qb' = 'db'> {
    static readonly [entityKind]: string;
    private fields;
    private session;
    private dialect;
    private withList;
    private distinct;
    constructor(config: {
        fields: TSelection;
        session: PgSession | undefined;
        dialect: PgDialect;
        withList?: Subquery[];
        distinct?: boolean | {
            on: (AnyPgColumn | SQLWrapper)[];
        };
    });
    /**
     * Specify the table, subquery, or other target that you're
     * building a select query against.
     *
     * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FROM|Postgres from documentation}
     */
    from<TFrom extends AnyPgTable | Subquery | PgViewBase | SQL>(source: TFrom): CreatePgSelectFromBuilderMode<TBuilderMode, GetSelectTableName<TFrom>, TSelection extends undefined ? GetSelectTableSelection<TFrom> : TSelection, TSelection extends undefined ? 'single' : 'partial'>;
}
declare abstract class PgSelectQueryBuilder<THKT extends PgSelectHKTBase, TTableName extends string | undefined, TSelection extends ColumnsSelection, TSelectMode extends SelectMode, TNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'> : {}> extends TypedQueryBuilder<BuildSubquerySelection<TSelection, TNullabilityMap>, SelectResult<TSelection, TSelectMode, TNullabilityMap>[]> {
    static readonly [entityKind]: string;
    readonly _: {
        readonly selectMode: TSelectMode;
        readonly selection: TSelection;
        readonly result: SelectResult<TSelection, TSelectMode, TNullabilityMap>[];
        readonly selectedFields: BuildSubquerySelection<TSelection, TNullabilityMap>;
    };
    protected config: PgSelectConfig;
    protected joinsNotNullableMap: Record<string, boolean>;
    private tableName;
    private isPartialSelect;
    protected session: PgSession | undefined;
    protected dialect: PgDialect;
    constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }: {
        table: PgSelectConfig['table'];
        fields: PgSelectConfig['fields'];
        isPartialSelect: boolean;
        session: PgSession | undefined;
        dialect: PgDialect;
        withList: Subquery[];
        distinct: boolean | {
            on: (AnyPgColumn | SQLWrapper)[];
        } | undefined;
    });
    private createJoin;
    /**
     * For each row of the table, include
     * values from a matching row of the joined
     * table, if there is a matching row. If not,
     * all of the columns of the joined table
     * will be set to null.
     */
    leftJoin: JoinFn<THKT, TTableName, TSelectMode, "left", TSelection, TNullabilityMap>;
    /**
     * Includes all of the rows of the joined table.
     * If there is no matching row in the main table,
     * all the columns of the main table will be
     * set to null.
     */
    rightJoin: JoinFn<THKT, TTableName, TSelectMode, "right", TSelection, TNullabilityMap>;
    /**
     * This is the default type of join.
     *
     * For each row of the table, the joined table
     * needs to have a matching row, or it will
     * be excluded from results.
     */
    innerJoin: JoinFn<THKT, TTableName, TSelectMode, "inner", TSelection, TNullabilityMap>;
    /**
     * Rows from both the main & joined are included,
     * regardless of whether or not they have matching
     * rows in the other table.
     */
    fullJoin: JoinFn<THKT, TTableName, TSelectMode, "full", TSelection, TNullabilityMap>;
    /**
     * Specify a condition to narrow the result set. Multiple
     * conditions can be combined with the `and` and `or`
     * functions.
     *
     * ## Examples
     *
     * ```ts
     * // Find cars made in the year 2000
     * db.select().from(cars).where(eq(cars.year, 2000));
     * ```
     */
    where(where: ((aliases: TSelection) => SQL | undefined) | SQL | undefined): this;
    /**
     * Sets the HAVING clause of this query, which often
     * used with GROUP BY and filters rows after they've been
     * grouped together and combined.
     *
     * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-HAVING|Postgres having clause documentation}
     */
    having(having: ((aliases: TSelection) => SQL | undefined) | SQL | undefined): this;
    /**
     * Specify the GROUP BY of this query: given
     * a list of columns or SQL expressions, Postgres will
     * combine all rows with the same values in those columns
     * into a single row.
     *
     * ## Examples
     *
     * ```ts
     * // Group and count people by their last names
     * db.select({
     *    lastName: people.lastName,
     *    count: sql<number>`count(*)::integer`
     * }).from(people).groupBy(people.lastName);
     * ```
     *
     * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-GROUPBY|Postgres GROUP BY documentation}
     */
    groupBy(builder: (aliases: TSelection) => ValueOrArray<AnyPgColumn | SQL | SQL.Aliased>): this;
    groupBy(...columns: (AnyPgColumn | SQL | SQL.Aliased)[]): this;
    /**
     * Specify the ORDER BY clause of this query: a number of
     * columns or SQL expressions that will control sorting
     * of results. You can specify whether results are in ascending
     * or descending order with the `asc()` and `desc()` operators.
     *
     * ## Examples
     *
     * ```
     * // Select cars by year released
     * db.select().from(cars).orderBy(cars.year);
     * ```
     *
     * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-ORDERBY|Postgres ORDER BY documentation}
     */
    orderBy(builder: (aliases: TSelection) => ValueOrArray<AnyPgColumn | SQL | SQL.Aliased>): this;
    orderBy(...columns: (AnyPgColumn | SQL | SQL.Aliased)[]): this;
    /**
     * Set the maximum number of rows that will be
     * returned by this query.
     *
     * ## Examples
     *
     * ```ts
     * // Get the first 10 people from this query.
     * db.select().from(people).limit(10);
     * ```
     *
     * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-LIMIT|Postgres LIMIT documentation}
     */
    limit(limit: number | Placeholder): this;
    /**
     * Skip a number of rows when returning results
     * from this query.
     *
     * ## Examples
     *
     * ```ts
     * // Get the 10th-20th people from this query.
     * db.select().from(people).offset(10).limit(10);
     * ```
     */
    offset(offset: number | Placeholder): this;
    /**
     * The FOR clause specifies a lock strength for this query
     * that controls how strictly it acquires exclusive access to
     * the rows being queried.
     *
     * {@link https://www.postgresql.org/docs/current/sql-select.html#SQL-FOR-UPDATE-SHARE|Postgres locking clause documentation}
     */
    for(strength: LockStrength, config?: LockConfig): this;
    toSQL(): {
        sql: Query['sql'];
        params: Query['params'];
    };
    as<TAlias extends string>(alias: TAlias): SubqueryWithSelection<BuildSubquerySelection<TSelection, TNullabilityMap>, TAlias>;
}
interface PgSelect<TTableName extends string | undefined, TSelection extends ColumnsSelection, TSelectMode extends SelectMode, TNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'> : {}> extends PgSelectQueryBuilder<PgSelectHKT, TTableName, TSelection, TSelectMode, TNullabilityMap>, QueryPromise<SelectResult<TSelection, TSelectMode, TNullabilityMap>[]> {
}
declare class PgSelect<TTableName extends string | undefined, TSelection, TSelectMode extends SelectMode, TNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'> : {}> extends PgSelectQueryBuilder<PgSelectHKT, TTableName, TSelection, TSelectMode, TNullabilityMap> {
    static readonly [entityKind]: string;
    private _prepare;
    /**
     * Create a prepared statement for this query. This allows
     * the database to remember this query for the given session
     * and call it by name, rather than specifying the full query.
     *
     * {@link https://www.postgresql.org/docs/current/sql-prepare.html|Postgres prepare documentation}
     */
    prepare(name: string): PreparedQuery<PreparedQueryConfig & {
        execute: SelectResult<TSelection, TSelectMode, TNullabilityMap>[];
    }>;
    execute: ReturnType<this['prepare']>['execute'];
}

declare class QueryBuilder {
    static readonly [entityKind]: string;
    private dialect;
    $with<TAlias extends string>(alias: TAlias): {
        as<TSelection extends ColumnsSelection>(qb: TypedQueryBuilder<TSelection, unknown> | ((qb: QueryBuilder) => TypedQueryBuilder<TSelection, unknown>)): WithSubqueryWithSelection<TSelection, TAlias>;
    };
    with(...queries: WithSubquery[]): {
        select: {
            (): PgSelectBuilder<undefined, 'qb'>;
            <TSelection extends SelectedFields>(fields: TSelection): PgSelectBuilder<TSelection, "qb">;
        };
        selectDistinct: {
            (): PgSelectBuilder<undefined, 'qb'>;
            <TSelection_1 extends SelectedFields>(fields: TSelection_1): PgSelectBuilder<TSelection_1, "qb">;
        };
        selectDistinctOn: {
            (on: (AnyPgColumn | SQLWrapper)[]): PgSelectBuilder<undefined, 'qb'>;
            <TSelection_2 extends SelectedFields>(on: (AnyPgColumn | SQLWrapper)[], fields: TSelection_2): PgSelectBuilder<TSelection_2, "qb">;
        };
    };
    select(): PgSelectBuilder<undefined, 'qb'>;
    select<TSelection extends SelectedFields>(fields: TSelection): PgSelectBuilder<TSelection, 'qb'>;
    selectDistinct(): PgSelectBuilder<undefined>;
    selectDistinct<TSelection extends SelectedFields>(fields: TSelection): PgSelectBuilder<TSelection>;
    selectDistinctOn(on: (AnyPgColumn | SQLWrapper)[]): PgSelectBuilder<undefined>;
    selectDistinctOn<TSelection extends SelectedFields>(on: (AnyPgColumn | SQLWrapper)[], fields: TSelection): PgSelectBuilder<TSelection>;
    private getDialect;
}

interface ViewWithConfig {
    checkOption: 'local' | 'cascaded';
    securityBarrier: boolean;
    securityInvoker: boolean;
}
declare class DefaultViewBuilderCore<TConfig extends {
    name: string;
    columns?: unknown;
}> {
    protected name: TConfig['name'];
    protected schema: string | undefined;
    static readonly [entityKind]: string;
    readonly _: {
        readonly name: TConfig['name'];
        readonly columns: TConfig['columns'];
    };
    constructor(name: TConfig['name'], schema: string | undefined);
    protected config: {
        with?: ViewWithConfig;
    };
    with(config: ViewWithConfig): this;
}
declare class ViewBuilder<TName extends string = string> extends DefaultViewBuilderCore<{
    name: TName;
}> {
    static readonly [entityKind]: string;
    as<TSelectedFields extends SelectedFields>(qb: TypedQueryBuilder<TSelectedFields> | ((qb: QueryBuilder) => TypedQueryBuilder<TSelectedFields>)): PgViewWithSelection<TName, false, AddAliasToSelection<TSelectedFields, TName, 'pg'>>;
}
declare class ManualViewBuilder<TName extends string = string, TColumns extends Record<string, PgColumnBuilder> = Record<string, PgColumnBuilder>> extends DefaultViewBuilderCore<{
    name: TName;
    columns: TColumns;
}> {
    static readonly [entityKind]: string;
    private columns;
    constructor(name: TName, columns: TColumns, schema: string | undefined);
    existing(): PgViewWithSelection<TName, true, BuildColumns<TName, TColumns, 'pg'>>;
    as(query: SQL): PgViewWithSelection<TName, false, BuildColumns<TName, TColumns, 'pg'>>;
}
interface PgMaterializedViewWithConfig {
    [Key: string]: string | number | boolean | SQL;
}
declare class MaterializedViewBuilderCore<TConfig extends {
    name: string;
    columns?: unknown;
}> {
    protected name: TConfig['name'];
    protected schema: string | undefined;
    static readonly [entityKind]: string;
    _: {
        readonly name: TConfig['name'];
        readonly columns: TConfig['columns'];
    };
    constructor(name: TConfig['name'], schema: string | undefined);
    protected config: {
        with?: PgMaterializedViewWithConfig;
        using?: string;
        tablespace?: string;
        withNoData?: boolean;
    };
    using(using: string): this;
    with(config: PgMaterializedViewWithConfig): this;
    tablespace(tablespace: string): this;
    withNoData(): this;
}
declare class MaterializedViewBuilder<TName extends string = string> extends MaterializedViewBuilderCore<{
    name: TName;
}> {
    static readonly [entityKind]: string;
    as<TSelectedFields extends SelectedFields>(qb: TypedQueryBuilder<TSelectedFields> | ((qb: QueryBuilder) => TypedQueryBuilder<TSelectedFields>)): PgMaterializedViewWithSelection<TName, false, AddAliasToSelection<TSelectedFields, TName, 'pg'>>;
}
declare class ManualMaterializedViewBuilder<TName extends string = string, TColumns extends Record<string, AnyPgColumnBuilder> = Record<string, AnyPgColumnBuilder>> extends MaterializedViewBuilderCore<{
    name: TName;
    columns: TColumns;
}> {
    static readonly [entityKind]: string;
    private columns;
    constructor(name: TName, columns: TColumns, schema: string | undefined);
    existing(): PgMaterializedViewWithSelection<TName, true, BuildColumns<TName, TColumns, 'pg'>>;
    as(query: SQL): PgMaterializedViewWithSelection<TName, false, BuildColumns<TName, TColumns, 'pg'>>;
}
declare abstract class PgViewBase<TName extends string = string, TExisting extends boolean = boolean, TSelectedFields extends ColumnsSelection = ColumnsSelection> extends View<TName, TExisting, TSelectedFields> {
    static readonly [entityKind]: string;
    readonly _: View<TName, TExisting, TSelectedFields>['_'] & {
        readonly viewBrand: 'PgViewBase';
    };
}
declare const PgViewConfig: unique symbol;
declare class PgView<TName extends string = string, TExisting extends boolean = boolean, TSelectedFields extends ColumnsSelection = ColumnsSelection> extends PgViewBase<TName, TExisting, TSelectedFields> {
    static readonly [entityKind]: string;
    [PgViewConfig]: {
        with?: ViewWithConfig;
    } | undefined;
    constructor({ pgConfig, config }: {
        pgConfig: {
            with?: ViewWithConfig;
        } | undefined;
        config: {
            name: TName;
            schema: string | undefined;
            selectedFields: SelectedFields;
            query: SQL | undefined;
        };
    });
}
type PgViewWithSelection<TName extends string = string, TExisting extends boolean = boolean, TSelectedFields extends ColumnsSelection = ColumnsSelection> = PgView<TName, TExisting, TSelectedFields> & TSelectedFields;
declare const PgMaterializedViewConfig: unique symbol;
declare class PgMaterializedView<TName extends string = string, TExisting extends boolean = boolean, TSelectedFields extends ColumnsSelection = ColumnsSelection> extends PgViewBase<TName, TExisting, TSelectedFields> {
    static readonly [entityKind]: string;
    readonly [PgMaterializedViewConfig]: {
        readonly with?: PgMaterializedViewWithConfig;
        readonly using?: string;
        readonly tablespace?: string;
        readonly withNoData?: boolean;
    } | undefined;
    constructor({ pgConfig, config }: {
        pgConfig: {
            with: PgMaterializedViewWithConfig | undefined;
            using: string | undefined;
            tablespace: string | undefined;
            withNoData: boolean | undefined;
        } | undefined;
        config: {
            name: TName;
            schema: string | undefined;
            selectedFields: SelectedFields;
            query: SQL | undefined;
        };
    });
}
type PgMaterializedViewWithSelection<TName extends string = string, TExisting extends boolean = boolean, TSelectedFields extends ColumnsSelection = ColumnsSelection> = PgMaterializedView<TName, TExisting, TSelectedFields> & TSelectedFields;
declare function pgView<TName extends string>(name: TName): ViewBuilder<TName>;
declare function pgView<TName extends string, TColumns extends Record<string, AnyPgColumnBuilder>>(name: TName, columns: TColumns): ManualViewBuilder<TName, TColumns>;
declare function pgMaterializedView<TName extends string>(name: TName): MaterializedViewBuilder<TName>;
declare function pgMaterializedView<TName extends string, TColumns extends Record<string, AnyPgColumnBuilder>>(name: TName, columns: TColumns): ManualMaterializedViewBuilder<TName, TColumns>;

interface Join {
    on: SQL | undefined;
    table: PgTable | Subquery | PgViewBase | SQL;
    alias: string | undefined;
    joinType: JoinType;
    lateral?: boolean;
}
type AnyPgSelect = PgSelect<any, any, any, any>;
type BuildAliasTable<TTable extends PgTable | View, TAlias extends string> = TTable extends Table ? PgTableWithColumns<UpdateTableConfig<TTable['_']['config'], {
    name: TAlias;
    columns: MapColumnsToTableAlias<TTable['_']['columns'], TAlias, 'pg'>;
}>> : TTable extends View ? PgViewWithSelection<TAlias, TTable['_']['existing'], MapColumnsToTableAlias<TTable['_']['selectedFields'], TAlias, 'pg'>> : never;
interface PgSelectConfig {
    withList?: Subquery[];
    fields: Record<string, unknown>;
    fieldsFlat?: SelectedFieldsOrdered;
    where?: SQL;
    having?: SQL;
    table: PgTable | Subquery | PgViewBase | SQL;
    limit?: number | Placeholder;
    offset?: number | Placeholder;
    joins?: Join[];
    orderBy?: (PgColumn | SQL | SQL.Aliased)[];
    groupBy?: (PgColumn | SQL | SQL.Aliased)[];
    lockingClauses?: {
        strength: LockStrength;
        config: LockConfig;
    }[];
    distinct?: boolean | {
        on: (PgColumn | SQLWrapper)[];
    };
}
type JoinFn<THKT extends PgSelectHKTBase, TTableName extends string | undefined, TSelectMode extends SelectMode, TJoinType extends JoinType, TSelection, TNullabilityMap extends Record<string, JoinNullability>> = <TJoinedTable extends PgTable | Subquery | PgViewBase | SQL, TJoinedName extends GetSelectTableName<TJoinedTable> = GetSelectTableName<TJoinedTable>>(table: TJoinedTable, on: ((aliases: TSelection) => SQL | undefined) | SQL | undefined) => PgSelectKind<THKT, TTableName, AppendToResult<TTableName, TSelection, TJoinedName, TJoinedTable extends Table ? TJoinedTable['_']['columns'] : TJoinedTable extends Subquery ? Assume<TJoinedTable['_']['selectedFields'], SelectedFields> : never, TSelectMode>, TSelectMode extends 'partial' ? TSelectMode : 'multiple', AppendToNullabilityMap<TNullabilityMap, TJoinedName, TJoinType>>;
type SelectedFieldsFlat = SelectedFieldsFlat$1<PgColumn>;
type SelectedFields = SelectedFields$1<PgColumn, PgTable>;
type SelectedFieldsOrdered = SelectedFieldsOrdered$1<PgColumn>;
type LockStrength = 'update' | 'no key update' | 'share' | 'key share';
type LockConfig = {
    of?: PgTable;
} & ({
    noWait: true;
    skipLocked?: undefined;
} | {
    noWait?: undefined;
    skipLocked: true;
} | {
    noWait?: undefined;
    skipLocked?: undefined;
});
interface PgSelectHKTBase {
    tableName: string | undefined;
    selection: unknown;
    selectMode: SelectMode;
    nullabilityMap: unknown;
    _type: unknown;
}
type PgSelectKind<T extends PgSelectHKTBase, TTableName extends string | undefined, TSelection, TSelectMode extends SelectMode, TNullabilityMap extends Record<string, JoinNullability>> = (T & {
    tableName: TTableName;
    selection: TSelection;
    selectMode: TSelectMode;
    nullabilityMap: TNullabilityMap;
})['_type'];
interface PgSelectQueryBuilderHKT extends PgSelectHKTBase {
    _type: PgSelectQueryBuilder<this, this['tableName'], Assume<this['selection'], ColumnsSelection>, this['selectMode'], Assume<this['nullabilityMap'], Record<string, JoinNullability>>>;
}
interface PgSelectHKT extends PgSelectHKTBase {
    _type: PgSelect<this['tableName'], Assume<this['selection'], ColumnsSelection>, this['selectMode'], Assume<this['nullabilityMap'], Record<string, JoinNullability>>>;
}

export { PgViewConfig as $, AnyPgSelect as A, BuildAliasTable as B, PgUpdateConfig as C, PgUpdateSetSource as D, PgUpdateBuilder as E, PgUpdate as F, PreparedQueryConfig as G, PreparedQuery as H, PgTransactionConfig as I, Join as J, PgSession as K, LockStrength as L, PgTransaction as M, QueryResultHKT as N, QueryResultKind as O, PgViewBase as P, QueryBuilder as Q, SubqueryWithSelection as R, SelectedFieldsFlat as S, DefaultViewBuilderCore as T, ViewBuilder as U, ViewWithConfig as V, WithSubqueryWithSelection as W, ManualViewBuilder as X, MaterializedViewBuilderCore as Y, MaterializedViewBuilder as Z, ManualMaterializedViewBuilder as _, pgMaterializedView as a, PgViewWithSelection as a0, PgMaterializedViewConfig as a1, PgMaterializedViewWithSelection as a2, PgView as b, PgMaterializedView as c, PgMaterializedViewWithConfig as d, PgDatabase as e, PgDialect as f, PgDeleteConfig as g, PgDelete as h, PgInsertConfig as i, PgInsertValue as j, PgInsertBuilder as k, PgInsert as l, PgRefreshMaterializedView as m, PgSelectBuilder as n, PgSelectQueryBuilder as o, pgView as p, PgSelect as q, PgSelectConfig as r, JoinFn as s, SelectedFields as t, SelectedFieldsOrdered as u, LockConfig as v, PgSelectHKTBase as w, PgSelectKind as x, PgSelectQueryBuilderHKT as y, PgSelectHKT as z };
