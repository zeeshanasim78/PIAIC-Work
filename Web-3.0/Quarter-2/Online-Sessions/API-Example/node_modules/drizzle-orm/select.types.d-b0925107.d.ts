import { a as SQL, aq as UpdateSet, bh as AnyMySqlTable, G as GetColumnData, e as entityKind, X as SQLWrapper, Q as Query, av as Assume, a9 as Param, I as InferModel, ad as Placeholder, bi as AnyMySqlColumn, aF as KnownKeysOnly, aJ as ColumnsSelection, h as Dialect, ah as Subquery, ai as WithSubquery, ax as DrizzleTypeError, aw as Equal, ay as ValueOrArray, bj as MySqlColumnBuilder, o as BuildColumns, V as View, bk as MySqlTable, T as Table, bl as MySqlTableWithColumns, al as UpdateTableConfig, y as SelectedFieldsFlat$1, E as SelectedFields$1, F as SelectedFieldsOrdered$1 } from './column.d-04875079.js';
import { A as AddAliasToSelection, T as TypedQueryBuilder, G as GetSelectTableName, a as GetSelectTableSelection, S as SelectMode, J as JoinNullability, B as BuildSubquerySelection, b as SelectResult, c as JoinType, M as MapColumnsToTableAlias, d as AppendToResult, e as AppendToNullabilityMap } from './select.types.d-f5caa4d6.js';
import { Q as QueryPromise, T as TablesRelationalConfig, L as TableRelationalConfig, K as DBQueryConfig, a as Relation, a3 as BuildRelationalQueryResult, V as BuildQueryResult, N as ExtractTablesWithRelations, R as RelationalSchemaConfig } from './query-promise.d-31db3408.js';
import { ResultSetHeader } from 'mysql2/promise';
import { MigrationMeta, MigrationConfig } from './migrator.js';

interface MySqlUpdateConfig {
    where?: SQL | undefined;
    set: UpdateSet;
    table: AnyMySqlTable;
    returning?: SelectedFieldsOrdered;
}
type MySqlUpdateSetSource<TTable extends AnyMySqlTable> = {
    [Key in keyof TTable['_']['columns']]?: GetColumnData<TTable['_']['columns'][Key], 'query'> | SQL;
} & {};
declare class MySqlUpdateBuilder<TTable extends AnyMySqlTable, TQueryResult extends QueryResultHKT, TPreparedQueryHKT extends PreparedQueryHKTBase> {
    private table;
    private session;
    private dialect;
    static readonly [entityKind]: string;
    protected $table: TTable;
    constructor(table: TTable, session: MySqlSession, dialect: MySqlDialect);
    set(values: MySqlUpdateSetSource<TTable>): MySqlUpdate<TTable, TQueryResult, TPreparedQueryHKT>;
}
interface MySqlUpdate<TTable extends AnyMySqlTable, TQueryResult extends QueryResultHKT, TPreparedQueryHKT extends PreparedQueryHKTBase> extends QueryPromise<QueryResultKind<TQueryResult, never>>, SQLWrapper {
}
declare class MySqlUpdate<TTable extends AnyMySqlTable, TQueryResult extends QueryResultHKT, TPreparedQueryHKT extends PreparedQueryHKTBase> extends QueryPromise<QueryResultKind<TQueryResult, never>> implements SQLWrapper {
    private session;
    private dialect;
    static readonly [entityKind]: string;
    protected $table: TTable;
    private config;
    constructor(table: TTable, set: UpdateSet, session: MySqlSession, dialect: MySqlDialect);
    where(where: SQL | undefined): this;
    toSQL(): {
        sql: Query['sql'];
        params: Query['params'];
    };
    prepare(): Assume<(TPreparedQueryHKT & {
        readonly config: PreparedQueryConfig & {
            execute: QueryResultKind<TQueryResult, never>;
            iterator: never;
        };
    })["type"], PreparedQuery<PreparedQueryConfig & {
        execute: QueryResultKind<TQueryResult, never>;
        iterator: never;
    }>>;
    execute: ReturnType<this['prepare']>['execute'];
    private createIterator;
    iterator: ReturnType<this["prepare"]>["iterator"];
}

interface MySqlInsertConfig<TTable extends AnyMySqlTable = AnyMySqlTable> {
    table: TTable;
    values: Record<string, Param | SQL>[];
    ignore: boolean;
    onConflict?: SQL;
}
type AnyMySqlInsertConfig = MySqlInsertConfig<AnyMySqlTable>;
type MySqlInsertValue<TTable extends AnyMySqlTable> = {
    [Key in keyof InferModel<TTable, 'insert'>]: InferModel<TTable, 'insert'>[Key] | SQL | Placeholder;
} & {};
declare class MySqlInsertBuilder<TTable extends AnyMySqlTable, TQueryResult extends QueryResultHKT, TPreparedQueryHKT extends PreparedQueryHKTBase> {
    private table;
    private session;
    private dialect;
    static readonly [entityKind]: string;
    private shouldIgnore;
    constructor(table: TTable, session: MySqlSession, dialect: MySqlDialect);
    ignore(): this;
    values(value: MySqlInsertValue<TTable>): MySqlInsert<TTable, TQueryResult, TPreparedQueryHKT>;
    values(values: MySqlInsertValue<TTable>[]): MySqlInsert<TTable, TQueryResult, TPreparedQueryHKT>;
}
interface MySqlInsert<TTable extends AnyMySqlTable, TQueryResult extends QueryResultHKT, TPreparedQueryHKT extends PreparedQueryHKTBase> extends QueryPromise<QueryResultKind<TQueryResult, never>>, SQLWrapper {
}
declare class MySqlInsert<TTable extends AnyMySqlTable, TQueryResult extends QueryResultHKT, TPreparedQueryHKT extends PreparedQueryHKTBase> extends QueryPromise<QueryResultKind<TQueryResult, never>> implements SQLWrapper {
    private session;
    private dialect;
    static readonly [entityKind]: string;
    protected $table: TTable;
    private config;
    constructor(table: TTable, values: MySqlInsertConfig['values'], ignore: boolean, session: MySqlSession, dialect: MySqlDialect);
    onDuplicateKeyUpdate(config: {
        set: MySqlUpdateSetSource<TTable>;
    }): this;
    toSQL(): {
        sql: Query['sql'];
        params: Query['params'];
    };
    prepare(): Assume<(TPreparedQueryHKT & {
        readonly config: PreparedQueryConfig & {
            execute: QueryResultKind<TQueryResult, never>;
            iterator: never;
        };
    })["type"], PreparedQuery<PreparedQueryConfig & {
        execute: QueryResultKind<TQueryResult, never>;
        iterator: never;
    }>>;
    execute: ReturnType<this['prepare']>['execute'];
    private createIterator;
    iterator: ReturnType<this["prepare"]>["iterator"];
}

declare class MySqlDialect {
    static readonly [entityKind]: string;
    migrate(migrations: MigrationMeta[], session: MySqlSession, config: MigrationConfig): Promise<void>;
    escapeName(name: string): string;
    escapeParam(_num: number): string;
    escapeString(str: string): string;
    buildDeleteQuery({ table, where, returning }: MySqlDeleteConfig): SQL;
    buildUpdateSet(table: AnyMySqlTable, set: UpdateSet): SQL;
    buildUpdateQuery({ table, set, where, returning }: MySqlUpdateConfig): SQL;
    /**
     * Builds selection SQL with provided fields/expressions
     *
     * Examples:
     *
     * `select <selection> from`
     *
     * `insert ... returning <selection>`
     *
     * If `isSingleTable` is true, then columns won't be prefixed with table name
     */
    private buildSelection;
    buildSelectQuery({ withList, fields, fieldsFlat, where, having, table, joins, orderBy, groupBy, limit, offset, lockingClause, distinct, }: MySqlSelectConfig): SQL;
    buildInsertQuery({ table, values, ignore, onConflict }: MySqlInsertConfig): SQL;
    sqlToQuery(sql: SQL): Query;
    buildRelationalQuery({ fullSchema, schema, tableNamesMap, table, tableConfig, queryConfig: config, tableAlias, nestedQueryRelation, joinOn, }: {
        fullSchema: Record<string, unknown>;
        schema: TablesRelationalConfig;
        tableNamesMap: Record<string, string>;
        table: AnyMySqlTable;
        tableConfig: TableRelationalConfig;
        queryConfig: true | DBQueryConfig<'many', true>;
        tableAlias: string;
        nestedQueryRelation?: Relation;
        joinOn?: SQL;
    }): BuildRelationalQueryResult<AnyMySqlTable, AnyMySqlColumn>;
    buildRelationalQueryWithoutLateralSubqueries({ fullSchema, schema, tableNamesMap, table, tableConfig, queryConfig: config, tableAlias, nestedQueryRelation, joinOn, }: {
        fullSchema: Record<string, unknown>;
        schema: TablesRelationalConfig;
        tableNamesMap: Record<string, string>;
        table: AnyMySqlTable;
        tableConfig: TableRelationalConfig;
        queryConfig: true | DBQueryConfig<'many', true>;
        tableAlias: string;
        nestedQueryRelation?: Relation;
        joinOn?: SQL;
    }): BuildRelationalQueryResult<AnyMySqlTable, AnyMySqlColumn>;
}

declare class RelationalQueryBuilder<TPreparedQueryHKT extends PreparedQueryHKTBase, TSchema extends TablesRelationalConfig, TFields extends TableRelationalConfig> {
    private fullSchema;
    private schema;
    private tableNamesMap;
    private table;
    private tableConfig;
    private dialect;
    private session;
    private mode;
    static readonly [entityKind]: string;
    constructor(fullSchema: Record<string, unknown>, schema: TSchema, tableNamesMap: Record<string, string>, table: AnyMySqlTable, tableConfig: TableRelationalConfig, dialect: MySqlDialect, session: MySqlSession, mode: Mode);
    findMany<TConfig extends DBQueryConfig<'many', true, TSchema, TFields>>(config?: KnownKeysOnly<TConfig, DBQueryConfig<'many', true, TSchema, TFields>>): MySqlRelationalQuery<TPreparedQueryHKT, BuildQueryResult<TSchema, TFields, TConfig>[]>;
    findFirst<TSelection extends Omit<DBQueryConfig<'many', true, TSchema, TFields>, 'limit'>>(config?: KnownKeysOnly<TSelection, Omit<DBQueryConfig<'many', true, TSchema, TFields>, 'limit'>>): MySqlRelationalQuery<TPreparedQueryHKT, BuildQueryResult<TSchema, TFields, TSelection> | undefined>;
}
declare class MySqlRelationalQuery<TPreparedQueryHKT extends PreparedQueryHKTBase, TResult> extends QueryPromise<TResult> {
    private fullSchema;
    private schema;
    private tableNamesMap;
    private table;
    private tableConfig;
    private dialect;
    private session;
    private config;
    private queryMode;
    private mode?;
    static readonly [entityKind]: string;
    protected $brand: 'MySqlRelationalQuery';
    constructor(fullSchema: Record<string, unknown>, schema: TablesRelationalConfig, tableNamesMap: Record<string, string>, table: AnyMySqlTable, tableConfig: TableRelationalConfig, dialect: MySqlDialect, session: MySqlSession, config: DBQueryConfig<'many', true> | true, queryMode: 'many' | 'first', mode?: Mode | undefined);
    prepare(): Assume<(TPreparedQueryHKT & {
        readonly config: PreparedQueryConfig & {
            execute: TResult;
        };
    })["type"], PreparedQuery<PreparedQueryConfig & {
        execute: TResult;
    }>>;
    execute(): Promise<TResult>;
}

type SubqueryWithSelection<TSelection extends ColumnsSelection, TAlias extends string, TDialect extends Dialect> = Subquery<TAlias, AddAliasToSelection<TSelection, TAlias, TDialect>> & AddAliasToSelection<TSelection, TAlias, TDialect>;
type WithSubqueryWithSelection<TSelection extends ColumnsSelection, TAlias extends string, TDialect extends Dialect> = WithSubquery<TAlias, AddAliasToSelection<TSelection, TAlias, TDialect>> & AddAliasToSelection<TSelection, TAlias, TDialect>;

declare class MySqlDatabase<TQueryResult extends QueryResultHKT, TPreparedQueryHKT extends PreparedQueryHKTBase, TFullSchema extends Record<string, unknown> = {}, TSchema extends TablesRelationalConfig = ExtractTablesWithRelations<TFullSchema>> {
    protected readonly mode: Mode;
    static readonly [entityKind]: string;
    readonly _: {
        readonly schema: TSchema | undefined;
        readonly tableNamesMap: Record<string, string>;
    };
    query: TFullSchema extends Record<string, never> ? DrizzleTypeError<'Seems like the schema generic is missing - did you forget to add it to your DB type?'> : {
        [K in keyof TSchema]: RelationalQueryBuilder<TPreparedQueryHKT, TSchema, TSchema[K]>;
    };
    constructor(
    /** @internal */
    dialect: MySqlDialect, 
    /** @internal */
    session: MySqlSession<any, any, any, any>, schema: RelationalSchemaConfig<TSchema> | undefined, mode: Mode);
    $with<TAlias extends string>(alias: TAlias): {
        as<TSelection extends ColumnsSelection>(qb: TypedQueryBuilder<TSelection, unknown> | ((qb: QueryBuilder) => TypedQueryBuilder<TSelection, unknown>)): WithSubqueryWithSelection<TSelection, TAlias, "mysql">;
    };
    with(...queries: WithSubquery[]): {
        select: {
            (): MySqlSelectBuilder<undefined, TPreparedQueryHKT>;
            <TSelection extends SelectedFields>(fields: TSelection): MySqlSelectBuilder<TSelection, TPreparedQueryHKT, "db">;
        };
        selectDistinct: {
            (): MySqlSelectBuilder<undefined, TPreparedQueryHKT>;
            <TSelection_1 extends SelectedFields>(fields: TSelection_1): MySqlSelectBuilder<TSelection_1, TPreparedQueryHKT, "db">;
        };
    };
    select(): MySqlSelectBuilder<undefined, TPreparedQueryHKT>;
    select<TSelection extends SelectedFields>(fields: TSelection): MySqlSelectBuilder<TSelection, TPreparedQueryHKT>;
    selectDistinct(): MySqlSelectBuilder<undefined, TPreparedQueryHKT>;
    selectDistinct<TSelection extends SelectedFields>(fields: TSelection): MySqlSelectBuilder<TSelection, TPreparedQueryHKT>;
    update<TTable extends AnyMySqlTable>(table: TTable): MySqlUpdateBuilder<TTable, TQueryResult, TPreparedQueryHKT>;
    insert<TTable extends AnyMySqlTable>(table: TTable): MySqlInsertBuilder<TTable, TQueryResult, TPreparedQueryHKT>;
    delete<TTable extends AnyMySqlTable>(table: TTable): MySqlDelete<TTable, TQueryResult, TPreparedQueryHKT>;
    execute<T extends {
        [column: string]: any;
    } = ResultSetHeader>(query: SQLWrapper): Promise<QueryResultKind<TQueryResult, T>>;
    transaction<T>(transaction: (tx: MySqlTransaction<TQueryResult, TPreparedQueryHKT, TFullSchema, TSchema>, config?: MySqlTransactionConfig) => Promise<T>, config?: MySqlTransactionConfig): Promise<T>;
}

type Mode = 'default' | 'planetscale';
interface QueryResultHKT {
    readonly $brand: 'MySqlQueryRowHKT';
    readonly row: unknown;
    readonly type: unknown;
}
type QueryResultKind<TKind extends QueryResultHKT, TRow> = (TKind & {
    readonly row: TRow;
})['type'];
interface PreparedQueryConfig {
    execute: unknown;
    iterator: unknown;
}
interface PreparedQueryHKT {
    readonly $brand: 'MySqlPreparedQueryHKT';
    readonly config: unknown;
    readonly type: unknown;
}
type PreparedQueryKind<TKind extends PreparedQueryHKT, TConfig extends PreparedQueryConfig, TAssume extends boolean = false> = Equal<TAssume, true> extends true ? Assume<(TKind & {
    readonly config: TConfig;
})['type'], PreparedQuery<TConfig>> : (TKind & {
    readonly config: TConfig;
})['type'];
declare abstract class PreparedQuery<T extends PreparedQueryConfig> {
    static readonly [entityKind]: string;
    abstract execute(placeholderValues?: Record<string, unknown>): Promise<T['execute']>;
    abstract iterator(placeholderValues?: Record<string, unknown>): AsyncGenerator<T['iterator']>;
}
interface MySqlTransactionConfig {
    withConsistentSnapshot?: boolean;
    accessMode?: 'read only' | 'read write';
    isolationLevel: 'read uncommitted' | 'read committed' | 'repeatable read' | 'serializable';
}
declare abstract class MySqlSession<TQueryResult extends QueryResultHKT = QueryResultHKT, TPreparedQueryHKT extends PreparedQueryHKTBase = PreparedQueryHKTBase, TFullSchema extends Record<string, unknown> = Record<string, never>, TSchema extends TablesRelationalConfig = Record<string, never>> {
    protected dialect: MySqlDialect;
    static readonly [entityKind]: string;
    constructor(dialect: MySqlDialect);
    abstract prepareQuery<T extends PreparedQueryConfig, TPreparedQueryHKT extends PreparedQueryHKT>(query: Query, fields: SelectedFieldsOrdered | undefined, customResultMapper?: (rows: unknown[][]) => T['execute']): PreparedQueryKind<TPreparedQueryHKT, T>;
    execute<T>(query: SQL): Promise<T>;
    abstract all<T = unknown>(query: SQL): Promise<T[]>;
    abstract transaction<T>(transaction: (tx: MySqlTransaction<TQueryResult, TPreparedQueryHKT, TFullSchema, TSchema>) => Promise<T>, config?: MySqlTransactionConfig): Promise<T>;
    protected getSetTransactionSQL(config: MySqlTransactionConfig): SQL | undefined;
    protected getStartTransactionSQL(config: MySqlTransactionConfig): SQL | undefined;
}
declare abstract class MySqlTransaction<TQueryResult extends QueryResultHKT, TPreparedQueryHKT extends PreparedQueryHKTBase, TFullSchema extends Record<string, unknown> = Record<string, never>, TSchema extends TablesRelationalConfig = Record<string, never>> extends MySqlDatabase<TQueryResult, TPreparedQueryHKT, TFullSchema, TSchema> {
    protected schema: RelationalSchemaConfig<TSchema> | undefined;
    protected readonly nestedIndex: number;
    static readonly [entityKind]: string;
    constructor(dialect: MySqlDialect, session: MySqlSession, schema: RelationalSchemaConfig<TSchema> | undefined, nestedIndex: number, mode: Mode);
    rollback(): never;
    /** Nested transactions (aka savepoints) only work with InnoDB engine. */
    abstract transaction<T>(transaction: (tx: MySqlTransaction<TQueryResult, TPreparedQueryHKT, TFullSchema, TSchema>) => Promise<T>): Promise<T>;
}
interface PreparedQueryHKTBase extends PreparedQueryHKT {
    type: PreparedQuery<Assume<this['config'], PreparedQueryConfig>>;
}

interface MySqlDeleteConfig {
    where?: SQL | undefined;
    table: AnyMySqlTable;
    returning?: SelectedFieldsOrdered;
}
interface MySqlDelete<TTable extends AnyMySqlTable, TQueryResult extends QueryResultHKT, TPreparedQueryHKT extends PreparedQueryHKTBase> extends QueryPromise<QueryResultKind<TQueryResult, never>> {
}
declare class MySqlDelete<TTable extends AnyMySqlTable, TQueryResult extends QueryResultHKT, TPreparedQueryHKT extends PreparedQueryHKTBase> extends QueryPromise<QueryResultKind<TQueryResult, never>> implements SQLWrapper {
    private table;
    private session;
    private dialect;
    static readonly [entityKind]: string;
    private config;
    constructor(table: TTable, session: MySqlSession, dialect: MySqlDialect);
    where(where: SQL | undefined): Omit<this, 'where'>;
    toSQL(): {
        sql: Query['sql'];
        params: Query['params'];
    };
    prepare(): Assume<(TPreparedQueryHKT & {
        readonly config: PreparedQueryConfig & {
            execute: QueryResultKind<TQueryResult, never>;
            iterator: never;
        };
    })["type"], PreparedQuery<PreparedQueryConfig & {
        execute: QueryResultKind<TQueryResult, never>;
        iterator: never;
    }>>;
    execute: ReturnType<this['prepare']>['execute'];
    private createIterator;
    iterator: ReturnType<this["prepare"]>["iterator"];
}

type CreateMySqlSelectFromBuilderMode<TBuilderMode extends 'db' | 'qb', TTableName extends string | undefined, TSelection extends ColumnsSelection, TSelectMode extends SelectMode, TPreparedQueryHKT extends PreparedQueryHKTBase> = TBuilderMode extends 'db' ? MySqlSelect<TTableName, TSelection, TSelectMode, TPreparedQueryHKT> : MySqlSelectQueryBuilder<MySqlSelectQueryBuilderHKT, TTableName, TSelection, TSelectMode>;
declare class MySqlSelectBuilder<TSelection extends SelectedFields | undefined, TPreparedQueryHKT extends PreparedQueryHKTBase, TBuilderMode extends 'db' | 'qb' = 'db'> {
    static readonly [entityKind]: string;
    private fields;
    private session;
    private dialect;
    private withList;
    private distinct;
    constructor(config: {
        fields: TSelection;
        session: MySqlSession | undefined;
        dialect: MySqlDialect;
        withList?: Subquery[];
        distinct?: boolean;
    });
    from<TFrom extends AnyMySqlTable | Subquery | MySqlViewBase | SQL>(source: TFrom): CreateMySqlSelectFromBuilderMode<TBuilderMode, GetSelectTableName<TFrom>, TSelection extends undefined ? GetSelectTableSelection<TFrom> : TSelection, TSelection extends undefined ? 'single' : 'partial', TPreparedQueryHKT>;
}
declare abstract class MySqlSelectQueryBuilder<THKT extends MySqlSelectHKTBase, TTableName extends string | undefined, TSelection extends ColumnsSelection, TSelectMode extends SelectMode, TNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'> : {}> extends TypedQueryBuilder<BuildSubquerySelection<TSelection, TNullabilityMap>, SelectResult<TSelection, TSelectMode, TNullabilityMap>[]> {
    static readonly [entityKind]: string;
    readonly _: {
        selectMode: TSelectMode;
        selection: TSelection;
        result: SelectResult<TSelection, TSelectMode, TNullabilityMap>[];
        selectedFields: BuildSubquerySelection<TSelection, TNullabilityMap>;
    };
    protected config: MySqlSelectConfig;
    protected joinsNotNullableMap: Record<string, boolean>;
    private tableName;
    private isPartialSelect;
    protected dialect: MySqlDialect;
    constructor({ table, fields, isPartialSelect, session, dialect, withList, distinct }: {
        table: MySqlSelectConfig['table'];
        fields: MySqlSelectConfig['fields'];
        isPartialSelect: boolean;
        session: MySqlSession | undefined;
        dialect: MySqlDialect;
        withList: Subquery[];
        distinct: boolean | undefined;
    });
    private createJoin;
    leftJoin: JoinFn<THKT, TTableName, TSelectMode, "left", TSelection, TNullabilityMap>;
    rightJoin: JoinFn<THKT, TTableName, TSelectMode, "right", TSelection, TNullabilityMap>;
    innerJoin: JoinFn<THKT, TTableName, TSelectMode, "inner", TSelection, TNullabilityMap>;
    fullJoin: JoinFn<THKT, TTableName, TSelectMode, "full", TSelection, TNullabilityMap>;
    where(where: ((aliases: TSelection) => SQL | undefined) | SQL | undefined): this;
    having(having: ((aliases: TSelection) => SQL | undefined) | SQL | undefined): this;
    groupBy(builder: (aliases: TSelection) => ValueOrArray<AnyMySqlColumn | SQL | SQL.Aliased>): this;
    groupBy(...columns: (AnyMySqlColumn | SQL | SQL.Aliased)[]): this;
    orderBy(builder: (aliases: TSelection) => ValueOrArray<AnyMySqlColumn | SQL | SQL.Aliased>): this;
    orderBy(...columns: (AnyMySqlColumn | SQL | SQL.Aliased)[]): this;
    limit(limit: number): this;
    offset(offset: number): this;
    for(strength: LockStrength, config?: LockConfig): this;
    toSQL(): {
        sql: Query['sql'];
        params: Query['params'];
    };
    as<TAlias extends string>(alias: TAlias): SubqueryWithSelection<BuildSubquerySelection<TSelection, TNullabilityMap>, TAlias, 'mysql'>;
}
interface MySqlSelect<TTableName extends string | undefined, TSelection extends ColumnsSelection, TSelectMode extends SelectMode, TPreparedQueryHKT extends PreparedQueryHKTBase, TNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'> : {}> extends MySqlSelectQueryBuilder<MySqlSelectHKT, TTableName, TSelection, TSelectMode, TNullabilityMap>, QueryPromise<SelectResult<TSelection, TSelectMode, TNullabilityMap>[]> {
}
declare class MySqlSelect<TTableName extends string | undefined, TSelection, TSelectMode extends SelectMode, TPreparedQueryHKT extends PreparedQueryHKTBase, TNullabilityMap extends Record<string, JoinNullability> = TTableName extends string ? Record<TTableName, 'not-null'> : {}> extends MySqlSelectQueryBuilder<MySqlSelectHKT, TTableName, TSelection, TSelectMode, TNullabilityMap> {
    static readonly [entityKind]: string;
    prepare(): Assume<(TPreparedQueryHKT & {
        readonly config: PreparedQueryConfig & {
            execute: SelectResult<TSelection, TSelectMode, TNullabilityMap>[];
            iterator: SelectResult<TSelection, TSelectMode, TNullabilityMap>;
        };
    })["type"], PreparedQuery<PreparedQueryConfig & {
        execute: SelectResult<TSelection, TSelectMode, TNullabilityMap>[];
        iterator: SelectResult<TSelection, TSelectMode, TNullabilityMap>;
    }>>;
    execute: ReturnType<this["prepare"]>["execute"];
    private createIterator;
    iterator: ReturnType<this["prepare"]>["iterator"];
}

declare class QueryBuilder {
    static readonly [entityKind]: string;
    private dialect;
    $with<TAlias extends string>(alias: TAlias): {
        as<TSelection extends ColumnsSelection>(qb: TypedQueryBuilder<TSelection, unknown> | ((qb: QueryBuilder) => TypedQueryBuilder<TSelection, unknown>)): WithSubqueryWithSelection<TSelection, TAlias, "mysql">;
    };
    with(...queries: WithSubquery[]): {
        select: {
            (): MySqlSelectBuilder<undefined, never, 'qb'>;
            <TSelection extends SelectedFields>(fields: TSelection): MySqlSelectBuilder<TSelection, never, "qb">;
        };
        selectDistinct: {
            (): MySqlSelectBuilder<undefined, never, 'qb'>;
            <TSelection_1 extends SelectedFields>(fields: TSelection_1): MySqlSelectBuilder<TSelection_1, never, "qb">;
        };
    };
    select(): MySqlSelectBuilder<undefined, never, 'qb'>;
    select<TSelection extends SelectedFields>(fields: TSelection): MySqlSelectBuilder<TSelection, never, 'qb'>;
    selectDistinct(): MySqlSelectBuilder<undefined, never, 'qb'>;
    selectDistinct<TSelection extends SelectedFields>(fields: TSelection): MySqlSelectBuilder<TSelection, never, 'qb'>;
    private getDialect;
}

interface ViewBuilderConfig {
    algorithm?: 'undefined' | 'merge' | 'temptable';
    definer?: string;
    sqlSecurity?: 'definer' | 'invoker';
    withCheckOption?: 'cascaded' | 'local';
}
declare class ViewBuilderCore<TConfig extends {
    name: string;
    columns?: unknown;
}> {
    protected name: TConfig['name'];
    protected schema: string | undefined;
    static readonly [entityKind]: string;
    readonly _: {
        readonly name: TConfig['name'];
        readonly columns: TConfig['columns'];
    };
    constructor(name: TConfig['name'], schema: string | undefined);
    protected config: ViewBuilderConfig;
    algorithm(algorithm: Exclude<ViewBuilderConfig['algorithm'], undefined>): this;
    definer(definer: Exclude<ViewBuilderConfig['definer'], undefined>): this;
    sqlSecurity(sqlSecurity: Exclude<ViewBuilderConfig['sqlSecurity'], undefined>): this;
    withCheckOption(withCheckOption?: Exclude<ViewBuilderConfig['withCheckOption'], undefined>): this;
}
declare class ViewBuilder<TName extends string = string> extends ViewBuilderCore<{
    name: TName;
}> {
    static readonly [entityKind]: string;
    as<TSelectedFields extends SelectedFields>(qb: TypedQueryBuilder<TSelectedFields> | ((qb: QueryBuilder) => TypedQueryBuilder<TSelectedFields>)): MySqlViewWithSelection<TName, false, AddAliasToSelection<TSelectedFields, TName, 'mysql'>>;
}
declare class ManualViewBuilder<TName extends string = string, TColumns extends Record<string, MySqlColumnBuilder> = Record<string, MySqlColumnBuilder>> extends ViewBuilderCore<{
    name: TName;
    columns: TColumns;
}> {
    static readonly [entityKind]: string;
    private columns;
    constructor(name: TName, columns: TColumns, schema: string | undefined);
    existing(): MySqlViewWithSelection<TName, true, BuildColumns<TName, TColumns, 'mysql'>>;
    as(query: SQL): MySqlViewWithSelection<TName, false, BuildColumns<TName, TColumns, 'mysql'>>;
}
declare abstract class MySqlViewBase<TName extends string = string, TExisting extends boolean = boolean, TSelectedFields extends ColumnsSelection = ColumnsSelection> extends View<TName, TExisting, TSelectedFields> {
    static readonly [entityKind]: string;
    readonly _: View<TName, TExisting, TSelectedFields>['_'] & {
        readonly viewBrand: 'MySqlViewBase';
    };
}
declare const MySqlViewConfig: unique symbol;
declare class MySqlView<TName extends string = string, TExisting extends boolean = boolean, TSelectedFields extends ColumnsSelection = ColumnsSelection> extends MySqlViewBase<TName, TExisting, TSelectedFields> {
    static readonly [entityKind]: string;
    protected $MySqlViewBrand: 'MySqlView';
    [MySqlViewConfig]: ViewBuilderConfig | undefined;
    constructor({ mysqlConfig, config }: {
        mysqlConfig: ViewBuilderConfig | undefined;
        config: {
            name: TName;
            schema: string | undefined;
            selectedFields: SelectedFields;
            query: SQL | undefined;
        };
    });
}
type MySqlViewWithSelection<TName extends string, TExisting extends boolean, TSelectedFields extends ColumnsSelection> = MySqlView<TName, TExisting, TSelectedFields> & TSelectedFields;
declare function mysqlView<TName extends string>(name: TName): ViewBuilder<TName>;
declare function mysqlView<TName extends string, TColumns extends Record<string, MySqlColumnBuilder>>(name: TName, columns: TColumns): ManualViewBuilder<TName, TColumns>;

interface Join {
    on: SQL | undefined;
    table: AnyMySqlTable | Subquery | MySqlViewBase | SQL;
    alias: string | undefined;
    joinType: JoinType;
    lateral?: boolean;
}
type AnyMySqlSelect = MySqlSelect<any, any, any, any>;
type BuildAliasTable<TTable extends MySqlTable | View, TAlias extends string> = TTable extends Table ? MySqlTableWithColumns<UpdateTableConfig<TTable['_']['config'], {
    name: TAlias;
    columns: MapColumnsToTableAlias<TTable['_']['columns'], TAlias, 'mysql'>;
}>> : TTable extends View ? MySqlViewWithSelection<TAlias, TTable['_']['existing'], MapColumnsToTableAlias<TTable['_']['selectedFields'], TAlias, 'mysql'>> : never;
interface MySqlSelectConfig {
    withList?: Subquery[];
    fields: Record<string, unknown>;
    fieldsFlat?: SelectedFieldsOrdered;
    where?: SQL;
    having?: SQL;
    table: AnyMySqlTable | Subquery | MySqlViewBase | SQL;
    limit?: number | Placeholder;
    offset?: number | Placeholder;
    joins?: Join[];
    orderBy?: (AnyMySqlColumn | SQL | SQL.Aliased)[];
    groupBy?: (AnyMySqlColumn | SQL | SQL.Aliased)[];
    lockingClause?: {
        strength: LockStrength;
        config: LockConfig;
    };
    distinct?: boolean;
}
type JoinFn<THKT extends MySqlSelectHKTBase, TTableName extends string | undefined, TSelectMode extends SelectMode, TJoinType extends JoinType, TSelection, TNullabilityMap extends Record<string, JoinNullability>> = <TJoinedTable extends AnyMySqlTable | Subquery | MySqlViewBase | SQL, TJoinedName extends GetSelectTableName<TJoinedTable> = GetSelectTableName<TJoinedTable>>(table: TJoinedTable, on: ((aliases: TSelection) => SQL | undefined) | SQL | undefined) => MySqlSelectKind<THKT, TTableName, AppendToResult<TTableName, TSelection, TJoinedName, TJoinedTable extends AnyMySqlTable ? TJoinedTable['_']['columns'] : TJoinedTable extends Subquery ? Assume<TJoinedTable['_']['selectedFields'], SelectedFields> : never, TSelectMode>, TSelectMode extends 'partial' ? TSelectMode : 'multiple', AppendToNullabilityMap<TNullabilityMap, TJoinedName, TJoinType>>;
type SelectedFieldsFlat = SelectedFieldsFlat$1<AnyMySqlColumn>;
type SelectedFields = SelectedFields$1<AnyMySqlColumn, AnyMySqlTable>;
type SelectedFieldsOrdered = SelectedFieldsOrdered$1<AnyMySqlColumn>;
type LockStrength = 'update' | 'share';
type LockConfig = {
    noWait: true;
    skipLocked?: undefined;
} | {
    noWait?: undefined;
    skipLocked: true;
} | {
    noWait?: undefined;
    skipLocked?: undefined;
};
interface MySqlSelectHKTBase {
    tableName: string | undefined;
    selection: unknown;
    selectMode: SelectMode;
    preparedQueryHKT: unknown;
    nullabilityMap: unknown;
    _type: unknown;
}
type MySqlSelectKind<T extends MySqlSelectHKTBase, TTableName extends string | undefined, TSelection, TSelectMode extends SelectMode, TNullabilityMap extends Record<string, JoinNullability>> = (T & {
    tableName: TTableName;
    selection: TSelection;
    selectMode: TSelectMode;
    nullabilityMap: TNullabilityMap;
})['_type'];
interface MySqlSelectQueryBuilderHKT extends MySqlSelectHKTBase {
    _type: MySqlSelectQueryBuilder<this, this['tableName'], Assume<this['selection'], ColumnsSelection>, this['selectMode'], Assume<this['nullabilityMap'], Record<string, JoinNullability>>>;
}
interface MySqlSelectHKT extends MySqlSelectHKTBase {
    _type: MySqlSelect<this['tableName'], Assume<this['selection'], ColumnsSelection>, this['selectMode'], Assume<this['preparedQueryHKT'], PreparedQueryHKTBase>, Assume<this['nullabilityMap'], Record<string, JoinNullability>>>;
}

export { AnyMySqlInsertConfig as A, BuildAliasTable as B, MySqlUpdate as C, Mode as D, QueryResultHKT as E, QueryResultKind as F, PreparedQueryHKT as G, PreparedQueryKind as H, PreparedQuery as I, Join as J, MySqlTransactionConfig as K, LockStrength as L, MySqlViewBase as M, MySqlSession as N, MySqlTransaction as O, PreparedQueryConfig as P, QueryBuilder as Q, PreparedQueryHKTBase as R, SelectedFieldsFlat as S, SubqueryWithSelection as T, ViewBuilderCore as U, ViewBuilderConfig as V, WithSubqueryWithSelection as W, ViewBuilder as X, ManualViewBuilder as Y, MySqlViewConfig as Z, MySqlViewWithSelection as _, MySqlView as a, MySqlDatabase as b, MySqlDialect as c, MySqlDeleteConfig as d, MySqlDelete as e, MySqlInsertConfig as f, MySqlInsertValue as g, MySqlInsertBuilder as h, MySqlInsert as i, MySqlSelectBuilder as j, MySqlSelectQueryBuilder as k, MySqlSelect as l, mysqlView as m, AnyMySqlSelect as n, MySqlSelectConfig as o, JoinFn as p, SelectedFields as q, SelectedFieldsOrdered as r, LockConfig as s, MySqlSelectHKTBase as t, MySqlSelectKind as u, MySqlSelectQueryBuilderHKT as v, MySqlSelectHKT as w, MySqlUpdateConfig as x, MySqlUpdateSetSource as y, MySqlUpdateBuilder as z };
